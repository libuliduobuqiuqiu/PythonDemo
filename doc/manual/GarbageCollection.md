Python垃圾回收机制：
- 引用计数
- 标记-清除
- 分代回收

### 引用计数

> 对每个对象都有一个引用计数器（ob_refcnt），对象的引用计数器变为0之后，系统就会自动进行清理；

引用计数器加1的情况：
1. 对象被创建
2. 对象被引用
3. 对象被作为参数传入到另外的函数
4. 对象作为元素被存储在一个容器中（列表、元组、字典、集合）

引用计数减1的情况：
1. 显式删除一个对象
2. 变量赋值为其他值，原对象的引用计数器减一
3. 对象从容器中删除
4. 对象离开原有作用域

遗留问题：如果出现对象出现循环引用，对象就会一直驻留在内存中，引用计数就没办法解决这个问题；

### 标记-清除

> 标记-清除分为两个阶段，分别是标记阶段：将所有活动对象打上标记，清除阶段：将所有没有打上标记的对象（非活动对象）进行清除；


标记阶段：
1. 从程序的根对象开始（全局变量、调用栈、寄存器），通过引用关系追踪所有可达对象，将他们标记为存活；
2. 标记完成后，未被标记的对象即为垃圾；

清除阶段：
1. 在清除阶段，系统会遍历整个堆，然后将未被标记的对象进行释放；
2. 对于清除阶段可能会导致内存出现不连续的空闲块，所以清除过程会进行合并内存的操作；

遗留的问题：由于清除过程中需要遍历整个堆，可能暂停应用程序的执行，来保证新的对象没有分配和现有对象没有被引用；

### 分代回收

> 分代回收基于：对象存活时间越长，越不可能是垃圾，应该减少收集操作。这样在执行标记-清除时可以有效减少遍历的对象数，从而提高垃圾回收的速度。

根据上述的观察，分代回收根据不同存活时间的对象分成不同的代：
- 年轻代：大部分新创键的对象被分配到年轻代，由于对象的生命周期很短；（垃圾回收频率高）
- 中年代：经过一次或者多次年轻代的垃圾回收，仍然存活的对象会被分配到中年代；（垃圾回收频率低）
- 老年代：经过多次中年代的垃圾回收后，仍然存活的对象会被分配到老年代；（垃圾回收频率比中年代低）
（当分配对象的个数减去释放对象的个数大于某个阈值，就会对应第几代进行gc垃圾回收检查）

总的来说，分代回收可以理解为标记-清除机制的一种扩展或者补充，在标记-清除的基础上引入对象生命周期的概念。将对象分为不同的代，从而采取不同的垃圾回收策略，提高整体的垃圾回收效率。（以空间换时间的方式）


参考链接：
> https://juejin.cn/post/6844903966241718279
> https://blog.csdn.net/weixin_38477351/article/details/106533436

