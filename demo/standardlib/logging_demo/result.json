{"traceEvents":[{"ph":"M","pid":4936,"tid":4936,"name":"process_name","args":{"name":"MainProcess"}},{"ph":"M","pid":4936,"tid":16712,"name":"thread_name","args":{"name":"MainThread"}},{"pid":4936,"tid":16712,"ts":109146836248.7,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146836249.8,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836250.2,"ph":"X","cat":"fee","dur":0.5,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146836250.9,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836251.1,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146836248.4,"ph":"X","cat":"fee","dur":3.4,"name":"_handle_fromlist (<frozen importlib._bootstrap>:997)"},{"pid":4936,"tid":16712,"ts":109146836252.82,"ph":"X","cat":"fee","dur":0.18,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146836253.2,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836253.5,"ph":"X","cat":"fee","dur":0.5,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146836252.8,"ph":"X","cat":"fee","dur":1.3,"name":"_handle_fromlist (<frozen importlib._bootstrap>:997)"},{"pid":4936,"tid":16712,"ts":109146836259.8,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836261.9,"ph":"X","cat":"fee","dur":0.8,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146836260.9,"ph":"X","cat":"fee","dur":1.9,"name":"_acquireLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:219)"},{"pid":4936,"tid":16712,"ts":109146836266.3,"ph":"X","cat":"fee","dur":1.2,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:685)"},{"pid":4936,"tid":16712,"ts":109146836268.9,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836268.5,"ph":"X","cat":"fee","dur":0.7,"name":"_checkLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:190)"},{"pid":4936,"tid":16712,"ts":109146836264.9,"ph":"X","cat":"fee","dur":5.9,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1268)"},{"pid":4936,"tid":16712,"ts":109146836273.0,"ph":"X","cat":"fee","dur":0.9,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146836272.3,"ph":"X","cat":"fee","dur":2.7,"name":"_fixupParents (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1212)"},{"pid":4936,"tid":16712,"ts":109146836275.8,"ph":"X","cat":"fee","dur":0.3,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146836275.4,"ph":"X","cat":"fee","dur":0.72,"name":"_releaseLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:228)"},{"pid":4936,"tid":16712,"ts":109146836259.4,"ph":"X","cat":"fee","dur":17.0,"name":"getLogger (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1161)"},{"pid":4936,"tid":16712,"ts":109146836256.9,"ph":"X","cat":"fee","dur":19.6,"name":"getLogger (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1838)"},{"pid":4936,"tid":16712,"ts":109146836280.6,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836280.4,"ph":"X","cat":"fee","dur":1.8,"name":"_checkLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:190)"},{"pid":4936,"tid":16712,"ts":109146836280.0,"ph":"X","cat":"fee","dur":2.6,"name":"setLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1280)"},{"pid":4936,"tid":16712,"ts":109146836285.8,"ph":"X","cat":"fee","dur":0.9,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:384)"},{"pid":4936,"tid":16712,"ts":109146836284.1,"ph":"X","cat":"fee","dur":3.6,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:471)"},{"pid":4936,"tid":16712,"ts":109146836289.5,"ph":"X","cat":"fee","dur":0.2,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146836290.6,"ph":"X","cat":"fee","dur":2.0,"name":"nt._getfullpathname"},{"pid":4936,"tid":16712,"ts":109146836293.1,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146836293.4,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836294.0,"ph":"X","cat":"fee","dur":0.3,"name":"str.startswith"},{"pid":4936,"tid":16712,"ts":109146836294.6,"ph":"X","cat":"fee","dur":0.4,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146836295.5,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146836295.8,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836296.3,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836296.6,"ph":"X","cat":"fee","dur":0.3,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146836295.4,"ph":"X","cat":"fee","dur":3.0,"name":"splitdrive (d:\\coding\\python3.6\\lib\\ntpath.py:122)"},{"pid":4936,"tid":16712,"ts":109146836298.6,"ph":"X","cat":"fee","dur":0.3,"name":"str.startswith"},{"pid":4936,"tid":16712,"ts":109146836299.3,"ph":"X","cat":"fee","dur":0.4,"name":"str.lstrip"},{"pid":4936,"tid":16712,"ts":109146836299.9,"ph":"X","cat":"fee","dur":1.1,"name":"str.split"},{"pid":4936,"tid":16712,"ts":109146836301.2,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836302.1,"ph":"X","cat":"fee","dur":0.02,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836302.6,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836303.0,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836305.6,"ph":"X","cat":"fee","dur":0.02,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836305.9,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836306.2,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836306.6,"ph":"X","cat":"fee","dur":0.02,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836307.0,"ph":"X","cat":"fee","dur":0.5,"name":"str.join"},{"pid":4936,"tid":16712,"ts":109146836292.9,"ph":"X","cat":"fee","dur":15.0,"name":"normpath (d:\\coding\\python3.6\\lib\\ntpath.py:472)"},{"pid":4936,"tid":16712,"ts":109146836290.4,"ph":"X","cat":"fee","dur":17.9,"name":"abspath (d:\\coding\\python3.6\\lib\\ntpath.py:545)"},{"pid":4936,"tid":16712,"ts":109146836508.8,"ph":"X","cat":"fee","dur":6.2,"name":"_locale._getdefaultlocale"},{"pid":4936,"tid":16712,"ts":109146836507.9,"ph":"X","cat":"fee","dur":7.6,"name":"getpreferredencoding (d:\\coding\\python3.6\\lib\\_bootlocale.py:11)"},{"pid":4936,"tid":16712,"ts":109146836532.4,"ph":"X","cat":"fee","dur":0.3,"name":"setstate (d:\\coding\\python3.6\\lib\\codecs.py:213)"},{"pid":4936,"tid":16712,"ts":109146836312.3,"ph":"X","cat":"fee","dur":222.0,"name":"io.open"},{"pid":4936,"tid":16712,"ts":109146836311.6,"ph":"X","cat":"fee","dur":222.9,"name":"_open (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1056)"},{"pid":4936,"tid":16712,"ts":109146836537.7,"ph":"X","cat":"fee","dur":0.8,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:685)"},{"pid":4936,"tid":16712,"ts":109146836540.4,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836540.1,"ph":"X","cat":"fee","dur":0.7,"name":"_checkLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:190)"},{"pid":4936,"tid":16712,"ts":109146836543.4,"ph":"X","cat":"fee","dur":0.5,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146836542.8,"ph":"X","cat":"fee","dur":1.2,"name":"_acquireLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:219)"},{"pid":4936,"tid":16712,"ts":109146836545.5,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":4936,"tid":16712,"ts":109146836546.3,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146836546.1,"ph":"X","cat":"fee","dur":0.5,"name":"_releaseLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:228)"},{"pid":4936,"tid":16712,"ts":109146836542.3,"ph":"X","cat":"fee","dur":4.4,"name":"_addHandlerRef (d:\\coding\\python3.6\\lib\\logging\\__init__.py:752)"},{"pid":4936,"tid":16712,"ts":109146836549.2,"ph":"X","cat":"fee","dur":3.3,"name":"RLock (d:\\coding\\python3.6\\lib\\threading.py:74)"},{"pid":4936,"tid":16712,"ts":109146836547.5,"ph":"X","cat":"fee","dur":5.6,"name":"createLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:800)"},{"pid":4936,"tid":16712,"ts":109146836536.5,"ph":"X","cat":"fee","dur":16.8,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:771)"},{"pid":4936,"tid":16712,"ts":109146836535.2,"ph":"X","cat":"fee","dur":18.8,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:960)"},{"pid":4936,"tid":16712,"ts":109146836289.0,"ph":"X","cat":"fee","dur":265.2,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1014)"},{"pid":4936,"tid":16712,"ts":109146836555.9,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836555.7,"ph":"X","cat":"fee","dur":1.8,"name":"_checkLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:190)"},{"pid":4936,"tid":16712,"ts":109146836555.3,"ph":"X","cat":"fee","dur":2.5,"name":"setLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:823)"},{"pid":4936,"tid":16712,"ts":109146836558.7,"ph":"X","cat":"fee","dur":0.3,"name":"setFormatter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:870)"},{"pid":4936,"tid":16712,"ts":109146836560.6,"ph":"X","cat":"fee","dur":0.5,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:685)"},{"pid":4936,"tid":16712,"ts":109146836561.9,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836561.7,"ph":"X","cat":"fee","dur":0.4,"name":"_checkLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:190)"},{"pid":4936,"tid":16712,"ts":109146836563.2,"ph":"X","cat":"fee","dur":0.3,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146836563.0,"ph":"X","cat":"fee","dur":0.6,"name":"_acquireLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:219)"},{"pid":4936,"tid":16712,"ts":109146836564.2,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":4936,"tid":16712,"ts":109146836564.7,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146836564.6,"ph":"X","cat":"fee","dur":0.32,"name":"_releaseLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:228)"},{"pid":4936,"tid":16712,"ts":109146836562.8,"ph":"X","cat":"fee","dur":2.3,"name":"_addHandlerRef (d:\\coding\\python3.6\\lib\\logging\\__init__.py:752)"},{"pid":4936,"tid":16712,"ts":109146836566.2,"ph":"X","cat":"fee","dur":1.9,"name":"RLock (d:\\coding\\python3.6\\lib\\threading.py:74)"},{"pid":4936,"tid":16712,"ts":109146836565.5,"ph":"X","cat":"fee","dur":3.0,"name":"createLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:800)"},{"pid":4936,"tid":16712,"ts":109146836560.3,"ph":"X","cat":"fee","dur":8.4,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:771)"},{"pid":4936,"tid":16712,"ts":109146836560.0,"ph":"X","cat":"fee","dur":10.1,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:960)"},{"pid":4936,"tid":16712,"ts":109146836571.2,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836571.1,"ph":"X","cat":"fee","dur":0.9,"name":"_checkLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:190)"},{"pid":4936,"tid":16712,"ts":109146836570.9,"ph":"X","cat":"fee","dur":1.3,"name":"setLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:823)"},{"pid":4936,"tid":16712,"ts":109146836572.7,"ph":"X","cat":"fee","dur":0.2,"name":"setFormatter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:870)"},{"pid":4936,"tid":16712,"ts":109146836577.3,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146836577.1,"ph":"X","cat":"fee","dur":0.42,"name":"_acquireLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:219)"},{"pid":4936,"tid":16712,"ts":109146836578.2,"ph":"X","cat":"fee","dur":0.2,"name":"list.append"},{"pid":4936,"tid":16712,"ts":109146836578.8,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146836578.7,"ph":"X","cat":"fee","dur":0.3,"name":"_releaseLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:228)"},{"pid":4936,"tid":16712,"ts":109146836576.8,"ph":"X","cat":"fee","dur":2.3,"name":"addHandler (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1456)"},{"pid":4936,"tid":16712,"ts":109146836580.0,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146836579.8,"ph":"X","cat":"fee","dur":0.4,"name":"_acquireLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:219)"},{"pid":4936,"tid":16712,"ts":109146836580.8,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":4936,"tid":16712,"ts":109146836581.3,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146836581.1,"ph":"X","cat":"fee","dur":0.32,"name":"_releaseLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:228)"},{"pid":4936,"tid":16712,"ts":109146836579.6,"ph":"X","cat":"fee","dur":2.0,"name":"addHandler (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1456)"},{"pid":4936,"tid":16712,"ts":109146836255.7,"ph":"X","cat":"fee","dur":326.0,"name":"init_logger (C:\\Users\\libuliduobuqiuqiu\\Desktop\\GitProjects\\PythonDemo\\Logging\\logging_example.py:12)"},{"pid":4936,"tid":16712,"ts":109146836585.6,"ph":"X","cat":"fee","dur":0.7,"name":"getEffectiveLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1530)"},{"pid":4936,"tid":16712,"ts":109146836584.1,"ph":"X","cat":"fee","dur":2.3,"name":"isEnabledFor (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1544)"},{"pid":4936,"tid":16712,"ts":109146836590.4,"ph":"X","cat":"fee","dur":0.6,"name":"sys._getframe"},{"pid":4936,"tid":16712,"ts":109146836590.0,"ph":"X","cat":"fee","dur":1.1,"name":"<lambda> (d:\\coding\\python3.6\\lib\\logging\\__init__.py:157)"},{"pid":4936,"tid":16712,"ts":109146836592.2,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146836594.8,"ph":"X","cat":"fee","dur":0.3,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146836595.4,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836595.9,"ph":"X","cat":"fee","dur":0.6,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146836596.7,"ph":"X","cat":"fee","dur":0.3,"name":"str.lower"},{"pid":4936,"tid":16712,"ts":109146836594.3,"ph":"X","cat":"fee","dur":2.8,"name":"normcase (d:\\coding\\python3.6\\lib\\ntpath.py:44)"},{"pid":4936,"tid":16712,"ts":109146836589.2,"ph":"X","cat":"fee","dur":9.4,"name":"findCaller (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1376)"},{"pid":4936,"tid":16712,"ts":109146836603.0,"ph":"X","cat":"fee","dur":1.1,"name":"time.time"},{"pid":4936,"tid":16712,"ts":109146836606.3,"ph":"X","cat":"fee","dur":0.3,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146836605.8,"ph":"X","cat":"fee","dur":1.1,"name":"getLevelName (d:\\coding\\python3.6\\lib\\logging\\__init__.py:120)"},{"pid":4936,"tid":16712,"ts":109146836609.2,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146836609.9,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836609.7,"ph":"X","cat":"fee","dur":0.6,"name":"_get_bothseps (d:\\coding\\python3.6\\lib\\ntpath.py:34)"},{"pid":4936,"tid":16712,"ts":109146836610.8,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146836611.1,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836611.5,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836611.9,"ph":"X","cat":"fee","dur":0.2,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146836610.7,"ph":"X","cat":"fee","dur":3.2,"name":"splitdrive (d:\\coding\\python3.6\\lib\\ntpath.py:122)"},{"pid":4936,"tid":16712,"ts":109146836614.3,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146836617.7,"ph":"X","cat":"fee","dur":0.4,"name":"str.rstrip"},{"pid":4936,"tid":16712,"ts":109146836609.0,"ph":"X","cat":"fee","dur":9.8,"name":"split (d:\\coding\\python3.6\\lib\\ntpath.py:200)"},{"pid":4936,"tid":16712,"ts":109146836608.7,"ph":"X","cat":"fee","dur":10.5,"name":"basename (d:\\coding\\python3.6\\lib\\ntpath.py:234)"},{"pid":4936,"tid":16712,"ts":109146836620.7,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146836620.9,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146836622.6,"ph":"X","cat":"fee","dur":0.8,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146836623.6,"ph":"X","cat":"fee","dur":0.2,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146836624.0,"ph":"X","cat":"fee","dur":0.9,"name":"builtins.max"},{"pid":4936,"tid":16712,"ts":109146836625.1,"ph":"X","cat":"fee","dur":0.2,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146836622.3,"ph":"X","cat":"fee","dur":4.5,"name":"_splitext (d:\\coding\\python3.6\\lib\\genericpath.py:117)"},{"pid":4936,"tid":16712,"ts":109146836620.4,"ph":"X","cat":"fee","dur":6.6,"name":"splitext (d:\\coding\\python3.6\\lib\\ntpath.py:223)"},{"pid":4936,"tid":16712,"ts":109146836636.7,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146836638.3,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146836637.9,"ph":"X","cat":"fee","dur":1.2,"name":"current_thread (d:\\coding\\python3.6\\lib\\threading.py:1230)"},{"pid":4936,"tid":16712,"ts":109146836639.7,"ph":"X","cat":"fee","dur":0.6,"name":"name (d:\\coding\\python3.6\\lib\\threading.py:1076)"},{"pid":4936,"tid":16712,"ts":109146836641.4,"ph":"X","cat":"fee","dur":0.4,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146836643.3,"ph":"X","cat":"fee","dur":0.6,"name":"current_process (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:35)"},{"pid":4936,"tid":16712,"ts":109146836645.2,"ph":"X","cat":"fee","dur":0.5,"name":"name (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:146)"},{"pid":4936,"tid":16712,"ts":109146836646.4,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146836647.0,"ph":"X","cat":"fee","dur":0.4,"name":"nt.getpid"},{"pid":4936,"tid":16712,"ts":109146836602.2,"ph":"X","cat":"fee","dur":45.5,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:251)"},{"pid":4936,"tid":16712,"ts":109146836600.5,"ph":"X","cat":"fee","dur":48.0,"name":"makeRecord (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1406)"},{"pid":4936,"tid":16712,"ts":109146836650.5,"ph":"X","cat":"fee","dur":0.7,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146836657.5,"ph":"X","cat":"fee","dur":0.2,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146836659.0,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146836658.4,"ph":"X","cat":"fee","dur":0.9,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146836663.7,"ph":"X","cat":"fee","dur":0.8,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146836667.4,"ph":"X","cat":"fee","dur":0.7,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146836666.7,"ph":"X","cat":"fee","dur":1.6,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146836665.5,"ph":"X","cat":"fee","dur":2.9,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146836669.8,"ph":"X","cat":"fee","dur":15.0,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146836685.5,"ph":"X","cat":"fee","dur":9.4,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146836669.2,"ph":"X","cat":"fee","dur":25.8,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146836700.6,"ph":"X","cat":"fee","dur":3.7,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146836697.8,"ph":"X","cat":"fee","dur":6.6,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146836662.8,"ph":"X","cat":"fee","dur":42.2,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146836661.3,"ph":"X","cat":"fee","dur":43.9,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146836706.1,"ph":"X","cat":"fee","dur":2.8,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146836709.6,"ph":"X","cat":"fee","dur":278.7,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146836993.0,"ph":"X","cat":"fee","dur":0.7,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146836992.1,"ph":"X","cat":"fee","dur":1.9,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146836995.1,"ph":"X","cat":"fee","dur":0.8,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146836996.3,"ph":"X","cat":"fee","dur":1.6,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146836999.3,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146836998.9,"ph":"X","cat":"fee","dur":16.5,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146836991.2,"ph":"X","cat":"fee","dur":24.6,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146836660.5,"ph":"X","cat":"fee","dur":355.5,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146837017.1,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837016.9,"ph":"X","cat":"fee","dur":0.4,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146836657.0,"ph":"X","cat":"fee","dur":360.5,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146836654.5,"ph":"X","cat":"fee","dur":366.2,"name":"callHandlers (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1500)"},{"pid":4936,"tid":16712,"ts":109146836649.4,"ph":"X","cat":"fee","dur":371.6,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1446)"},{"pid":4936,"tid":16712,"ts":109146836587.9,"ph":"X","cat":"fee","dur":433.3,"name":"_log (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1421)"},{"pid":4936,"tid":16712,"ts":109146836583.0,"ph":"X","cat":"fee","dur":439.5,"name":"debug (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1286)"},{"pid":4936,"tid":16712,"ts":109146837025.6,"ph":"X","cat":"fee","dur":0.5,"name":"getEffectiveLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1530)"},{"pid":4936,"tid":16712,"ts":109146837024.8,"ph":"X","cat":"fee","dur":1.5,"name":"isEnabledFor (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1544)"},{"pid":4936,"tid":16712,"ts":109146837028.7,"ph":"X","cat":"fee","dur":0.6,"name":"sys._getframe"},{"pid":4936,"tid":16712,"ts":109146837028.3,"ph":"X","cat":"fee","dur":4.9,"name":"<lambda> (d:\\coding\\python3.6\\lib\\logging\\__init__.py:157)"},{"pid":4936,"tid":16712,"ts":109146837033.9,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837035.6,"ph":"X","cat":"fee","dur":0.3,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837036.3,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837037.0,"ph":"X","cat":"fee","dur":0.4,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146837037.7,"ph":"X","cat":"fee","dur":0.3,"name":"str.lower"},{"pid":4936,"tid":16712,"ts":109146837035.3,"ph":"X","cat":"fee","dur":2.8,"name":"normcase (d:\\coding\\python3.6\\lib\\ntpath.py:44)"},{"pid":4936,"tid":16712,"ts":109146837027.9,"ph":"X","cat":"fee","dur":11.3,"name":"findCaller (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1376)"},{"pid":4936,"tid":16712,"ts":109146837042.0,"ph":"X","cat":"fee","dur":0.5,"name":"time.time"},{"pid":4936,"tid":16712,"ts":109146837044.0,"ph":"X","cat":"fee","dur":0.3,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146837043.7,"ph":"X","cat":"fee","dur":0.8,"name":"getLevelName (d:\\coding\\python3.6\\lib\\logging\\__init__.py:120)"},{"pid":4936,"tid":16712,"ts":109146837045.9,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837046.6,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837046.4,"ph":"X","cat":"fee","dur":0.6,"name":"_get_bothseps (d:\\coding\\python3.6\\lib\\ntpath.py:34)"},{"pid":4936,"tid":16712,"ts":109146837047.5,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837047.8,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146837048.2,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837048.6,"ph":"X","cat":"fee","dur":0.3,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146837047.3,"ph":"X","cat":"fee","dur":3.4,"name":"splitdrive (d:\\coding\\python3.6\\lib\\ntpath.py:122)"},{"pid":4936,"tid":16712,"ts":109146837051.1,"ph":"X","cat":"fee","dur":0.02,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146837054.3,"ph":"X","cat":"fee","dur":0.5,"name":"str.rstrip"},{"pid":4936,"tid":16712,"ts":109146837045.7,"ph":"X","cat":"fee","dur":9.6,"name":"split (d:\\coding\\python3.6\\lib\\ntpath.py:200)"},{"pid":4936,"tid":16712,"ts":109146837045.3,"ph":"X","cat":"fee","dur":10.5,"name":"basename (d:\\coding\\python3.6\\lib\\ntpath.py:234)"},{"pid":4936,"tid":16712,"ts":109146837056.7,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837057.0,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837057.8,"ph":"X","cat":"fee","dur":0.8,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837058.8,"ph":"X","cat":"fee","dur":0.2,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837059.2,"ph":"X","cat":"fee","dur":0.7,"name":"builtins.max"},{"pid":4936,"tid":16712,"ts":109146837060.1,"ph":"X","cat":"fee","dur":0.2,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837057.6,"ph":"X","cat":"fee","dur":4.1,"name":"_splitext (d:\\coding\\python3.6\\lib\\genericpath.py:117)"},{"pid":4936,"tid":16712,"ts":109146837056.6,"ph":"X","cat":"fee","dur":5.3,"name":"splitext (d:\\coding\\python3.6\\lib\\ntpath.py:223)"},{"pid":4936,"tid":16712,"ts":109146837066.0,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146837067.4,"ph":"X","cat":"fee","dur":0.02,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146837067.1,"ph":"X","cat":"fee","dur":0.8,"name":"current_thread (d:\\coding\\python3.6\\lib\\threading.py:1230)"},{"pid":4936,"tid":16712,"ts":109146837068.5,"ph":"X","cat":"fee","dur":0.3,"name":"name (d:\\coding\\python3.6\\lib\\threading.py:1076)"},{"pid":4936,"tid":16712,"ts":109146837069.7,"ph":"X","cat":"fee","dur":0.2,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146837070.8,"ph":"X","cat":"fee","dur":0.1,"name":"current_process (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:35)"},{"pid":4936,"tid":16712,"ts":109146837071.3,"ph":"X","cat":"fee","dur":0.4,"name":"name (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:146)"},{"pid":4936,"tid":16712,"ts":109146837072.3,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837072.8,"ph":"X","cat":"fee","dur":0.3,"name":"nt.getpid"},{"pid":4936,"tid":16712,"ts":109146837041.6,"ph":"X","cat":"fee","dur":31.7,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:251)"},{"pid":4936,"tid":16712,"ts":109146837040.3,"ph":"X","cat":"fee","dur":33.8,"name":"makeRecord (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1406)"},{"pid":4936,"tid":16712,"ts":109146837075.4,"ph":"X","cat":"fee","dur":0.5,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146837078.5,"ph":"X","cat":"fee","dur":0.2,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146837079.5,"ph":"X","cat":"fee","dur":0.4,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837079.2,"ph":"X","cat":"fee","dur":0.8,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837082.6,"ph":"X","cat":"fee","dur":0.8,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146837087.4,"ph":"X","cat":"fee","dur":0.6,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146837086.9,"ph":"X","cat":"fee","dur":1.3,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146837086.2,"ph":"X","cat":"fee","dur":2.1,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146837089.4,"ph":"X","cat":"fee","dur":6.1,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146837096.0,"ph":"X","cat":"fee","dur":5.7,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146837089.0,"ph":"X","cat":"fee","dur":12.9,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146837103.3,"ph":"X","cat":"fee","dur":3.2,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146837102.8,"ph":"X","cat":"fee","dur":3.8,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146837082.2,"ph":"X","cat":"fee","dur":24.9,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146837081.3,"ph":"X","cat":"fee","dur":26.0,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146837107.8,"ph":"X","cat":"fee","dur":1.2,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837109.5,"ph":"X","cat":"fee","dur":142.9,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837255.9,"ph":"X","cat":"fee","dur":0.8,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837255.1,"ph":"X","cat":"fee","dur":3.6,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837260.2,"ph":"X","cat":"fee","dur":0.6,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837261.2,"ph":"X","cat":"fee","dur":1.2,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146837263.7,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837263.3,"ph":"X","cat":"fee","dur":0.8,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837254.3,"ph":"X","cat":"fee","dur":10.1,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146837080.6,"ph":"X","cat":"fee","dur":184.0,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146837265.8,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837265.5,"ph":"X","cat":"fee","dur":0.7,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837078.2,"ph":"X","cat":"fee","dur":188.2,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146837076.3,"ph":"X","cat":"fee","dur":192.4,"name":"callHandlers (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1500)"},{"pid":4936,"tid":16712,"ts":109146837074.7,"ph":"X","cat":"fee","dur":194.3,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1446)"},{"pid":4936,"tid":16712,"ts":109146837027.3,"ph":"X","cat":"fee","dur":242.1,"name":"_log (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1421)"},{"pid":4936,"tid":16712,"ts":109146837024.0,"ph":"X","cat":"fee","dur":247.2,"name":"info (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1298)"},{"pid":4936,"tid":16712,"ts":109146837275.0,"ph":"X","cat":"fee","dur":0.7,"name":"getEffectiveLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1530)"},{"pid":4936,"tid":16712,"ts":109146837273.9,"ph":"X","cat":"fee","dur":2.1,"name":"isEnabledFor (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1544)"},{"pid":4936,"tid":16712,"ts":109146837279.8,"ph":"X","cat":"fee","dur":0.8,"name":"sys._getframe"},{"pid":4936,"tid":16712,"ts":109146837279.3,"ph":"X","cat":"fee","dur":1.5,"name":"<lambda> (d:\\coding\\python3.6\\lib\\logging\\__init__.py:157)"},{"pid":4936,"tid":16712,"ts":109146837281.7,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837284.1,"ph":"X","cat":"fee","dur":0.5,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837285.1,"ph":"X","cat":"fee","dur":0.5,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837286.0,"ph":"X","cat":"fee","dur":0.7,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146837287.0,"ph":"X","cat":"fee","dur":0.4,"name":"str.lower"},{"pid":4936,"tid":16712,"ts":109146837283.7,"ph":"X","cat":"fee","dur":4.0,"name":"normcase (d:\\coding\\python3.6\\lib\\ntpath.py:44)"},{"pid":4936,"tid":16712,"ts":109146837278.7,"ph":"X","cat":"fee","dur":10.7,"name":"findCaller (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1376)"},{"pid":4936,"tid":16712,"ts":109146837295.2,"ph":"X","cat":"fee","dur":0.8,"name":"time.time"},{"pid":4936,"tid":16712,"ts":109146837297.6,"ph":"X","cat":"fee","dur":0.4,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146837297.3,"ph":"X","cat":"fee","dur":1.0,"name":"getLevelName (d:\\coding\\python3.6\\lib\\logging\\__init__.py:120)"},{"pid":4936,"tid":16712,"ts":109146837300.1,"ph":"X","cat":"fee","dur":0.2,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837301.0,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837300.7,"ph":"X","cat":"fee","dur":0.8,"name":"_get_bothseps (d:\\coding\\python3.6\\lib\\ntpath.py:34)"},{"pid":4936,"tid":16712,"ts":109146837302.1,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837302.4,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146837306.3,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837306.9,"ph":"X","cat":"fee","dur":0.5,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146837301.9,"ph":"X","cat":"fee","dur":7.4,"name":"splitdrive (d:\\coding\\python3.6\\lib\\ntpath.py:122)"},{"pid":4936,"tid":16712,"ts":109146837309.7,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146837313.0,"ph":"X","cat":"fee","dur":0.4,"name":"str.rstrip"},{"pid":4936,"tid":16712,"ts":109146837299.8,"ph":"X","cat":"fee","dur":14.2,"name":"split (d:\\coding\\python3.6\\lib\\ntpath.py:200)"},{"pid":4936,"tid":16712,"ts":109146837299.5,"ph":"X","cat":"fee","dur":14.9,"name":"basename (d:\\coding\\python3.6\\lib\\ntpath.py:234)"},{"pid":4936,"tid":16712,"ts":109146837315.4,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837315.6,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837316.5,"ph":"X","cat":"fee","dur":0.8,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837317.4,"ph":"X","cat":"fee","dur":0.3,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837317.8,"ph":"X","cat":"fee","dur":0.9,"name":"builtins.max"},{"pid":4936,"tid":16712,"ts":109146837318.9,"ph":"X","cat":"fee","dur":0.1,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837316.3,"ph":"X","cat":"fee","dur":4.1,"name":"_splitext (d:\\coding\\python3.6\\lib\\genericpath.py:117)"},{"pid":4936,"tid":16712,"ts":109146837315.2,"ph":"X","cat":"fee","dur":5.5,"name":"splitext (d:\\coding\\python3.6\\lib\\ntpath.py:223)"},{"pid":4936,"tid":16712,"ts":109146837324.6,"ph":"X","cat":"fee","dur":0.3,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146837326.0,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146837325.8,"ph":"X","cat":"fee","dur":0.8,"name":"current_thread (d:\\coding\\python3.6\\lib\\threading.py:1230)"},{"pid":4936,"tid":16712,"ts":109146837327.2,"ph":"X","cat":"fee","dur":0.3,"name":"name (d:\\coding\\python3.6\\lib\\threading.py:1076)"},{"pid":4936,"tid":16712,"ts":109146837328.4,"ph":"X","cat":"fee","dur":0.2,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146837329.3,"ph":"X","cat":"fee","dur":0.2,"name":"current_process (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:35)"},{"pid":4936,"tid":16712,"ts":109146837329.9,"ph":"X","cat":"fee","dur":0.1,"name":"name (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:146)"},{"pid":4936,"tid":16712,"ts":109146837330.7,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837331.2,"ph":"X","cat":"fee","dur":0.3,"name":"nt.getpid"},{"pid":4936,"tid":16712,"ts":109146837294.8,"ph":"X","cat":"fee","dur":36.9,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:251)"},{"pid":4936,"tid":16712,"ts":109146837293.1,"ph":"X","cat":"fee","dur":39.5,"name":"makeRecord (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1406)"},{"pid":4936,"tid":16712,"ts":109146837333.9,"ph":"X","cat":"fee","dur":0.5,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146837337.2,"ph":"X","cat":"fee","dur":0.3,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146837338.5,"ph":"X","cat":"fee","dur":0.4,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837338.0,"ph":"X","cat":"fee","dur":1.1,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837342.7,"ph":"X","cat":"fee","dur":1.0,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146837345.2,"ph":"X","cat":"fee","dur":0.6,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146837344.7,"ph":"X","cat":"fee","dur":1.3,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146837344.2,"ph":"X","cat":"fee","dur":1.9,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146837347.0,"ph":"X","cat":"fee","dur":6.4,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146837353.9,"ph":"X","cat":"fee","dur":10.2,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146837346.7,"ph":"X","cat":"fee","dur":17.8,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146837367.4,"ph":"X","cat":"fee","dur":3.8,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146837366.8,"ph":"X","cat":"fee","dur":4.5,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146837342.4,"ph":"X","cat":"fee","dur":29.6,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146837341.6,"ph":"X","cat":"fee","dur":30.7,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146837373.0,"ph":"X","cat":"fee","dur":5.3,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837379.2,"ph":"X","cat":"fee","dur":2.8,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837384.3,"ph":"X","cat":"fee","dur":0.6,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837383.7,"ph":"X","cat":"fee","dur":1.4,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837386.1,"ph":"X","cat":"fee","dur":2.1,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837388.8,"ph":"X","cat":"fee","dur":60.8,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146837453.9,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837453.4,"ph":"X","cat":"fee","dur":0.8,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837383.0,"ph":"X","cat":"fee","dur":71.4,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146837341.1,"ph":"X","cat":"fee","dur":113.5,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146837340.0,"ph":"X","cat":"fee","dur":114.9,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1063)"},{"pid":4936,"tid":16712,"ts":109146837455.6,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837455.4,"ph":"X","cat":"fee","dur":0.4,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837336.7,"ph":"X","cat":"fee","dur":119.2,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146837457.5,"ph":"X","cat":"fee","dur":0.5,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146837458.8,"ph":"X","cat":"fee","dur":0.4,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837458.5,"ph":"X","cat":"fee","dur":0.8,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837461.1,"ph":"X","cat":"fee","dur":0.9,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146837463.6,"ph":"X","cat":"fee","dur":0.9,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146837463.2,"ph":"X","cat":"fee","dur":1.4,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146837462.7,"ph":"X","cat":"fee","dur":2.1,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146837465.7,"ph":"X","cat":"fee","dur":4.3,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146837470.5,"ph":"X","cat":"fee","dur":4.8,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146837465.4,"ph":"X","cat":"fee","dur":10.1,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146837477.0,"ph":"X","cat":"fee","dur":2.6,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146837476.6,"ph":"X","cat":"fee","dur":3.1,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146837460.7,"ph":"X","cat":"fee","dur":19.4,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146837460.1,"ph":"X","cat":"fee","dur":20.1,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146837480.7,"ph":"X","cat":"fee","dur":1.2,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837482.2,"ph":"X","cat":"fee","dur":106.8,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837592.7,"ph":"X","cat":"fee","dur":0.8,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837591.8,"ph":"X","cat":"fee","dur":2.1,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837595.0,"ph":"X","cat":"fee","dur":0.7,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837596.2,"ph":"X","cat":"fee","dur":1.5,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146837599.1,"ph":"X","cat":"fee","dur":2.0,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837598.6,"ph":"X","cat":"fee","dur":2.8,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837590.9,"ph":"X","cat":"fee","dur":10.8,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146837459.7,"ph":"X","cat":"fee","dur":142.3,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146837603.7,"ph":"X","cat":"fee","dur":0.4,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837603.3,"ph":"X","cat":"fee","dur":0.9,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837457.1,"ph":"X","cat":"fee","dur":147.3,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146837334.9,"ph":"X","cat":"fee","dur":271.9,"name":"callHandlers (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1500)"},{"pid":4936,"tid":16712,"ts":109146837333.3,"ph":"X","cat":"fee","dur":273.7,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1446)"},{"pid":4936,"tid":16712,"ts":109146837277.6,"ph":"X","cat":"fee","dur":329.6,"name":"_log (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1421)"},{"pid":4936,"tid":16712,"ts":109146837273.2,"ph":"X","cat":"fee","dur":335.5,"name":"warning (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1310)"},{"pid":4936,"tid":16712,"ts":109146837612.0,"ph":"X","cat":"fee","dur":0.5,"name":"getEffectiveLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1530)"},{"pid":4936,"tid":16712,"ts":109146837611.2,"ph":"X","cat":"fee","dur":1.5,"name":"isEnabledFor (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1544)"},{"pid":4936,"tid":16712,"ts":109146837615.5,"ph":"X","cat":"fee","dur":0.6,"name":"sys._getframe"},{"pid":4936,"tid":16712,"ts":109146837615.1,"ph":"X","cat":"fee","dur":1.1,"name":"<lambda> (d:\\coding\\python3.6\\lib\\logging\\__init__.py:157)"},{"pid":4936,"tid":16712,"ts":109146837616.8,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837618.9,"ph":"X","cat":"fee","dur":0.3,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837619.6,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837626.7,"ph":"X","cat":"fee","dur":0.6,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146837627.7,"ph":"X","cat":"fee","dur":0.4,"name":"str.lower"},{"pid":4936,"tid":16712,"ts":109146837618.5,"ph":"X","cat":"fee","dur":9.8,"name":"normcase (d:\\coding\\python3.6\\lib\\ntpath.py:44)"},{"pid":4936,"tid":16712,"ts":109146837614.7,"ph":"X","cat":"fee","dur":15.3,"name":"findCaller (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1376)"},{"pid":4936,"tid":16712,"ts":109146837634.0,"ph":"X","cat":"fee","dur":0.6,"name":"time.time"},{"pid":4936,"tid":16712,"ts":109146837636.6,"ph":"X","cat":"fee","dur":0.4,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146837636.2,"ph":"X","cat":"fee","dur":1.1,"name":"getLevelName (d:\\coding\\python3.6\\lib\\logging\\__init__.py:120)"},{"pid":4936,"tid":16712,"ts":109146837639.6,"ph":"X","cat":"fee","dur":0.3,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837641.0,"ph":"X","cat":"fee","dur":2.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837640.5,"ph":"X","cat":"fee","dur":3.1,"name":"_get_bothseps (d:\\coding\\python3.6\\lib\\ntpath.py:34)"},{"pid":4936,"tid":16712,"ts":109146837644.7,"ph":"X","cat":"fee","dur":0.3,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837645.3,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146837646.0,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837646.7,"ph":"X","cat":"fee","dur":0.5,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146837644.3,"ph":"X","cat":"fee","dur":5.2,"name":"splitdrive (d:\\coding\\python3.6\\lib\\ntpath.py:122)"},{"pid":4936,"tid":16712,"ts":109146837649.9,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146837656.1,"ph":"X","cat":"fee","dur":0.5,"name":"str.rstrip"},{"pid":4936,"tid":16712,"ts":109146837639.1,"ph":"X","cat":"fee","dur":18.1,"name":"split (d:\\coding\\python3.6\\lib\\ntpath.py:200)"},{"pid":4936,"tid":16712,"ts":109146837638.6,"ph":"X","cat":"fee","dur":19.0,"name":"basename (d:\\coding\\python3.6\\lib\\ntpath.py:234)"},{"pid":4936,"tid":16712,"ts":109146837658.8,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837659.1,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837660.5,"ph":"X","cat":"fee","dur":0.9,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837661.7,"ph":"X","cat":"fee","dur":0.4,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837662.3,"ph":"X","cat":"fee","dur":1.1,"name":"builtins.max"},{"pid":4936,"tid":16712,"ts":109146837663.6,"ph":"X","cat":"fee","dur":0.3,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837660.2,"ph":"X","cat":"fee","dur":7.8,"name":"_splitext (d:\\coding\\python3.6\\lib\\genericpath.py:117)"},{"pid":4936,"tid":16712,"ts":109146837658.5,"ph":"X","cat":"fee","dur":9.9,"name":"splitext (d:\\coding\\python3.6\\lib\\ntpath.py:223)"},{"pid":4936,"tid":16712,"ts":109146837674.5,"ph":"X","cat":"fee","dur":0.4,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146837676.9,"ph":"X","cat":"fee","dur":1.9,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146837676.4,"ph":"X","cat":"fee","dur":3.4,"name":"current_thread (d:\\coding\\python3.6\\lib\\threading.py:1230)"},{"pid":4936,"tid":16712,"ts":109146837680.7,"ph":"X","cat":"fee","dur":0.6,"name":"name (d:\\coding\\python3.6\\lib\\threading.py:1076)"},{"pid":4936,"tid":16712,"ts":109146837682.4,"ph":"X","cat":"fee","dur":0.4,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146837684.0,"ph":"X","cat":"fee","dur":0.1,"name":"current_process (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:35)"},{"pid":4936,"tid":16712,"ts":109146837684.5,"ph":"X","cat":"fee","dur":0.3,"name":"name (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:146)"},{"pid":4936,"tid":16712,"ts":109146837685.4,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837686.0,"ph":"X","cat":"fee","dur":0.4,"name":"nt.getpid"},{"pid":4936,"tid":16712,"ts":109146837633.5,"ph":"X","cat":"fee","dur":53.1,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:251)"},{"pid":4936,"tid":16712,"ts":109146837632.0,"ph":"X","cat":"fee","dur":55.5,"name":"makeRecord (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1406)"},{"pid":4936,"tid":16712,"ts":109146837688.9,"ph":"X","cat":"fee","dur":0.5,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146837692.3,"ph":"X","cat":"fee","dur":0.3,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146837693.5,"ph":"X","cat":"fee","dur":0.6,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837693.1,"ph":"X","cat":"fee","dur":1.1,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837697.1,"ph":"X","cat":"fee","dur":0.9,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146837699.4,"ph":"X","cat":"fee","dur":0.8,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146837699.0,"ph":"X","cat":"fee","dur":1.4,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146837698.6,"ph":"X","cat":"fee","dur":1.9,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146837701.6,"ph":"X","cat":"fee","dur":5.5,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146837710.3,"ph":"X","cat":"fee","dur":5.7,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146837701.1,"ph":"X","cat":"fee","dur":15.1,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146837717.8,"ph":"X","cat":"fee","dur":3.1,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146837717.3,"ph":"X","cat":"fee","dur":3.7,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146837696.7,"ph":"X","cat":"fee","dur":24.8,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146837695.9,"ph":"X","cat":"fee","dur":25.8,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146837722.2,"ph":"X","cat":"fee","dur":2.0,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837724.6,"ph":"X","cat":"fee","dur":1.8,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837727.5,"ph":"X","cat":"fee","dur":0.3,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837727.2,"ph":"X","cat":"fee","dur":0.7,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837728.4,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837729.0,"ph":"X","cat":"fee","dur":19.9,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146837749.7,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837749.5,"ph":"X","cat":"fee","dur":0.5,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837726.9,"ph":"X","cat":"fee","dur":23.2,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146837695.5,"ph":"X","cat":"fee","dur":54.9,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146837694.8,"ph":"X","cat":"fee","dur":55.8,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1063)"},{"pid":4936,"tid":16712,"ts":109146837751.2,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837751.0,"ph":"X","cat":"fee","dur":0.4,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837691.8,"ph":"X","cat":"fee","dur":59.7,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146837753.0,"ph":"X","cat":"fee","dur":0.4,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146837754.0,"ph":"X","cat":"fee","dur":0.3,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837753.8,"ph":"X","cat":"fee","dur":0.6,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837755.9,"ph":"X","cat":"fee","dur":0.7,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146837758.0,"ph":"X","cat":"fee","dur":0.6,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146837757.6,"ph":"X","cat":"fee","dur":1.2,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146837757.1,"ph":"X","cat":"fee","dur":1.8,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146837759.8,"ph":"X","cat":"fee","dur":2.7,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146837762.9,"ph":"X","cat":"fee","dur":3.8,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146837759.5,"ph":"X","cat":"fee","dur":7.3,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146837768.0,"ph":"X","cat":"fee","dur":2.1,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146837767.7,"ph":"X","cat":"fee","dur":2.5,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146837755.6,"ph":"X","cat":"fee","dur":14.9,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146837755.1,"ph":"X","cat":"fee","dur":15.6,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146837771.0,"ph":"X","cat":"fee","dur":1.0,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837772.2,"ph":"X","cat":"fee","dur":163.8,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146837939.0,"ph":"X","cat":"fee","dur":0.6,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146837938.3,"ph":"X","cat":"fee","dur":1.6,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146837940.9,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837941.7,"ph":"X","cat":"fee","dur":1.1,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146837943.7,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837943.4,"ph":"X","cat":"fee","dur":0.6,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837937.7,"ph":"X","cat":"fee","dur":6.5,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146837754.7,"ph":"X","cat":"fee","dur":189.7,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146837945.3,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146837945.0,"ph":"X","cat":"fee","dur":0.6,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146837752.6,"ph":"X","cat":"fee","dur":196.6,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146837689.9,"ph":"X","cat":"fee","dur":261.5,"name":"callHandlers (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1500)"},{"pid":4936,"tid":16712,"ts":109146837688.3,"ph":"X","cat":"fee","dur":263.3,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1446)"},{"pid":4936,"tid":16712,"ts":109146837614.1,"ph":"X","cat":"fee","dur":337.8,"name":"_log (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1421)"},{"pid":4936,"tid":16712,"ts":109146837610.6,"ph":"X","cat":"fee","dur":342.9,"name":"error (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1327)"},{"pid":4936,"tid":16712,"ts":109146837957.1,"ph":"X","cat":"fee","dur":0.5,"name":"getEffectiveLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1530)"},{"pid":4936,"tid":16712,"ts":109146837956.2,"ph":"X","cat":"fee","dur":1.6,"name":"isEnabledFor (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1544)"},{"pid":4936,"tid":16712,"ts":109146837961.0,"ph":"X","cat":"fee","dur":0.6,"name":"sys._getframe"},{"pid":4936,"tid":16712,"ts":109146837960.4,"ph":"X","cat":"fee","dur":1.3,"name":"<lambda> (d:\\coding\\python3.6\\lib\\logging\\__init__.py:157)"},{"pid":4936,"tid":16712,"ts":109146837962.4,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146837964.4,"ph":"X","cat":"fee","dur":0.3,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837965.1,"ph":"X","cat":"fee","dur":0.5,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837966.0,"ph":"X","cat":"fee","dur":0.5,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146837966.8,"ph":"X","cat":"fee","dur":0.3,"name":"str.lower"},{"pid":4936,"tid":16712,"ts":109146837964.0,"ph":"X","cat":"fee","dur":3.2,"name":"normcase (d:\\coding\\python3.6\\lib\\ntpath.py:44)"},{"pid":4936,"tid":16712,"ts":109146837959.9,"ph":"X","cat":"fee","dur":8.6,"name":"findCaller (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1376)"},{"pid":4936,"tid":16712,"ts":109146837971.6,"ph":"X","cat":"fee","dur":0.5,"name":"time.time"},{"pid":4936,"tid":16712,"ts":109146837973.7,"ph":"X","cat":"fee","dur":0.4,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146837973.3,"ph":"X","cat":"fee","dur":1.0,"name":"getLevelName (d:\\coding\\python3.6\\lib\\logging\\__init__.py:120)"},{"pid":4936,"tid":16712,"ts":109146837975.9,"ph":"X","cat":"fee","dur":0.02,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837976.6,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837976.4,"ph":"X","cat":"fee","dur":0.7,"name":"_get_bothseps (d:\\coding\\python3.6\\lib\\ntpath.py:34)"},{"pid":4936,"tid":16712,"ts":109146837977.6,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837977.9,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146837978.3,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837978.7,"ph":"X","cat":"fee","dur":0.3,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146837977.4,"ph":"X","cat":"fee","dur":3.4,"name":"splitdrive (d:\\coding\\python3.6\\lib\\ntpath.py:122)"},{"pid":4936,"tid":16712,"ts":109146837981.2,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146837984.7,"ph":"X","cat":"fee","dur":0.5,"name":"str.rstrip"},{"pid":4936,"tid":16712,"ts":109146837975.7,"ph":"X","cat":"fee","dur":10.0,"name":"split (d:\\coding\\python3.6\\lib\\ntpath.py:200)"},{"pid":4936,"tid":16712,"ts":109146837975.2,"ph":"X","cat":"fee","dur":11.0,"name":"basename (d:\\coding\\python3.6\\lib\\ntpath.py:234)"},{"pid":4936,"tid":16712,"ts":109146837987.2,"ph":"X","cat":"fee","dur":0.2,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146837987.5,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146837988.7,"ph":"X","cat":"fee","dur":0.8,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837989.7,"ph":"X","cat":"fee","dur":0.3,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837990.1,"ph":"X","cat":"fee","dur":0.9,"name":"builtins.max"},{"pid":4936,"tid":16712,"ts":109146837991.1,"ph":"X","cat":"fee","dur":0.2,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146837988.5,"ph":"X","cat":"fee","dur":4.2,"name":"_splitext (d:\\coding\\python3.6\\lib\\genericpath.py:117)"},{"pid":4936,"tid":16712,"ts":109146837987.1,"ph":"X","cat":"fee","dur":5.8,"name":"splitext (d:\\coding\\python3.6\\lib\\ntpath.py:223)"},{"pid":4936,"tid":16712,"ts":109146837997.2,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146837999.0,"ph":"X","cat":"fee","dur":0.02,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146837998.7,"ph":"X","cat":"fee","dur":0.9,"name":"current_thread (d:\\coding\\python3.6\\lib\\threading.py:1230)"},{"pid":4936,"tid":16712,"ts":109146838000.3,"ph":"X","cat":"fee","dur":0.5,"name":"name (d:\\coding\\python3.6\\lib\\threading.py:1076)"},{"pid":4936,"tid":16712,"ts":109146838001.6,"ph":"X","cat":"fee","dur":0.3,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146838002.8,"ph":"X","cat":"fee","dur":0.2,"name":"current_process (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:35)"},{"pid":4936,"tid":16712,"ts":109146838003.5,"ph":"X","cat":"fee","dur":0.3,"name":"name (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:146)"},{"pid":4936,"tid":16712,"ts":109146838004.3,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146838007.1,"ph":"X","cat":"fee","dur":0.4,"name":"nt.getpid"},{"pid":4936,"tid":16712,"ts":109146837971.1,"ph":"X","cat":"fee","dur":36.7,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:251)"},{"pid":4936,"tid":16712,"ts":109146837969.8,"ph":"X","cat":"fee","dur":38.7,"name":"makeRecord (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1406)"},{"pid":4936,"tid":16712,"ts":109146838009.9,"ph":"X","cat":"fee","dur":0.4,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146838013.1,"ph":"X","cat":"fee","dur":0.3,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146838014.2,"ph":"X","cat":"fee","dur":0.4,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146838013.8,"ph":"X","cat":"fee","dur":1.0,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146838017.8,"ph":"X","cat":"fee","dur":1.0,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146838020.2,"ph":"X","cat":"fee","dur":0.6,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146838019.8,"ph":"X","cat":"fee","dur":1.2,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146838019.3,"ph":"X","cat":"fee","dur":1.8,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146838022.3,"ph":"X","cat":"fee","dur":5.9,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146838028.6,"ph":"X","cat":"fee","dur":5.6,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146838021.8,"ph":"X","cat":"fee","dur":12.5,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146838035.8,"ph":"X","cat":"fee","dur":3.2,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146838035.4,"ph":"X","cat":"fee","dur":3.7,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146838017.4,"ph":"X","cat":"fee","dur":22.2,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146838016.6,"ph":"X","cat":"fee","dur":23.2,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146838040.3,"ph":"X","cat":"fee","dur":1.9,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146838042.7,"ph":"X","cat":"fee","dur":1.7,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146838045.6,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146838045.2,"ph":"X","cat":"fee","dur":0.7,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146838046.3,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146838046.7,"ph":"X","cat":"fee","dur":20.9,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146838068.5,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146838068.2,"ph":"X","cat":"fee","dur":0.5,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146838044.9,"ph":"X","cat":"fee","dur":24.0,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146838016.1,"ph":"X","cat":"fee","dur":53.0,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146838015.4,"ph":"X","cat":"fee","dur":53.9,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1063)"},{"pid":4936,"tid":16712,"ts":109146838069.9,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146838069.7,"ph":"X","cat":"fee","dur":0.4,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146838012.7,"ph":"X","cat":"fee","dur":57.5,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146838071.7,"ph":"X","cat":"fee","dur":0.4,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146838072.7,"ph":"X","cat":"fee","dur":0.3,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146838072.5,"ph":"X","cat":"fee","dur":0.6,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146838074.6,"ph":"X","cat":"fee","dur":0.7,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146838076.6,"ph":"X","cat":"fee","dur":0.5,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146838076.1,"ph":"X","cat":"fee","dur":1.2,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146838075.8,"ph":"X","cat":"fee","dur":1.6,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146838078.3,"ph":"X","cat":"fee","dur":2.9,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146838081.6,"ph":"X","cat":"fee","dur":3.7,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146838077.9,"ph":"X","cat":"fee","dur":7.5,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146838086.6,"ph":"X","cat":"fee","dur":2.0,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146838086.3,"ph":"X","cat":"fee","dur":2.4,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146838074.3,"ph":"X","cat":"fee","dur":14.8,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146838073.8,"ph":"X","cat":"fee","dur":15.5,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146838092.1,"ph":"X","cat":"fee","dur":1.1,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146838093.5,"ph":"X","cat":"fee","dur":197.7,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146838296.8,"ph":"X","cat":"fee","dur":1.2,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146838295.5,"ph":"X","cat":"fee","dur":2.9,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146838300.1,"ph":"X","cat":"fee","dur":1.0,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146838301.7,"ph":"X","cat":"fee","dur":2.1,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146838305.5,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146838304.9,"ph":"X","cat":"fee","dur":1.0,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146838294.4,"ph":"X","cat":"fee","dur":11.9,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146838073.4,"ph":"X","cat":"fee","dur":233.3,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146838308.3,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146838307.9,"ph":"X","cat":"fee","dur":0.8,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146838071.4,"ph":"X","cat":"fee","dur":237.6,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146838010.8,"ph":"X","cat":"fee","dur":302.2,"name":"callHandlers (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1500)"},{"pid":4936,"tid":16712,"ts":109146838009.2,"ph":"X","cat":"fee","dur":304.2,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1446)"},{"pid":4936,"tid":16712,"ts":109146837959.1,"ph":"X","cat":"fee","dur":354.9,"name":"_log (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1421)"},{"pid":4936,"tid":16712,"ts":109146837955.5,"ph":"X","cat":"fee","dur":361.0,"name":"critical (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1345)"},{"pid":4936,"tid":16712,"ts":109146838321.3,"ph":"X","cat":"fee","dur":0.5,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146838324.9,"ph":"X","cat":"fee","dur":1.0,"name":"getEffectiveLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1530)"},{"pid":4936,"tid":16712,"ts":109146838322.8,"ph":"X","cat":"fee","dur":3.5,"name":"isEnabledFor (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1544)"},{"pid":4936,"tid":16712,"ts":109146838320.4,"ph":"X","cat":"fee","dur":6.2,"name":"log (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1359)"},{"pid":4936,"tid":16712,"ts":109146838342.4,"ph":"X","cat":"fee","dur":0.5,"name":"getEffectiveLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1530)"},{"pid":4936,"tid":16712,"ts":109146838341.3,"ph":"X","cat":"fee","dur":1.9,"name":"isEnabledFor (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1544)"},{"pid":4936,"tid":16712,"ts":109146838348.4,"ph":"X","cat":"fee","dur":18.2,"name":"sys._getframe"},{"pid":4936,"tid":16712,"ts":109146838347.3,"ph":"X","cat":"fee","dur":19.6,"name":"<lambda> (d:\\coding\\python3.6\\lib\\logging\\__init__.py:157)"},{"pid":4936,"tid":16712,"ts":109146838367.7,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146838369.9,"ph":"X","cat":"fee","dur":0.4,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146838370.7,"ph":"X","cat":"fee","dur":0.5,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146838371.6,"ph":"X","cat":"fee","dur":0.5,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146838372.4,"ph":"X","cat":"fee","dur":0.3,"name":"str.lower"},{"pid":4936,"tid":16712,"ts":109146838369.4,"ph":"X","cat":"fee","dur":3.4,"name":"normcase (d:\\coding\\python3.6\\lib\\ntpath.py:44)"},{"pid":4936,"tid":16712,"ts":109146838373.5,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146838374.5,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146838374.7,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146838375.1,"ph":"X","cat":"fee","dur":0.2,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146838375.5,"ph":"X","cat":"fee","dur":0.2,"name":"str.lower"},{"pid":4936,"tid":16712,"ts":109146838374.3,"ph":"X","cat":"fee","dur":1.5,"name":"normcase (d:\\coding\\python3.6\\lib\\ntpath.py:44)"},{"pid":4936,"tid":16712,"ts":109146838346.3,"ph":"X","cat":"fee","dur":30.8,"name":"findCaller (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1376)"},{"pid":4936,"tid":16712,"ts":109146838377.9,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146838378.4,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146838379.4,"ph":"X","cat":"fee","dur":15.2,"name":"sys.exc_info"},{"pid":4936,"tid":16712,"ts":109146838397.3,"ph":"X","cat":"fee","dur":0.6,"name":"time.time"},{"pid":4936,"tid":16712,"ts":109146838399.6,"ph":"X","cat":"fee","dur":0.3,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146838399.2,"ph":"X","cat":"fee","dur":1.0,"name":"getLevelName (d:\\coding\\python3.6\\lib\\logging\\__init__.py:120)"},{"pid":4936,"tid":16712,"ts":109146838401.6,"ph":"X","cat":"fee","dur":0.2,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146838402.4,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146838402.2,"ph":"X","cat":"fee","dur":0.5,"name":"_get_bothseps (d:\\coding\\python3.6\\lib\\ntpath.py:34)"},{"pid":4936,"tid":16712,"ts":109146838406.8,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146838407.1,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146838407.6,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146838407.9,"ph":"X","cat":"fee","dur":0.3,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146838406.5,"ph":"X","cat":"fee","dur":3.6,"name":"splitdrive (d:\\coding\\python3.6\\lib\\ntpath.py:122)"},{"pid":4936,"tid":16712,"ts":109146838410.5,"ph":"X","cat":"fee","dur":0.02,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146838414.1,"ph":"X","cat":"fee","dur":0.4,"name":"str.rstrip"},{"pid":4936,"tid":16712,"ts":109146838401.4,"ph":"X","cat":"fee","dur":13.7,"name":"split (d:\\coding\\python3.6\\lib\\ntpath.py:200)"},{"pid":4936,"tid":16712,"ts":109146838401.0,"ph":"X","cat":"fee","dur":14.6,"name":"basename (d:\\coding\\python3.6\\lib\\ntpath.py:234)"},{"pid":4936,"tid":16712,"ts":109146838416.4,"ph":"X","cat":"fee","dur":0.1,"name":"nt.fspath"},{"pid":4936,"tid":16712,"ts":109146838416.7,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":4936,"tid":16712,"ts":109146838417.6,"ph":"X","cat":"fee","dur":0.7,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146838418.6,"ph":"X","cat":"fee","dur":0.2,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146838419.0,"ph":"X","cat":"fee","dur":0.7,"name":"builtins.max"},{"pid":4936,"tid":16712,"ts":109146838419.9,"ph":"X","cat":"fee","dur":0.2,"name":"str.rfind"},{"pid":4936,"tid":16712,"ts":109146838417.4,"ph":"X","cat":"fee","dur":4.1,"name":"_splitext (d:\\coding\\python3.6\\lib\\genericpath.py:117)"},{"pid":4936,"tid":16712,"ts":109146838416.3,"ph":"X","cat":"fee","dur":5.4,"name":"splitext (d:\\coding\\python3.6\\lib\\ntpath.py:223)"},{"pid":4936,"tid":16712,"ts":109146838425.7,"ph":"X","cat":"fee","dur":0.3,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146838427.0,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.get_ident"},{"pid":4936,"tid":16712,"ts":109146838426.7,"ph":"X","cat":"fee","dur":0.8,"name":"current_thread (d:\\coding\\python3.6\\lib\\threading.py:1230)"},{"pid":4936,"tid":16712,"ts":109146838428.1,"ph":"X","cat":"fee","dur":0.4,"name":"name (d:\\coding\\python3.6\\lib\\threading.py:1076)"},{"pid":4936,"tid":16712,"ts":109146838429.3,"ph":"X","cat":"fee","dur":0.3,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146838430.4,"ph":"X","cat":"fee","dur":0.1,"name":"current_process (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:35)"},{"pid":4936,"tid":16712,"ts":109146838430.9,"ph":"X","cat":"fee","dur":0.2,"name":"name (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:146)"},{"pid":4936,"tid":16712,"ts":109146838431.7,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146838432.2,"ph":"X","cat":"fee","dur":0.4,"name":"nt.getpid"},{"pid":4936,"tid":16712,"ts":109146838396.8,"ph":"X","cat":"fee","dur":36.0,"name":"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:251)"},{"pid":4936,"tid":16712,"ts":109146838395.5,"ph":"X","cat":"fee","dur":38.0,"name":"makeRecord (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1406)"},{"pid":4936,"tid":16712,"ts":109146838434.8,"ph":"X","cat":"fee","dur":0.3,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146838437.5,"ph":"X","cat":"fee","dur":0.2,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146838438.7,"ph":"X","cat":"fee","dur":0.3,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146838438.2,"ph":"X","cat":"fee","dur":0.9,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146838442.1,"ph":"X","cat":"fee","dur":0.8,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146838444.4,"ph":"X","cat":"fee","dur":0.5,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146838443.8,"ph":"X","cat":"fee","dur":1.3,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146838443.3,"ph":"X","cat":"fee","dur":2.2,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146838446.6,"ph":"X","cat":"fee","dur":5.6,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146838452.5,"ph":"X","cat":"fee","dur":5.6,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146838446.0,"ph":"X","cat":"fee","dur":12.2,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146838459.5,"ph":"X","cat":"fee","dur":3.0,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146838459.1,"ph":"X","cat":"fee","dur":3.6,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146838479.4,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.id"},{"pid":4936,"tid":16712,"ts":109146838479.8,"ph":"X","cat":"fee","dur":0.2,"name":"set.add"},{"pid":4936,"tid":16712,"ts":109146838487.7,"ph":"X","cat":"fee","dur":10.2,"name":"builtins.getattr"},{"pid":4936,"tid":16712,"ts":109146838499.3,"ph":"X","cat":"fee","dur":1.5,"name":"walk_tb (d:\\coding\\python3.6\\lib\\traceback.py:303)"},{"pid":4936,"tid":16712,"ts":109146838501.5,"ph":"X","cat":"fee","dur":0.2,"name":"set.add"},{"pid":4936,"tid":16712,"ts":109146838504.8,"ph":"X","cat":"fee","dur":0.6,"name":"str.startswith"},{"pid":4936,"tid":16712,"ts":109146838508.1,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":4936,"tid":16712,"ts":109146838508.6,"ph":"X","cat":"fee","dur":1.6,"name":"builtins.getattr"},{"pid":4936,"tid":16712,"ts":109146838503.6,"ph":"X","cat":"fee","dur":6.9,"name":"lazycache (d:\\coding\\python3.6\\lib\\linecache.py:147)"},{"pid":4936,"tid":16712,"ts":109146838597.0,"ph":"X","cat":"fee","dur":2.2,"name":"__init__ (d:\\coding\\python3.6\\lib\\traceback.py:243)"},{"pid":4936,"tid":16712,"ts":109146838599.7,"ph":"X","cat":"fee","dur":0.3,"name":"StackSummary.append"},{"pid":4936,"tid":16712,"ts":109146838600.3,"ph":"X","cat":"fee","dur":0.7,"name":"walk_tb (d:\\coding\\python3.6\\lib\\traceback.py:303)"},{"pid":4936,"tid":16712,"ts":109146838603.3,"ph":"X","cat":"fee","dur":0.8,"name":"checkcache (d:\\coding\\python3.6\\lib\\linecache.py:53)"},{"pid":4936,"tid":16712,"ts":109146838611.3,"ph":"X","cat":"fee","dur":0.5,"name":"str.startswith"},{"pid":4936,"tid":16712,"ts":109146838612.4,"ph":"X","cat":"fee","dur":73.6,"name":"nt.stat"},{"pid":4936,"tid":16712,"ts":109146838689.0,"ph":"X","cat":"fee","dur":67.4,"name":"io.open"},{"pid":4936,"tid":16712,"ts":109146838766.0,"ph":"X","cat":"fee","dur":17.6,"name":"_io.BufferedReader.readline"},{"pid":4936,"tid":16712,"ts":109146838765.7,"ph":"X","cat":"fee","dur":18.1,"name":"read_or_stop (d:\\coding\\python3.6\\lib\\tokenize.py:379)"},{"pid":4936,"tid":16712,"ts":109146838785.0,"ph":"X","cat":"fee","dur":1.1,"name":"bytes.startswith"},{"pid":4936,"tid":16712,"ts":109146838788.0,"ph":"X","cat":"fee","dur":2.2,"name":"bytes.decode"},{"pid":4936,"tid":16712,"ts":109146838791.4,"ph":"X","cat":"fee","dur":5.1,"name":"_sre.SRE_Pattern.match"},{"pid":4936,"tid":16712,"ts":109146838797.2,"ph":"X","cat":"fee","dur":0.6,"name":"_sre.SRE_Match.group"},{"pid":4936,"tid":16712,"ts":109146838799.2,"ph":"X","cat":"fee","dur":0.2,"name":"str.lower"},{"pid":4936,"tid":16712,"ts":109146838799.6,"ph":"X","cat":"fee","dur":0.4,"name":"str.replace"},{"pid":4936,"tid":16712,"ts":109146838798.5,"ph":"X","cat":"fee","dur":2.0,"name":"_get_normal_name (d:\\coding\\python3.6\\lib\\tokenize.py:344)"},{"pid":4936,"tid":16712,"ts":109146838800.9,"ph":"X","cat":"fee","dur":3.9,"name":"_codecs.lookup"},{"pid":4936,"tid":16712,"ts":109146838787.5,"ph":"X","cat":"fee","dur":17.7,"name":"find_cookie (d:\\coding\\python3.6\\lib\\tokenize.py:385)"},{"pid":4936,"tid":16712,"ts":109146838758.9,"ph":"X","cat":"fee","dur":46.8,"name":"detect_encoding (d:\\coding\\python3.6\\lib\\tokenize.py:355)"},{"pid":4936,"tid":16712,"ts":109146838806.9,"ph":"X","cat":"fee","dur":6.1,"name":"_io.BufferedReader.seek"},{"pid":4936,"tid":16712,"ts":109146838822.8,"ph":"X","cat":"fee","dur":1.3,"name":"__init__ (d:\\coding\\python3.6\\lib\\codecs.py:259)"},{"pid":4936,"tid":16712,"ts":109146838820.8,"ph":"X","cat":"fee","dur":4.0,"name":"__init__ (d:\\coding\\python3.6\\lib\\codecs.py:308)"},{"pid":4936,"tid":16712,"ts":109146838688.4,"ph":"X","cat":"fee","dur":141.1,"name":"open (d:\\coding\\python3.6\\lib\\tokenize.py:448)"},{"pid":4936,"tid":16712,"ts":109146838843.7,"ph":"X","cat":"fee","dur":10.3,"name":"_codecs.utf_8_decode"},{"pid":4936,"tid":16712,"ts":109146838842.1,"ph":"X","cat":"fee","dur":13.4,"name":"decode (d:\\coding\\python3.6\\lib\\codecs.py:318)"},{"pid":4936,"tid":16712,"ts":109146838913.0,"ph":"X","cat":"fee","dur":1.3,"name":"_codecs.utf_8_decode"},{"pid":4936,"tid":16712,"ts":109146838911.9,"ph":"X","cat":"fee","dur":3.8,"name":"decode (d:\\coding\\python3.6\\lib\\codecs.py:318)"},{"pid":4936,"tid":16712,"ts":109146838834.4,"ph":"X","cat":"fee","dur":82.9,"name":"_io.TextIOWrapper.readlines"},{"pid":4936,"tid":16712,"ts":109146838956.3,"ph":"X","cat":"fee","dur":1.2,"name":"str.endswith"},{"pid":4936,"tid":16712,"ts":109146838610.6,"ph":"X","cat":"fee","dur":350.0,"name":"updatecache (d:\\coding\\python3.6\\lib\\linecache.py:82)"},{"pid":4936,"tid":16712,"ts":109146838608.4,"ph":"X","cat":"fee","dur":359.1,"name":"getlines (d:\\coding\\python3.6\\lib\\linecache.py:37)"},{"pid":4936,"tid":16712,"ts":109146838968.6,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.len"},{"pid":4936,"tid":16712,"ts":109146838607.0,"ph":"X","cat":"fee","dur":362.3,"name":"getline (d:\\coding\\python3.6\\lib\\linecache.py:15)"},{"pid":4936,"tid":16712,"ts":109146838970.5,"ph":"X","cat":"fee","dur":0.5,"name":"str.strip"},{"pid":4936,"tid":16712,"ts":109146838605.5,"ph":"X","cat":"fee","dur":366.5,"name":"line (d:\\coding\\python3.6\\lib\\traceback.py:283)"},{"pid":4936,"tid":16712,"ts":109146838486.9,"ph":"X","cat":"fee","dur":486.2,"name":"extract (d:\\coding\\python3.6\\lib\\traceback.py:319)"},{"pid":4936,"tid":16712,"ts":109146838978.2,"ph":"X","cat":"fee","dur":1.7,"name":"_some_str (d:\\coding\\python3.6\\lib\\traceback.py:153)"},{"pid":4936,"tid":16712,"ts":109146838981.5,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.issubclass"},{"pid":4936,"tid":16712,"ts":109146838984.6,"ph":"X","cat":"fee","dur":0.4,"name":"line (d:\\coding\\python3.6\\lib\\traceback.py:283)"},{"pid":4936,"tid":16712,"ts":109146838983.4,"ph":"X","cat":"fee","dur":2.4,"name":"_load_lines (d:\\coding\\python3.6\\lib\\traceback.py:529)"},{"pid":4936,"tid":16712,"ts":109146838477.9,"ph":"X","cat":"fee","dur":508.2,"name":"__init__ (d:\\coding\\python3.6\\lib\\traceback.py:466)"},{"pid":4936,"tid":16712,"ts":109146838989.0,"ph":"X","cat":"fee","dur":1.1,"name":"format (d:\\coding\\python3.6\\lib\\traceback.py:589)"},{"pid":4936,"tid":16712,"ts":109146838990.7,"ph":"X","cat":"fee","dur":6.1,"name":"builtins.print"},{"pid":4936,"tid":16712,"ts":109146839007.8,"ph":"X","cat":"fee","dur":3.0,"name":"str.format"},{"pid":4936,"tid":16712,"ts":109146839011.0,"ph":"X","cat":"fee","dur":0.2,"name":"list.append"},{"pid":4936,"tid":16712,"ts":109146839011.8,"ph":"X","cat":"fee","dur":0.4,"name":"line (d:\\coding\\python3.6\\lib\\traceback.py:283)"},{"pid":4936,"tid":16712,"ts":109146839013.0,"ph":"X","cat":"fee","dur":0.5,"name":"line (d:\\coding\\python3.6\\lib\\traceback.py:283)"},{"pid":4936,"tid":16712,"ts":109146839013.8,"ph":"X","cat":"fee","dur":0.6,"name":"str.strip"},{"pid":4936,"tid":16712,"ts":109146839014.5,"ph":"X","cat":"fee","dur":1.1,"name":"str.format"},{"pid":4936,"tid":16712,"ts":109146839015.8,"ph":"X","cat":"fee","dur":0.2,"name":"list.append"},{"pid":4936,"tid":16712,"ts":109146839018.5,"ph":"X","cat":"fee","dur":0.6,"name":"str.join"},{"pid":4936,"tid":16712,"ts":109146839019.2,"ph":"X","cat":"fee","dur":0.2,"name":"list.append"},{"pid":4936,"tid":16712,"ts":109146839003.9,"ph":"X","cat":"fee","dur":16.3,"name":"format (d:\\coding\\python3.6\\lib\\traceback.py:386)"},{"pid":4936,"tid":16712,"ts":109146839001.6,"ph":"X","cat":"fee","dur":19.7,"name":"format (d:\\coding\\python3.6\\lib\\traceback.py:589)"},{"pid":4936,"tid":16712,"ts":109146839021.7,"ph":"X","cat":"fee","dur":3.4,"name":"builtins.print"},{"pid":4936,"tid":16712,"ts":109146839032.4,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.issubclass"},{"pid":4936,"tid":16712,"ts":109146839034.1,"ph":"X","cat":"fee","dur":0.7,"name":"_some_str (d:\\coding\\python3.6\\lib\\traceback.py:153)"},{"pid":4936,"tid":16712,"ts":109146839033.6,"ph":"X","cat":"fee","dur":2.9,"name":"_format_final_exc_line (d:\\coding\\python3.6\\lib\\traceback.py:145)"},{"pid":4936,"tid":16712,"ts":109146839027.7,"ph":"X","cat":"fee","dur":9.1,"name":"format_exception_only (d:\\coding\\python3.6\\lib\\traceback.py:544)"},{"pid":4936,"tid":16712,"ts":109146839025.7,"ph":"X","cat":"fee","dur":11.12,"name":"format (d:\\coding\\python3.6\\lib\\traceback.py:589)"},{"pid":4936,"tid":16712,"ts":109146839037.1,"ph":"X","cat":"fee","dur":1.2,"name":"builtins.print"},{"pid":4936,"tid":16712,"ts":109146839038.9,"ph":"X","cat":"fee","dur":0.2,"name":"format_exception_only (d:\\coding\\python3.6\\lib\\traceback.py:544)"},{"pid":4936,"tid":16712,"ts":109146839038.7,"ph":"X","cat":"fee","dur":1.4,"name":"format (d:\\coding\\python3.6\\lib\\traceback.py:589)"},{"pid":4936,"tid":16712,"ts":109146838474.2,"ph":"X","cat":"fee","dur":567.3,"name":"print_exception (d:\\coding\\python3.6\\lib\\traceback.py:87)"},{"pid":4936,"tid":16712,"ts":109146839042.0,"ph":"X","cat":"fee","dur":1.1,"name":"_io.StringIO.getvalue"},{"pid":4936,"tid":16712,"ts":109146839043.5,"ph":"X","cat":"fee","dur":0.3,"name":"_io.StringIO.close"},{"pid":4936,"tid":16712,"ts":109146838463.9,"ph":"X","cat":"fee","dur":581.4,"name":"formatException (d:\\coding\\python3.6\\lib\\logging\\__init__.py:523)"},{"pid":4936,"tid":16712,"ts":109146838441.8,"ph":"X","cat":"fee","dur":621.1,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146838441.0,"ph":"X","cat":"fee","dur":622.2,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146839063.9,"ph":"X","cat":"fee","dur":7.0,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146839071.4,"ph":"X","cat":"fee","dur":1.2,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146839074.4,"ph":"X","cat":"fee","dur":0.4,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146839073.8,"ph":"X","cat":"fee","dur":1.2,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146839075.6,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146839076.3,"ph":"X","cat":"fee","dur":21.6,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146839099.1,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146839098.7,"ph":"X","cat":"fee","dur":0.6,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146839073.2,"ph":"X","cat":"fee","dur":26.3,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146838440.4,"ph":"X","cat":"fee","dur":659.3,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146838439.7,"ph":"X","cat":"fee","dur":660.3,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1063)"},{"pid":4936,"tid":16712,"ts":109146839100.7,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146839100.6,"ph":"X","cat":"fee","dur":0.3,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146838437.1,"ph":"X","cat":"fee","dur":663.9,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146839103.3,"ph":"X","cat":"fee","dur":0.6,"name":"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)"},{"pid":4936,"tid":16712,"ts":109146839104.6,"ph":"X","cat":"fee","dur":0.4,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146839104.3,"ph":"X","cat":"fee","dur":0.72,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146839107.0,"ph":"X","cat":"fee","dur":1.0,"name":"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)"},{"pid":4936,"tid":16712,"ts":109146839109.8,"ph":"X","cat":"fee","dur":0.9,"name":"str.find"},{"pid":4936,"tid":16712,"ts":109146839109.3,"ph":"X","cat":"fee","dur":1.7,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)"},{"pid":4936,"tid":16712,"ts":109146839108.6,"ph":"X","cat":"fee","dur":2.5,"name":"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)"},{"pid":4936,"tid":16712,"ts":109146839115.1,"ph":"X","cat":"fee","dur":5.7,"name":"time.localtime"},{"pid":4936,"tid":16712,"ts":109146839121.3,"ph":"X","cat":"fee","dur":5.3,"name":"time.strftime"},{"pid":4936,"tid":16712,"ts":109146839114.6,"ph":"X","cat":"fee","dur":12.2,"name":"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)"},{"pid":4936,"tid":16712,"ts":109146839128.4,"ph":"X","cat":"fee","dur":2.8,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)"},{"pid":4936,"tid":16712,"ts":109146839128.0,"ph":"X","cat":"fee","dur":3.4,"name":"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)"},{"pid":4936,"tid":16712,"ts":109146839106.6,"ph":"X","cat":"fee","dur":26.1,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)"},{"pid":4936,"tid":16712,"ts":109146839106.0,"ph":"X","cat":"fee","dur":26.9,"name":"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)"},{"pid":4936,"tid":16712,"ts":109146839133.5,"ph":"X","cat":"fee","dur":1948.4,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146841083.9,"ph":"X","cat":"fee","dur":1378.3,"name":"_io.TextIOWrapper.write"},{"pid":4936,"tid":16712,"ts":109146842467.1,"ph":"X","cat":"fee","dur":1.2,"name":"_thread.RLock.acquire"},{"pid":4936,"tid":16712,"ts":109146842466.2,"ph":"X","cat":"fee","dur":2.8,"name":"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)"},{"pid":4936,"tid":16712,"ts":109146842470.5,"ph":"X","cat":"fee","dur":1.0,"name":"builtins.hasattr"},{"pid":4936,"tid":16712,"ts":109146842471.9,"ph":"X","cat":"fee","dur":1.4,"name":"_io.TextIOWrapper.flush"},{"pid":4936,"tid":16712,"ts":109146842474.5,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146842474.1,"ph":"X","cat":"fee","dur":0.7,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146842465.0,"ph":"X","cat":"fee","dur":10.0,"name":"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)"},{"pid":4936,"tid":16712,"ts":109146839105.5,"ph":"X","cat":"fee","dur":3369.9,"name":"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)"},{"pid":4936,"tid":16712,"ts":109146842476.5,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.RLock.release"},{"pid":4936,"tid":16712,"ts":109146842476.2,"ph":"X","cat":"fee","dur":0.5,"name":"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)"},{"pid":4936,"tid":16712,"ts":109146839102.8,"ph":"X","cat":"fee","dur":3374.1,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)"},{"pid":4936,"tid":16712,"ts":109146838435.5,"ph":"X","cat":"fee","dur":4045.3,"name":"callHandlers (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1500)"},{"pid":4936,"tid":16712,"ts":109146838434.1,"ph":"X","cat":"fee","dur":4047.2,"name":"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1446)"},{"pid":4936,"tid":16712,"ts":109146838344.8,"ph":"X","cat":"fee","dur":4136.8,"name":"_log (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1421)"},{"pid":4936,"tid":16712,"ts":109146838340.1,"ph":"X","cat":"fee","dur":4145.0,"name":"error (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1327)"},{"pid":4936,"tid":16712,"ts":109146838335.7,"ph":"X","cat":"fee","dur":4168.8,"name":"exception (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1339)"},{"pid":4936,"tid":16712,"ts":109146836245.9,"ph":"X","cat":"fee","dur":6261.3,"name":"<module> (C:\\Users\\libuliduobuqiuqiu\\Desktop\\GitProjects\\PythonDemo\\Logging\\logging_example.py:6)"},{"pid":4936,"tid":16712,"ts":109146836244.7,"ph":"X","cat":"fee","dur":6263.1,"name":"builtins.exec"}],"viztracer_metadata":{"overflow":false,"version":"0.15.2"},"file_info":{"files":{"d:\\coding\\python3.6\\lib\\logging\\__init__.py":["# Copyright 2001-2016 by Vinay Sajip. All Rights Reserved.\n#\n# Permission to use, copy, modify, and distribute this software and its\n# documentation for any purpose and without fee is hereby granted,\n# provided that the above copyright notice appear in all copies and that\n# both that copyright notice and this permission notice appear in\n# supporting documentation, and that the name of Vinay Sajip\n# not be used in advertising or publicity pertaining to distribution\n# of the software without specific, written prior permission.\n# VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\n# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL\n# VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\n# ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\"\"\"\nLogging package for Python. Based on PEP 282 and comments thereto in\ncomp.lang.python.\n\nCopyright (C) 2001-2016 Vinay Sajip. All Rights Reserved.\n\nTo use, simply 'import logging' and log away!\n\"\"\"\n\nimport sys, os, time, io, traceback, warnings, weakref, collections\n\nfrom string import Template\n\n__all__ = ['BASIC_FORMAT', 'BufferingFormatter', 'CRITICAL', 'DEBUG', 'ERROR',\n           'FATAL', 'FileHandler', 'Filter', 'Formatter', 'Handler', 'INFO',\n           'LogRecord', 'Logger', 'LoggerAdapter', 'NOTSET', 'NullHandler',\n           'StreamHandler', 'WARN', 'WARNING', 'addLevelName', 'basicConfig',\n           'captureWarnings', 'critical', 'debug', 'disable', 'error',\n           'exception', 'fatal', 'getLevelName', 'getLogger', 'getLoggerClass',\n           'info', 'log', 'makeLogRecord', 'setLoggerClass', 'shutdown',\n           'warn', 'warning', 'getLogRecordFactory', 'setLogRecordFactory',\n           'lastResort', 'raiseExceptions']\n\ntry:\n    import threading\nexcept ImportError: #pragma: no cover\n    threading = None\n\n__author__  = \"Vinay Sajip <vinay_sajip@red-dove.com>\"\n__status__  = \"production\"\n# The following module attributes are no longer updated.\n__version__ = \"0.5.1.2\"\n__date__    = \"07 February 2010\"\n\n#---------------------------------------------------------------------------\n#   Miscellaneous module data\n#---------------------------------------------------------------------------\n\n#\n#_startTime is used as the base when calculating the relative time of events\n#\n_startTime = time.time()\n\n#\n#raiseExceptions is used to see if exceptions during handling should be\n#propagated\n#\nraiseExceptions = True\n\n#\n# If you don't want threading information in the log, set this to zero\n#\nlogThreads = True\n\n#\n# If you don't want multiprocessing information in the log, set this to zero\n#\nlogMultiprocessing = True\n\n#\n# If you don't want process information in the log, set this to zero\n#\nlogProcesses = True\n\n#---------------------------------------------------------------------------\n#   Level related stuff\n#---------------------------------------------------------------------------\n#\n# Default levels and level names, these can be replaced with any positive set\n# of values having corresponding names. There is a pseudo-level, NOTSET, which\n# is only really there as a lower limit for user-defined levels. Handlers and\n# loggers are initialized with NOTSET so that they will log all messages, even\n# at user-defined levels.\n#\n\nCRITICAL = 50\nFATAL = CRITICAL\nERROR = 40\nWARNING = 30\nWARN = WARNING\nINFO = 20\nDEBUG = 10\nNOTSET = 0\n\n_levelToName = {\n    CRITICAL: 'CRITICAL',\n    ERROR: 'ERROR',\n    WARNING: 'WARNING',\n    INFO: 'INFO',\n    DEBUG: 'DEBUG',\n    NOTSET: 'NOTSET',\n}\n_nameToLevel = {\n    'CRITICAL': CRITICAL,\n    'FATAL': FATAL,\n    'ERROR': ERROR,\n    'WARN': WARNING,\n    'WARNING': WARNING,\n    'INFO': INFO,\n    'DEBUG': DEBUG,\n    'NOTSET': NOTSET,\n}\n\ndef getLevelName(level):\n    \"\"\"\n    Return the textual representation of logging level 'level'.\n\n    If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,\n    INFO, DEBUG) then you get the corresponding string. If you have\n    associated levels with names using addLevelName then the name you have\n    associated with 'level' is returned.\n\n    If a numeric value corresponding to one of the defined levels is passed\n    in, the corresponding string representation is returned.\n\n    Otherwise, the string \"Level %s\" % level is returned.\n    \"\"\"\n    # See Issues #22386, #27937 and #29220 for why it's this way\n    result = _levelToName.get(level)\n    if result is not None:\n        return result\n    result = _nameToLevel.get(level)\n    if result is not None:\n        return result\n    return \"Level %s\" % level\n\ndef addLevelName(level, levelName):\n    \"\"\"\n    Associate 'levelName' with 'level'.\n\n    This is used when converting levels to text during message formatting.\n    \"\"\"\n    _acquireLock()\n    try:    #unlikely to cause an exception, but you never know...\n        _levelToName[level] = levelName\n        _nameToLevel[levelName] = level\n    finally:\n        _releaseLock()\n\nif hasattr(sys, '_getframe'):\n    currentframe = lambda: sys._getframe(3)\nelse: #pragma: no cover\n    def currentframe():\n        \"\"\"Return the frame object for the caller's stack frame.\"\"\"\n        try:\n            raise Exception\n        except Exception:\n            return sys.exc_info()[2].tb_frame.f_back\n\n#\n# _srcfile is used when walking the stack to check when we've got the first\n# caller stack frame, by skipping frames whose filename is that of this\n# module's source. It therefore should contain the filename of this module's\n# source file.\n#\n# Ordinarily we would use __file__ for this, but frozen modules don't always\n# have __file__ set, for some reason (see Issue #21736). Thus, we get the\n# filename from a handy code object from a function defined in this module.\n# (There's no particular reason for picking addLevelName.)\n#\n\n_srcfile = os.path.normcase(addLevelName.__code__.co_filename)\n\n# _srcfile is only used in conjunction with sys._getframe().\n# To provide compatibility with older versions of Python, set _srcfile\n# to None if _getframe() is not available; this value will prevent\n# findCaller() from being called. You can also do this if you want to avoid\n# the overhead of fetching caller information, even when _getframe() is\n# available.\n#if not hasattr(sys, '_getframe'):\n#    _srcfile = None\n\n\ndef _checkLevel(level):\n    if isinstance(level, int):\n        rv = level\n    elif str(level) == level:\n        if level not in _nameToLevel:\n            raise ValueError(\"Unknown level: %r\" % level)\n        rv = _nameToLevel[level]\n    else:\n        raise TypeError(\"Level not an integer or a valid string: %r\" % level)\n    return rv\n\n#---------------------------------------------------------------------------\n#   Thread-related stuff\n#---------------------------------------------------------------------------\n\n#\n#_lock is used to serialize access to shared data structures in this module.\n#This needs to be an RLock because fileConfig() creates and configures\n#Handlers, and so might arbitrary user threads. Since Handler code updates the\n#shared dictionary _handlers, it needs to acquire the lock. But if configuring,\n#the lock would already have been acquired - so we need an RLock.\n#The same argument applies to Loggers and Manager.loggerDict.\n#\nif threading:\n    _lock = threading.RLock()\nelse: #pragma: no cover\n    _lock = None\n\n\ndef _acquireLock():\n    \"\"\"\n    Acquire the module-level lock for serializing access to shared data.\n\n    This should be released with _releaseLock().\n    \"\"\"\n    if _lock:\n        _lock.acquire()\n\ndef _releaseLock():\n    \"\"\"\n    Release the module-level lock acquired by calling _acquireLock().\n    \"\"\"\n    if _lock:\n        _lock.release()\n\n#---------------------------------------------------------------------------\n#   The logging record\n#---------------------------------------------------------------------------\n\nclass LogRecord(object):\n    \"\"\"\n    A LogRecord instance represents an event being logged.\n\n    LogRecord instances are created every time something is logged. They\n    contain all the information pertinent to the event being logged. The\n    main information passed in is in msg and args, which are combined\n    using str(msg) % args to create the message field of the record. The\n    record also includes information such as when the record was created,\n    the source line where the logging call was made, and any exception\n    information to be logged.\n    \"\"\"\n    def __init__(self, name, level, pathname, lineno,\n                 msg, args, exc_info, func=None, sinfo=None, **kwargs):\n        \"\"\"\n        Initialize a logging record with interesting information.\n        \"\"\"\n        ct = time.time()\n        self.name = name\n        self.msg = msg\n        #\n        # The following statement allows passing of a dictionary as a sole\n        # argument, so that you can do something like\n        #  logging.debug(\"a %(a)d b %(b)s\", {'a':1, 'b':2})\n        # Suggested by Stefan Behnel.\n        # Note that without the test for args[0], we get a problem because\n        # during formatting, we test to see if the arg is present using\n        # 'if self.args:'. If the event being logged is e.g. 'Value is %d'\n        # and if the passed arg fails 'if self.args:' then no formatting\n        # is done. For example, logger.warning('Value is %d', 0) would log\n        # 'Value is %d' instead of 'Value is 0'.\n        # For the use case of passing a dictionary, this should not be a\n        # problem.\n        # Issue #21172: a request was made to relax the isinstance check\n        # to hasattr(args[0], '__getitem__'). However, the docs on string\n        # formatting still seem to suggest a mapping object is required.\n        # Thus, while not removing the isinstance check, it does now look\n        # for collections.Mapping rather than, as before, dict.\n        if (args and len(args) == 1 and isinstance(args[0], collections.Mapping)\n            and args[0]):\n            args = args[0]\n        self.args = args\n        self.levelname = getLevelName(level)\n        self.levelno = level\n        self.pathname = pathname\n        try:\n            self.filename = os.path.basename(pathname)\n            self.module = os.path.splitext(self.filename)[0]\n        except (TypeError, ValueError, AttributeError):\n            self.filename = pathname\n            self.module = \"Unknown module\"\n        self.exc_info = exc_info\n        self.exc_text = None      # used to cache the traceback text\n        self.stack_info = sinfo\n        self.lineno = lineno\n        self.funcName = func\n        self.created = ct\n        self.msecs = (ct - int(ct)) * 1000\n        self.relativeCreated = (self.created - _startTime) * 1000\n        if logThreads and threading:\n            self.thread = threading.get_ident()\n            self.threadName = threading.current_thread().name\n        else: # pragma: no cover\n            self.thread = None\n            self.threadName = None\n        if not logMultiprocessing: # pragma: no cover\n            self.processName = None\n        else:\n            self.processName = 'MainProcess'\n            mp = sys.modules.get('multiprocessing')\n            if mp is not None:\n                # Errors may occur if multiprocessing has not finished loading\n                # yet - e.g. if a custom import hook causes third-party code\n                # to run when multiprocessing calls import. See issue 8200\n                # for an example\n                try:\n                    self.processName = mp.current_process().name\n                except Exception: #pragma: no cover\n                    pass\n        if logProcesses and hasattr(os, 'getpid'):\n            self.process = os.getpid()\n        else:\n            self.process = None\n\n    def __str__(self):\n        return '<LogRecord: %s, %s, %s, %s, \"%s\">'%(self.name, self.levelno,\n            self.pathname, self.lineno, self.msg)\n\n    __repr__ = __str__\n\n    def getMessage(self):\n        \"\"\"\n        Return the message for this LogRecord.\n\n        Return the message for this LogRecord after merging any user-supplied\n        arguments with the message.\n        \"\"\"\n        msg = str(self.msg)\n        if self.args:\n            msg = msg % self.args\n        return msg\n\n#\n#   Determine which class to use when instantiating log records.\n#\n_logRecordFactory = LogRecord\n\ndef setLogRecordFactory(factory):\n    \"\"\"\n    Set the factory to be used when instantiating a log record.\n\n    :param factory: A callable which will be called to instantiate\n    a log record.\n    \"\"\"\n    global _logRecordFactory\n    _logRecordFactory = factory\n\ndef getLogRecordFactory():\n    \"\"\"\n    Return the factory to be used when instantiating a log record.\n    \"\"\"\n\n    return _logRecordFactory\n\ndef makeLogRecord(dict):\n    \"\"\"\n    Make a LogRecord whose attributes are defined by the specified dictionary,\n    This function is useful for converting a logging event received over\n    a socket connection (which is sent as a dictionary) into a LogRecord\n    instance.\n    \"\"\"\n    rv = _logRecordFactory(None, None, \"\", 0, \"\", (), None, None)\n    rv.__dict__.update(dict)\n    return rv\n\n#---------------------------------------------------------------------------\n#   Formatter classes and functions\n#---------------------------------------------------------------------------\n\nclass PercentStyle(object):\n\n    default_format = '%(message)s'\n    asctime_format = '%(asctime)s'\n    asctime_search = '%(asctime)'\n\n    def __init__(self, fmt):\n        self._fmt = fmt or self.default_format\n\n    def usesTime(self):\n        return self._fmt.find(self.asctime_search) >= 0\n\n    def format(self, record):\n        return self._fmt % record.__dict__\n\nclass StrFormatStyle(PercentStyle):\n    default_format = '{message}'\n    asctime_format = '{asctime}'\n    asctime_search = '{asctime'\n\n    def format(self, record):\n        return self._fmt.format(**record.__dict__)\n\n\nclass StringTemplateStyle(PercentStyle):\n    default_format = '${message}'\n    asctime_format = '${asctime}'\n    asctime_search = '${asctime}'\n\n    def __init__(self, fmt):\n        self._fmt = fmt or self.default_format\n        self._tpl = Template(self._fmt)\n\n    def usesTime(self):\n        fmt = self._fmt\n        return fmt.find('$asctime') >= 0 or fmt.find(self.asctime_format) >= 0\n\n    def format(self, record):\n        return self._tpl.substitute(**record.__dict__)\n\nBASIC_FORMAT = \"%(levelname)s:%(name)s:%(message)s\"\n\n_STYLES = {\n    '%': (PercentStyle, BASIC_FORMAT),\n    '{': (StrFormatStyle, '{levelname}:{name}:{message}'),\n    '$': (StringTemplateStyle, '${levelname}:${name}:${message}'),\n}\n\nclass Formatter(object):\n    \"\"\"\n    Formatter instances are used to convert a LogRecord to text.\n\n    Formatters need to know how a LogRecord is constructed. They are\n    responsible for converting a LogRecord to (usually) a string which can\n    be interpreted by either a human or an external system. The base Formatter\n    allows a formatting string to be specified. If none is supplied, the\n    the style-dependent default value, \"%(message)s\", \"{message}\", or\n    \"${message}\", is used.\n\n    The Formatter can be initialized with a format string which makes use of\n    knowledge of the LogRecord attributes - e.g. the default value mentioned\n    above makes use of the fact that the user's message and arguments are pre-\n    formatted into a LogRecord's message attribute. Currently, the useful\n    attributes in a LogRecord are described by:\n\n    %(name)s            Name of the logger (logging channel)\n    %(levelno)s         Numeric logging level for the message (DEBUG, INFO,\n                        WARNING, ERROR, CRITICAL)\n    %(levelname)s       Text logging level for the message (\"DEBUG\", \"INFO\",\n                        \"WARNING\", \"ERROR\", \"CRITICAL\")\n    %(pathname)s        Full pathname of the source file where the logging\n                        call was issued (if available)\n    %(filename)s        Filename portion of pathname\n    %(module)s          Module (name portion of filename)\n    %(lineno)d          Source line number where the logging call was issued\n                        (if available)\n    %(funcName)s        Function name\n    %(created)f         Time when the LogRecord was created (time.time()\n                        return value)\n    %(asctime)s         Textual time when the LogRecord was created\n    %(msecs)d           Millisecond portion of the creation time\n    %(relativeCreated)d Time in milliseconds when the LogRecord was created,\n                        relative to the time the logging module was loaded\n                        (typically at application startup time)\n    %(thread)d          Thread ID (if available)\n    %(threadName)s      Thread name (if available)\n    %(process)d         Process ID (if available)\n    %(message)s         The result of record.getMessage(), computed just as\n                        the record is emitted\n    \"\"\"\n\n    converter = time.localtime\n\n    def __init__(self, fmt=None, datefmt=None, style='%'):\n        \"\"\"\n        Initialize the formatter with specified format strings.\n\n        Initialize the formatter either with the specified format string, or a\n        default as described above. Allow for specialized date formatting with\n        the optional datefmt argument. If datefmt is omitted, you get an\n        ISO8601-like (or RFC 3339-like) format.\n\n        Use a style parameter of '%', '{' or '$' to specify that you want to\n        use one of %-formatting, :meth:`str.format` (``{}``) formatting or\n        :class:`string.Template` formatting in your format string.\n\n        .. versionchanged:: 3.2\n           Added the ``style`` parameter.\n        \"\"\"\n        if style not in _STYLES:\n            raise ValueError('Style must be one of: %s' % ','.join(\n                             _STYLES.keys()))\n        self._style = _STYLES[style][0](fmt)\n        self._fmt = self._style._fmt\n        self.datefmt = datefmt\n\n    default_time_format = '%Y-%m-%d %H:%M:%S'\n    default_msec_format = '%s,%03d'\n\n    def formatTime(self, record, datefmt=None):\n        \"\"\"\n        Return the creation time of the specified LogRecord as formatted text.\n\n        This method should be called from format() by a formatter which\n        wants to make use of a formatted time. This method can be overridden\n        in formatters to provide for any specific requirement, but the\n        basic behaviour is as follows: if datefmt (a string) is specified,\n        it is used with time.strftime() to format the creation time of the\n        record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.\n        The resulting string is returned. This function uses a user-configurable\n        function to convert the creation time to a tuple. By default,\n        time.localtime() is used; to change this for a particular formatter\n        instance, set the 'converter' attribute to a function with the same\n        signature as time.localtime() or time.gmtime(). To change it for all\n        formatters, for example if you want all logging times to be shown in GMT,\n        set the 'converter' attribute in the Formatter class.\n        \"\"\"\n        ct = self.converter(record.created)\n        if datefmt:\n            s = time.strftime(datefmt, ct)\n        else:\n            t = time.strftime(self.default_time_format, ct)\n            s = self.default_msec_format % (t, record.msecs)\n        return s\n\n    def formatException(self, ei):\n        \"\"\"\n        Format and return the specified exception information as a string.\n\n        This default implementation just uses\n        traceback.print_exception()\n        \"\"\"\n        sio = io.StringIO()\n        tb = ei[2]\n        # See issues #9427, #1553375. Commented out for now.\n        #if getattr(self, 'fullstack', False):\n        #    traceback.print_stack(tb.tb_frame.f_back, file=sio)\n        traceback.print_exception(ei[0], ei[1], tb, None, sio)\n        s = sio.getvalue()\n        sio.close()\n        if s[-1:] == \"\\n\":\n            s = s[:-1]\n        return s\n\n    def usesTime(self):\n        \"\"\"\n        Check if the format uses the creation time of the record.\n        \"\"\"\n        return self._style.usesTime()\n\n    def formatMessage(self, record):\n        return self._style.format(record)\n\n    def formatStack(self, stack_info):\n        \"\"\"\n        This method is provided as an extension point for specialized\n        formatting of stack information.\n\n        The input data is a string as returned from a call to\n        :func:`traceback.print_stack`, but with the last trailing newline\n        removed.\n\n        The base implementation just returns the value passed in.\n        \"\"\"\n        return stack_info\n\n    def format(self, record):\n        \"\"\"\n        Format the specified record as text.\n\n        The record's attribute dictionary is used as the operand to a\n        string formatting operation which yields the returned string.\n        Before formatting the dictionary, a couple of preparatory steps\n        are carried out. The message attribute of the record is computed\n        using LogRecord.getMessage(). If the formatting string uses the\n        time (as determined by a call to usesTime(), formatTime() is\n        called to format the event time. If there is exception information,\n        it is formatted using formatException() and appended to the message.\n        \"\"\"\n        record.message = record.getMessage()\n        if self.usesTime():\n            record.asctime = self.formatTime(record, self.datefmt)\n        s = self.formatMessage(record)\n        if record.exc_info:\n            # Cache the traceback text to avoid converting it multiple times\n            # (it's constant anyway)\n            if not record.exc_text:\n                record.exc_text = self.formatException(record.exc_info)\n        if record.exc_text:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + record.exc_text\n        if record.stack_info:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + self.formatStack(record.stack_info)\n        return s\n\n#\n#   The default formatter to use when no other is specified\n#\n_defaultFormatter = Formatter()\n\nclass BufferingFormatter(object):\n    \"\"\"\n    A formatter suitable for formatting a number of records.\n    \"\"\"\n    def __init__(self, linefmt=None):\n        \"\"\"\n        Optionally specify a formatter which will be used to format each\n        individual record.\n        \"\"\"\n        if linefmt:\n            self.linefmt = linefmt\n        else:\n            self.linefmt = _defaultFormatter\n\n    def formatHeader(self, records):\n        \"\"\"\n        Return the header string for the specified records.\n        \"\"\"\n        return \"\"\n\n    def formatFooter(self, records):\n        \"\"\"\n        Return the footer string for the specified records.\n        \"\"\"\n        return \"\"\n\n    def format(self, records):\n        \"\"\"\n        Format the specified records and return the result as a string.\n        \"\"\"\n        rv = \"\"\n        if len(records) > 0:\n            rv = rv + self.formatHeader(records)\n            for record in records:\n                rv = rv + self.linefmt.format(record)\n            rv = rv + self.formatFooter(records)\n        return rv\n\n#---------------------------------------------------------------------------\n#   Filter classes and functions\n#---------------------------------------------------------------------------\n\nclass Filter(object):\n    \"\"\"\n    Filter instances are used to perform arbitrary filtering of LogRecords.\n\n    Loggers and Handlers can optionally use Filter instances to filter\n    records as desired. The base filter class only allows events which are\n    below a certain point in the logger hierarchy. For example, a filter\n    initialized with \"A.B\" will allow events logged by loggers \"A.B\",\n    \"A.B.C\", \"A.B.C.D\", \"A.B.D\" etc. but not \"A.BB\", \"B.A.B\" etc. If\n    initialized with the empty string, all events are passed.\n    \"\"\"\n    def __init__(self, name=''):\n        \"\"\"\n        Initialize a filter.\n\n        Initialize with the name of the logger which, together with its\n        children, will have its events allowed through the filter. If no\n        name is specified, allow every event.\n        \"\"\"\n        self.name = name\n        self.nlen = len(name)\n\n    def filter(self, record):\n        \"\"\"\n        Determine if the specified record is to be logged.\n\n        Is the specified record to be logged? Returns 0 for no, nonzero for\n        yes. If deemed appropriate, the record may be modified in-place.\n        \"\"\"\n        if self.nlen == 0:\n            return True\n        elif self.name == record.name:\n            return True\n        elif record.name.find(self.name, 0, self.nlen) != 0:\n            return False\n        return (record.name[self.nlen] == \".\")\n\nclass Filterer(object):\n    \"\"\"\n    A base class for loggers and handlers which allows them to share\n    common code.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initialize the list of filters to be an empty list.\n        \"\"\"\n        self.filters = []\n\n    def addFilter(self, filter):\n        \"\"\"\n        Add the specified filter to this handler.\n        \"\"\"\n        if not (filter in self.filters):\n            self.filters.append(filter)\n\n    def removeFilter(self, filter):\n        \"\"\"\n        Remove the specified filter from this handler.\n        \"\"\"\n        if filter in self.filters:\n            self.filters.remove(filter)\n\n    def filter(self, record):\n        \"\"\"\n        Determine if a record is loggable by consulting all the filters.\n\n        The default is to allow the record to be logged; any filter can veto\n        this and the record is then dropped. Returns a zero value if a record\n        is to be dropped, else non-zero.\n\n        .. versionchanged:: 3.2\n\n           Allow filters to be just callables.\n        \"\"\"\n        rv = True\n        for f in self.filters:\n            if hasattr(f, 'filter'):\n                result = f.filter(record)\n            else:\n                result = f(record) # assume callable - will raise if not\n            if not result:\n                rv = False\n                break\n        return rv\n\n#---------------------------------------------------------------------------\n#   Handler classes and functions\n#---------------------------------------------------------------------------\n\n_handlers = weakref.WeakValueDictionary()  #map of handler names to handlers\n_handlerList = [] # added to allow handlers to be removed in reverse of order initialized\n\ndef _removeHandlerRef(wr):\n    \"\"\"\n    Remove a handler reference from the internal cleanup list.\n    \"\"\"\n    # This function can be called during module teardown, when globals are\n    # set to None. It can also be called from another thread. So we need to\n    # pre-emptively grab the necessary globals and check if they're None,\n    # to prevent race conditions and failures during interpreter shutdown.\n    acquire, release, handlers = _acquireLock, _releaseLock, _handlerList\n    if acquire and release and handlers:\n        acquire()\n        try:\n            if wr in handlers:\n                handlers.remove(wr)\n        finally:\n            release()\n\ndef _addHandlerRef(handler):\n    \"\"\"\n    Add a handler to the internal cleanup list using a weak reference.\n    \"\"\"\n    _acquireLock()\n    try:\n        _handlerList.append(weakref.ref(handler, _removeHandlerRef))\n    finally:\n        _releaseLock()\n\nclass Handler(Filterer):\n    \"\"\"\n    Handler instances dispatch logging events to specific destinations.\n\n    The base handler class. Acts as a placeholder which defines the Handler\n    interface. Handlers can optionally use Formatter instances to format\n    records as desired. By default, no formatter is specified; in this case,\n    the 'raw' message as determined by record.message is logged.\n    \"\"\"\n    def __init__(self, level=NOTSET):\n        \"\"\"\n        Initializes the instance - basically setting the formatter to None\n        and the filter list to empty.\n        \"\"\"\n        Filterer.__init__(self)\n        self._name = None\n        self.level = _checkLevel(level)\n        self.formatter = None\n        # Add the handler to the global _handlerList (for cleanup on shutdown)\n        _addHandlerRef(self)\n        self.createLock()\n\n    def get_name(self):\n        return self._name\n\n    def set_name(self, name):\n        _acquireLock()\n        try:\n            if self._name in _handlers:\n                del _handlers[self._name]\n            self._name = name\n            if name:\n                _handlers[name] = self\n        finally:\n            _releaseLock()\n\n    name = property(get_name, set_name)\n\n    def createLock(self):\n        \"\"\"\n        Acquire a thread lock for serializing access to the underlying I/O.\n        \"\"\"\n        if threading:\n            self.lock = threading.RLock()\n        else: #pragma: no cover\n            self.lock = None\n\n    def acquire(self):\n        \"\"\"\n        Acquire the I/O thread lock.\n        \"\"\"\n        if self.lock:\n            self.lock.acquire()\n\n    def release(self):\n        \"\"\"\n        Release the I/O thread lock.\n        \"\"\"\n        if self.lock:\n            self.lock.release()\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the logging level of this handler.  level must be an int or a str.\n        \"\"\"\n        self.level = _checkLevel(level)\n\n    def format(self, record):\n        \"\"\"\n        Format the specified record.\n\n        If a formatter is set, use it. Otherwise, use the default formatter\n        for the module.\n        \"\"\"\n        if self.formatter:\n            fmt = self.formatter\n        else:\n            fmt = _defaultFormatter\n        return fmt.format(record)\n\n    def emit(self, record):\n        \"\"\"\n        Do whatever it takes to actually log the specified logging record.\n\n        This version is intended to be implemented by subclasses and so\n        raises a NotImplementedError.\n        \"\"\"\n        raise NotImplementedError('emit must be implemented '\n                                  'by Handler subclasses')\n\n    def handle(self, record):\n        \"\"\"\n        Conditionally emit the specified logging record.\n\n        Emission depends on filters which may have been added to the handler.\n        Wrap the actual emission of the record with acquisition/release of\n        the I/O thread lock. Returns whether the filter passed the record for\n        emission.\n        \"\"\"\n        rv = self.filter(record)\n        if rv:\n            self.acquire()\n            try:\n                self.emit(record)\n            finally:\n                self.release()\n        return rv\n\n    def setFormatter(self, fmt):\n        \"\"\"\n        Set the formatter for this handler.\n        \"\"\"\n        self.formatter = fmt\n\n    def flush(self):\n        \"\"\"\n        Ensure all logging output has been flushed.\n\n        This version does nothing and is intended to be implemented by\n        subclasses.\n        \"\"\"\n        pass\n\n    def close(self):\n        \"\"\"\n        Tidy up any resources used by the handler.\n\n        This version removes the handler from an internal map of handlers,\n        _handlers, which is used for handler lookup by name. Subclasses\n        should ensure that this gets called from overridden close()\n        methods.\n        \"\"\"\n        #get the module data lock, as we're updating a shared structure.\n        _acquireLock()\n        try:    #unlikely to raise an exception, but you never know...\n            if self._name and self._name in _handlers:\n                del _handlers[self._name]\n        finally:\n            _releaseLock()\n\n    def handleError(self, record):\n        \"\"\"\n        Handle errors which occur during an emit() call.\n\n        This method should be called from handlers when an exception is\n        encountered during an emit() call. If raiseExceptions is false,\n        exceptions get silently ignored. This is what is mostly wanted\n        for a logging system - most users will not care about errors in\n        the logging system, they are more interested in application errors.\n        You could, however, replace this with a custom handler if you wish.\n        The record which was being processed is passed in to this method.\n        \"\"\"\n        if raiseExceptions and sys.stderr:  # see issue 13807\n            t, v, tb = sys.exc_info()\n            try:\n                sys.stderr.write('--- Logging error ---\\n')\n                traceback.print_exception(t, v, tb, None, sys.stderr)\n                sys.stderr.write('Call stack:\\n')\n                # Walk the stack frame up until we're out of logging,\n                # so as to print the calling context.\n                frame = tb.tb_frame\n                while (frame and os.path.dirname(frame.f_code.co_filename) ==\n                       __path__[0]):\n                    frame = frame.f_back\n                if frame:\n                    traceback.print_stack(frame, file=sys.stderr)\n                else:\n                    # couldn't find the right stack frame, for some reason\n                    sys.stderr.write('Logged from file %s, line %s\\n' % (\n                                     record.filename, record.lineno))\n                # Issue 18671: output logging message and arguments\n                try:\n                    sys.stderr.write('Message: %r\\n'\n                                     'Arguments: %s\\n' % (record.msg,\n                                                          record.args))\n                except Exception:\n                    sys.stderr.write('Unable to print the message and arguments'\n                                     ' - possible formatting error.\\nUse the'\n                                     ' traceback above to help find the error.\\n'\n                                    )\n            except OSError: #pragma: no cover\n                pass    # see issue 5971\n            finally:\n                del t, v, tb\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        return '<%s (%s)>' % (self.__class__.__name__, level)\n\nclass StreamHandler(Handler):\n    \"\"\"\n    A handler class which writes logging records, appropriately formatted,\n    to a stream. Note that this class does not close the stream, as\n    sys.stdout or sys.stderr may be used.\n    \"\"\"\n\n    terminator = '\\n'\n\n    def __init__(self, stream=None):\n        \"\"\"\n        Initialize the handler.\n\n        If stream is not specified, sys.stderr is used.\n        \"\"\"\n        Handler.__init__(self)\n        if stream is None:\n            stream = sys.stderr\n        self.stream = stream\n\n    def flush(self):\n        \"\"\"\n        Flushes the stream.\n        \"\"\"\n        self.acquire()\n        try:\n            if self.stream and hasattr(self.stream, \"flush\"):\n                self.stream.flush()\n        finally:\n            self.release()\n\n    def emit(self, record):\n        \"\"\"\n        Emit a record.\n\n        If a formatter is specified, it is used to format the record.\n        The record is then written to the stream with a trailing newline.  If\n        exception information is present, it is formatted using\n        traceback.print_exception and appended to the stream.  If the stream\n        has an 'encoding' attribute, it is used to determine how to do the\n        output to the stream.\n        \"\"\"\n        try:\n            msg = self.format(record)\n            stream = self.stream\n            stream.write(msg)\n            stream.write(self.terminator)\n            self.flush()\n        except Exception:\n            self.handleError(record)\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        name = getattr(self.stream, 'name', '')\n        if name:\n            name += ' '\n        return '<%s %s(%s)>' % (self.__class__.__name__, name, level)\n\n\nclass FileHandler(StreamHandler):\n    \"\"\"\n    A handler class which writes formatted logging records to disk files.\n    \"\"\"\n    def __init__(self, filename, mode='a', encoding=None, delay=False):\n        \"\"\"\n        Open the specified file and use it as the stream for logging.\n        \"\"\"\n        # Issue #27493: add support for Path objects to be passed in\n        filename = os.fspath(filename)\n        #keep the absolute path, otherwise derived classes which use this\n        #may come a cropper when the current directory changes\n        self.baseFilename = os.path.abspath(filename)\n        self.mode = mode\n        self.encoding = encoding\n        self.delay = delay\n        if delay:\n            #We don't open the stream, but we still need to call the\n            #Handler constructor to set level, formatter, lock etc.\n            Handler.__init__(self)\n            self.stream = None\n        else:\n            StreamHandler.__init__(self, self._open())\n\n    def close(self):\n        \"\"\"\n        Closes the stream.\n        \"\"\"\n        self.acquire()\n        try:\n            try:\n                if self.stream:\n                    try:\n                        self.flush()\n                    finally:\n                        stream = self.stream\n                        self.stream = None\n                        if hasattr(stream, \"close\"):\n                            stream.close()\n            finally:\n                # Issue #19523: call unconditionally to\n                # prevent a handler leak when delay is set\n                StreamHandler.close(self)\n        finally:\n            self.release()\n\n    def _open(self):\n        \"\"\"\n        Open the current base file with the (original) mode and encoding.\n        Return the resulting stream.\n        \"\"\"\n        return open(self.baseFilename, self.mode, encoding=self.encoding)\n\n    def emit(self, record):\n        \"\"\"\n        Emit a record.\n\n        If the stream was not opened because 'delay' was specified in the\n        constructor, open it before calling the superclass's emit.\n        \"\"\"\n        if self.stream is None:\n            self.stream = self._open()\n        StreamHandler.emit(self, record)\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        return '<%s %s (%s)>' % (self.__class__.__name__, self.baseFilename, level)\n\n\nclass _StderrHandler(StreamHandler):\n    \"\"\"\n    This class is like a StreamHandler using sys.stderr, but always uses\n    whatever sys.stderr is currently set to rather than the value of\n    sys.stderr at handler construction time.\n    \"\"\"\n    def __init__(self, level=NOTSET):\n        \"\"\"\n        Initialize the handler.\n        \"\"\"\n        Handler.__init__(self, level)\n\n    @property\n    def stream(self):\n        return sys.stderr\n\n\n_defaultLastResort = _StderrHandler(WARNING)\nlastResort = _defaultLastResort\n\n#---------------------------------------------------------------------------\n#   Manager classes and functions\n#---------------------------------------------------------------------------\n\nclass PlaceHolder(object):\n    \"\"\"\n    PlaceHolder instances are used in the Manager logger hierarchy to take\n    the place of nodes for which no loggers have been defined. This class is\n    intended for internal use only and not as part of the public API.\n    \"\"\"\n    def __init__(self, alogger):\n        \"\"\"\n        Initialize with the specified logger being a child of this placeholder.\n        \"\"\"\n        self.loggerMap = { alogger : None }\n\n    def append(self, alogger):\n        \"\"\"\n        Add the specified logger as a child of this placeholder.\n        \"\"\"\n        if alogger not in self.loggerMap:\n            self.loggerMap[alogger] = None\n\n#\n#   Determine which class to use when instantiating loggers.\n#\n\ndef setLoggerClass(klass):\n    \"\"\"\n    Set the class to be used when instantiating a logger. The class should\n    define __init__() such that only a name argument is required, and the\n    __init__() should call Logger.__init__()\n    \"\"\"\n    if klass != Logger:\n        if not issubclass(klass, Logger):\n            raise TypeError(\"logger not derived from logging.Logger: \"\n                            + klass.__name__)\n    global _loggerClass\n    _loggerClass = klass\n\ndef getLoggerClass():\n    \"\"\"\n    Return the class to be used when instantiating a logger.\n    \"\"\"\n    return _loggerClass\n\nclass Manager(object):\n    \"\"\"\n    There is [under normal circumstances] just one Manager instance, which\n    holds the hierarchy of loggers.\n    \"\"\"\n    def __init__(self, rootnode):\n        \"\"\"\n        Initialize the manager with the root node of the logger hierarchy.\n        \"\"\"\n        self.root = rootnode\n        self.disable = 0\n        self.emittedNoHandlerWarning = False\n        self.loggerDict = {}\n        self.loggerClass = None\n        self.logRecordFactory = None\n\n    def getLogger(self, name):\n        \"\"\"\n        Get a logger with the specified name (channel name), creating it\n        if it doesn't yet exist. This name is a dot-separated hierarchical\n        name, such as \"a\", \"a.b\", \"a.b.c\" or similar.\n\n        If a PlaceHolder existed for the specified name [i.e. the logger\n        didn't exist but a child of it did], replace it with the created\n        logger and fix up the parent/child references which pointed to the\n        placeholder to now point to the logger.\n        \"\"\"\n        rv = None\n        if not isinstance(name, str):\n            raise TypeError('A logger name must be a string')\n        _acquireLock()\n        try:\n            if name in self.loggerDict:\n                rv = self.loggerDict[name]\n                if isinstance(rv, PlaceHolder):\n                    ph = rv\n                    rv = (self.loggerClass or _loggerClass)(name)\n                    rv.manager = self\n                    self.loggerDict[name] = rv\n                    self._fixupChildren(ph, rv)\n                    self._fixupParents(rv)\n            else:\n                rv = (self.loggerClass or _loggerClass)(name)\n                rv.manager = self\n                self.loggerDict[name] = rv\n                self._fixupParents(rv)\n        finally:\n            _releaseLock()\n        return rv\n\n    def setLoggerClass(self, klass):\n        \"\"\"\n        Set the class to be used when instantiating a logger with this Manager.\n        \"\"\"\n        if klass != Logger:\n            if not issubclass(klass, Logger):\n                raise TypeError(\"logger not derived from logging.Logger: \"\n                                + klass.__name__)\n        self.loggerClass = klass\n\n    def setLogRecordFactory(self, factory):\n        \"\"\"\n        Set the factory to be used when instantiating a log record with this\n        Manager.\n        \"\"\"\n        self.logRecordFactory = factory\n\n    def _fixupParents(self, alogger):\n        \"\"\"\n        Ensure that there are either loggers or placeholders all the way\n        from the specified logger to the root of the logger hierarchy.\n        \"\"\"\n        name = alogger.name\n        i = name.rfind(\".\")\n        rv = None\n        while (i > 0) and not rv:\n            substr = name[:i]\n            if substr not in self.loggerDict:\n                self.loggerDict[substr] = PlaceHolder(alogger)\n            else:\n                obj = self.loggerDict[substr]\n                if isinstance(obj, Logger):\n                    rv = obj\n                else:\n                    assert isinstance(obj, PlaceHolder)\n                    obj.append(alogger)\n            i = name.rfind(\".\", 0, i - 1)\n        if not rv:\n            rv = self.root\n        alogger.parent = rv\n\n    def _fixupChildren(self, ph, alogger):\n        \"\"\"\n        Ensure that children of the placeholder ph are connected to the\n        specified logger.\n        \"\"\"\n        name = alogger.name\n        namelen = len(name)\n        for c in ph.loggerMap.keys():\n            #The if means ... if not c.parent.name.startswith(nm)\n            if c.parent.name[:namelen] != name:\n                alogger.parent = c.parent\n                c.parent = alogger\n\n#---------------------------------------------------------------------------\n#   Logger classes and functions\n#---------------------------------------------------------------------------\n\nclass Logger(Filterer):\n    \"\"\"\n    Instances of the Logger class represent a single logging channel. A\n    \"logging channel\" indicates an area of an application. Exactly how an\n    \"area\" is defined is up to the application developer. Since an\n    application can have any number of areas, logging channels are identified\n    by a unique string. Application areas can be nested (e.g. an area\n    of \"input processing\" might include sub-areas \"read CSV files\", \"read\n    XLS files\" and \"read Gnumeric files\"). To cater for this natural nesting,\n    channel names are organized into a namespace hierarchy where levels are\n    separated by periods, much like the Java or Python package namespace. So\n    in the instance given above, channel names might be \"input\" for the upper\n    level, and \"input.csv\", \"input.xls\" and \"input.gnu\" for the sub-levels.\n    There is no arbitrary limit to the depth of nesting.\n    \"\"\"\n    def __init__(self, name, level=NOTSET):\n        \"\"\"\n        Initialize the logger with a name and an optional level.\n        \"\"\"\n        Filterer.__init__(self)\n        self.name = name\n        self.level = _checkLevel(level)\n        self.parent = None\n        self.propagate = True\n        self.handlers = []\n        self.disabled = False\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the logging level of this logger.  level must be an int or a str.\n        \"\"\"\n        self.level = _checkLevel(level)\n\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'DEBUG'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(DEBUG):\n            self._log(DEBUG, msg, args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'INFO'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(INFO):\n            self._log(INFO, msg, args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'WARNING'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(WARNING):\n            self._log(WARNING, msg, args, **kwargs)\n\n    def warn(self, msg, *args, **kwargs):\n        warnings.warn(\"The 'warn' method is deprecated, \"\n            \"use 'warning' instead\", DeprecationWarning, 2)\n        self.warning(msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'ERROR'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(ERROR):\n            self._log(ERROR, msg, args, **kwargs)\n\n    def exception(self, msg, *args, exc_info=True, **kwargs):\n        \"\"\"\n        Convenience method for logging an ERROR with exception information.\n        \"\"\"\n        self.error(msg, *args, exc_info=exc_info, **kwargs)\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'CRITICAL'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.critical(\"Houston, we have a %s\", \"major disaster\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(CRITICAL):\n            self._log(CRITICAL, msg, args, **kwargs)\n\n    fatal = critical\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with the integer severity 'level'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.log(level, \"We have a %s\", \"mysterious problem\", exc_info=1)\n        \"\"\"\n        if not isinstance(level, int):\n            if raiseExceptions:\n                raise TypeError(\"level must be an integer\")\n            else:\n                return\n        if self.isEnabledFor(level):\n            self._log(level, msg, args, **kwargs)\n\n    def findCaller(self, stack_info=False):\n        \"\"\"\n        Find the stack frame of the caller so that we can note the source\n        file name, line number and function name.\n        \"\"\"\n        f = currentframe()\n        #On some versions of IronPython, currentframe() returns None if\n        #IronPython isn't run with -X:Frames.\n        if f is not None:\n            f = f.f_back\n        rv = \"(unknown file)\", 0, \"(unknown function)\", None\n        while hasattr(f, \"f_code\"):\n            co = f.f_code\n            filename = os.path.normcase(co.co_filename)\n            if filename == _srcfile:\n                f = f.f_back\n                continue\n            sinfo = None\n            if stack_info:\n                sio = io.StringIO()\n                sio.write('Stack (most recent call last):\\n')\n                traceback.print_stack(f, file=sio)\n                sinfo = sio.getvalue()\n                if sinfo[-1] == '\\n':\n                    sinfo = sinfo[:-1]\n                sio.close()\n            rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)\n            break\n        return rv\n\n    def makeRecord(self, name, level, fn, lno, msg, args, exc_info,\n                   func=None, extra=None, sinfo=None):\n        \"\"\"\n        A factory method which can be overridden in subclasses to create\n        specialized LogRecords.\n        \"\"\"\n        rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,\n                             sinfo)\n        if extra is not None:\n            for key in extra:\n                if (key in [\"message\", \"asctime\"]) or (key in rv.__dict__):\n                    raise KeyError(\"Attempt to overwrite %r in LogRecord\" % key)\n                rv.__dict__[key] = extra[key]\n        return rv\n\n    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False):\n        \"\"\"\n        Low-level logging routine which creates a LogRecord and then calls\n        all the handlers of this logger to handle the record.\n        \"\"\"\n        sinfo = None\n        if _srcfile:\n            #IronPython doesn't track Python frames, so findCaller raises an\n            #exception on some versions of IronPython. We trap it here so that\n            #IronPython can use logging.\n            try:\n                fn, lno, func, sinfo = self.findCaller(stack_info)\n            except ValueError: # pragma: no cover\n                fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n        else: # pragma: no cover\n            fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n        if exc_info:\n            if isinstance(exc_info, BaseException):\n                exc_info = (type(exc_info), exc_info, exc_info.__traceback__)\n            elif not isinstance(exc_info, tuple):\n                exc_info = sys.exc_info()\n        record = self.makeRecord(self.name, level, fn, lno, msg, args,\n                                 exc_info, func, extra, sinfo)\n        self.handle(record)\n\n    def handle(self, record):\n        \"\"\"\n        Call the handlers for the specified record.\n\n        This method is used for unpickled records received from a socket, as\n        well as those created locally. Logger-level filtering is applied.\n        \"\"\"\n        if (not self.disabled) and self.filter(record):\n            self.callHandlers(record)\n\n    def addHandler(self, hdlr):\n        \"\"\"\n        Add the specified handler to this logger.\n        \"\"\"\n        _acquireLock()\n        try:\n            if not (hdlr in self.handlers):\n                self.handlers.append(hdlr)\n        finally:\n            _releaseLock()\n\n    def removeHandler(self, hdlr):\n        \"\"\"\n        Remove the specified handler from this logger.\n        \"\"\"\n        _acquireLock()\n        try:\n            if hdlr in self.handlers:\n                self.handlers.remove(hdlr)\n        finally:\n            _releaseLock()\n\n    def hasHandlers(self):\n        \"\"\"\n        See if this logger has any handlers configured.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. Return True if a handler was found, else False.\n        Stop searching up the hierarchy whenever a logger with the \"propagate\"\n        attribute set to zero is found - that will be the last logger which\n        is checked for the existence of handlers.\n        \"\"\"\n        c = self\n        rv = False\n        while c:\n            if c.handlers:\n                rv = True\n                break\n            if not c.propagate:\n                break\n            else:\n                c = c.parent\n        return rv\n\n    def callHandlers(self, record):\n        \"\"\"\n        Pass a record to all relevant handlers.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. If no handler was found, output a one-off error\n        message to sys.stderr. Stop searching up the hierarchy whenever a\n        logger with the \"propagate\" attribute set to zero is found - that\n        will be the last logger whose handlers are called.\n        \"\"\"\n        c = self\n        found = 0\n        while c:\n            for hdlr in c.handlers:\n                found = found + 1\n                if record.levelno >= hdlr.level:\n                    hdlr.handle(record)\n            if not c.propagate:\n                c = None    #break out\n            else:\n                c = c.parent\n        if (found == 0):\n            if lastResort:\n                if record.levelno >= lastResort.level:\n                    lastResort.handle(record)\n            elif raiseExceptions and not self.manager.emittedNoHandlerWarning:\n                sys.stderr.write(\"No handlers could be found for logger\"\n                                 \" \\\"%s\\\"\\n\" % self.name)\n                self.manager.emittedNoHandlerWarning = True\n\n    def getEffectiveLevel(self):\n        \"\"\"\n        Get the effective level for this logger.\n\n        Loop through this logger and its parents in the logger hierarchy,\n        looking for a non-zero logging level. Return the first one found.\n        \"\"\"\n        logger = self\n        while logger:\n            if logger.level:\n                return logger.level\n            logger = logger.parent\n        return NOTSET\n\n    def isEnabledFor(self, level):\n        \"\"\"\n        Is this logger enabled for level 'level'?\n        \"\"\"\n        if self.manager.disable >= level:\n            return False\n        return level >= self.getEffectiveLevel()\n\n    def getChild(self, suffix):\n        \"\"\"\n        Get a logger which is a descendant to this one.\n\n        This is a convenience method, such that\n\n        logging.getLogger('abc').getChild('def.ghi')\n\n        is the same as\n\n        logging.getLogger('abc.def.ghi')\n\n        It's useful, for example, when the parent logger is named using\n        __name__ rather than a literal string.\n        \"\"\"\n        if self.root is not self:\n            suffix = '.'.join((self.name, suffix))\n        return self.manager.getLogger(suffix)\n\n    def __repr__(self):\n        level = getLevelName(self.getEffectiveLevel())\n        return '<%s %s (%s)>' % (self.__class__.__name__, self.name, level)\n\n\nclass RootLogger(Logger):\n    \"\"\"\n    A root logger is not that different to any other logger, except that\n    it must have a logging level and there is only one instance of it in\n    the hierarchy.\n    \"\"\"\n    def __init__(self, level):\n        \"\"\"\n        Initialize the logger with the name \"root\".\n        \"\"\"\n        Logger.__init__(self, \"root\", level)\n\n_loggerClass = Logger\n\nclass LoggerAdapter(object):\n    \"\"\"\n    An adapter for loggers which makes it easier to specify contextual\n    information in logging output.\n    \"\"\"\n\n    def __init__(self, logger, extra):\n        \"\"\"\n        Initialize the adapter with a logger and a dict-like object which\n        provides contextual information. This constructor signature allows\n        easy stacking of LoggerAdapters, if so desired.\n\n        You can effectively pass keyword arguments as shown in the\n        following example:\n\n        adapter = LoggerAdapter(someLogger, dict(p1=v1, p2=\"v2\"))\n        \"\"\"\n        self.logger = logger\n        self.extra = extra\n\n    def process(self, msg, kwargs):\n        \"\"\"\n        Process the logging message and keyword arguments passed in to\n        a logging call to insert contextual information. You can either\n        manipulate the message itself, the keyword args or both. Return\n        the message and kwargs modified (or not) to suit your needs.\n\n        Normally, you'll only need to override this one method in a\n        LoggerAdapter subclass for your specific needs.\n        \"\"\"\n        kwargs[\"extra\"] = self.extra\n        return msg, kwargs\n\n    #\n    # Boilerplate convenience methods\n    #\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a debug call to the underlying logger.\n        \"\"\"\n        self.log(DEBUG, msg, *args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate an info call to the underlying logger.\n        \"\"\"\n        self.log(INFO, msg, *args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a warning call to the underlying logger.\n        \"\"\"\n        self.log(WARNING, msg, *args, **kwargs)\n\n    def warn(self, msg, *args, **kwargs):\n        warnings.warn(\"The 'warn' method is deprecated, \"\n            \"use 'warning' instead\", DeprecationWarning, 2)\n        self.warning(msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate an error call to the underlying logger.\n        \"\"\"\n        self.log(ERROR, msg, *args, **kwargs)\n\n    def exception(self, msg, *args, exc_info=True, **kwargs):\n        \"\"\"\n        Delegate an exception call to the underlying logger.\n        \"\"\"\n        self.log(ERROR, msg, *args, exc_info=exc_info, **kwargs)\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a critical call to the underlying logger.\n        \"\"\"\n        self.log(CRITICAL, msg, *args, **kwargs)\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a log call to the underlying logger, after adding\n        contextual information from this adapter instance.\n        \"\"\"\n        if self.isEnabledFor(level):\n            msg, kwargs = self.process(msg, kwargs)\n            self.logger.log(level, msg, *args, **kwargs)\n\n    def isEnabledFor(self, level):\n        \"\"\"\n        Is this logger enabled for level 'level'?\n        \"\"\"\n        if self.logger.manager.disable >= level:\n            return False\n        return level >= self.getEffectiveLevel()\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the specified level on the underlying logger.\n        \"\"\"\n        self.logger.setLevel(level)\n\n    def getEffectiveLevel(self):\n        \"\"\"\n        Get the effective level for the underlying logger.\n        \"\"\"\n        return self.logger.getEffectiveLevel()\n\n    def hasHandlers(self):\n        \"\"\"\n        See if the underlying logger has any handlers.\n        \"\"\"\n        return self.logger.hasHandlers()\n\n    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False):\n        \"\"\"\n        Low-level log implementation, proxied to allow nested logger adapters.\n        \"\"\"\n        return self.logger._log(\n            level,\n            msg,\n            args,\n            exc_info=exc_info,\n            extra=extra,\n            stack_info=stack_info,\n        )\n\n    @property\n    def manager(self):\n        return self.logger.manager\n\n    @manager.setter\n    def manager(self, value):\n        self.logger.manager = value\n\n    @property\n    def name(self):\n        return self.logger.name\n\n    def __repr__(self):\n        logger = self.logger\n        level = getLevelName(logger.getEffectiveLevel())\n        return '<%s %s (%s)>' % (self.__class__.__name__, logger.name, level)\n\nroot = RootLogger(WARNING)\nLogger.root = root\nLogger.manager = Manager(Logger.root)\n\n#---------------------------------------------------------------------------\n# Configuration classes and functions\n#---------------------------------------------------------------------------\n\ndef basicConfig(**kwargs):\n    \"\"\"\n    Do basic configuration for the logging system.\n\n    This function does nothing if the root logger already has handlers\n    configured. It is a convenience method intended for use by simple scripts\n    to do one-shot configuration of the logging package.\n\n    The default behaviour is to create a StreamHandler which writes to\n    sys.stderr, set a formatter using the BASIC_FORMAT format string, and\n    add the handler to the root logger.\n\n    A number of optional keyword arguments may be specified, which can alter\n    the default behaviour.\n\n    filename  Specifies that a FileHandler be created, using the specified\n              filename, rather than a StreamHandler.\n    filemode  Specifies the mode to open the file, if filename is specified\n              (if filemode is unspecified, it defaults to 'a').\n    format    Use the specified format string for the handler.\n    datefmt   Use the specified date/time format.\n    style     If a format string is specified, use this to specify the\n              type of format string (possible values '%', '{', '$', for\n              %-formatting, :meth:`str.format` and :class:`string.Template`\n              - defaults to '%').\n    level     Set the root logger level to the specified level.\n    stream    Use the specified stream to initialize the StreamHandler. Note\n              that this argument is incompatible with 'filename' - if both\n              are present, 'stream' is ignored.\n    handlers  If specified, this should be an iterable of already created\n              handlers, which will be added to the root handler. Any handler\n              in the list which does not have a formatter assigned will be\n              assigned the formatter created in this function.\n\n    Note that you could specify a stream created using open(filename, mode)\n    rather than passing the filename and mode in. However, it should be\n    remembered that StreamHandler does not close its stream (since it may be\n    using sys.stdout or sys.stderr), whereas FileHandler closes its stream\n    when the handler is closed.\n\n    .. versionchanged:: 3.2\n       Added the ``style`` parameter.\n\n    .. versionchanged:: 3.3\n       Added the ``handlers`` parameter. A ``ValueError`` is now thrown for\n       incompatible arguments (e.g. ``handlers`` specified together with\n       ``filename``/``filemode``, or ``filename``/``filemode`` specified\n       together with ``stream``, or ``handlers`` specified together with\n       ``stream``.\n    \"\"\"\n    # Add thread safety in case someone mistakenly calls\n    # basicConfig() from multiple threads\n    _acquireLock()\n    try:\n        if len(root.handlers) == 0:\n            handlers = kwargs.pop(\"handlers\", None)\n            if handlers is None:\n                if \"stream\" in kwargs and \"filename\" in kwargs:\n                    raise ValueError(\"'stream' and 'filename' should not be \"\n                                     \"specified together\")\n            else:\n                if \"stream\" in kwargs or \"filename\" in kwargs:\n                    raise ValueError(\"'stream' or 'filename' should not be \"\n                                     \"specified together with 'handlers'\")\n            if handlers is None:\n                filename = kwargs.pop(\"filename\", None)\n                mode = kwargs.pop(\"filemode\", 'a')\n                if filename:\n                    h = FileHandler(filename, mode)\n                else:\n                    stream = kwargs.pop(\"stream\", None)\n                    h = StreamHandler(stream)\n                handlers = [h]\n            dfs = kwargs.pop(\"datefmt\", None)\n            style = kwargs.pop(\"style\", '%')\n            if style not in _STYLES:\n                raise ValueError('Style must be one of: %s' % ','.join(\n                                 _STYLES.keys()))\n            fs = kwargs.pop(\"format\", _STYLES[style][1])\n            fmt = Formatter(fs, dfs, style)\n            for h in handlers:\n                if h.formatter is None:\n                    h.setFormatter(fmt)\n                root.addHandler(h)\n            level = kwargs.pop(\"level\", None)\n            if level is not None:\n                root.setLevel(level)\n            if kwargs:\n                keys = ', '.join(kwargs.keys())\n                raise ValueError('Unrecognised argument(s): %s' % keys)\n    finally:\n        _releaseLock()\n\n#---------------------------------------------------------------------------\n# Utility functions at module level.\n# Basically delegate everything to the root logger.\n#---------------------------------------------------------------------------\n\ndef getLogger(name=None):\n    \"\"\"\n    Return a logger with the specified name, creating it if necessary.\n\n    If no name is specified, return the root logger.\n    \"\"\"\n    if name:\n        return Logger.manager.getLogger(name)\n    else:\n        return root\n\ndef critical(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'CRITICAL' on the root logger. If the logger\n    has no handlers, call basicConfig() to add a console handler with a\n    pre-defined format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.critical(msg, *args, **kwargs)\n\nfatal = critical\n\ndef error(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'ERROR' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.error(msg, *args, **kwargs)\n\ndef exception(msg, *args, exc_info=True, **kwargs):\n    \"\"\"\n    Log a message with severity 'ERROR' on the root logger, with exception\n    information. If the logger has no handlers, basicConfig() is called to add\n    a console handler with a pre-defined format.\n    \"\"\"\n    error(msg, *args, exc_info=exc_info, **kwargs)\n\ndef warning(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'WARNING' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.warning(msg, *args, **kwargs)\n\ndef warn(msg, *args, **kwargs):\n    warnings.warn(\"The 'warn' function is deprecated, \"\n        \"use 'warning' instead\", DeprecationWarning, 2)\n    warning(msg, *args, **kwargs)\n\ndef info(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'INFO' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.info(msg, *args, **kwargs)\n\ndef debug(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'DEBUG' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.debug(msg, *args, **kwargs)\n\ndef log(level, msg, *args, **kwargs):\n    \"\"\"\n    Log 'msg % args' with the integer severity 'level' on the root logger. If\n    the logger has no handlers, call basicConfig() to add a console handler\n    with a pre-defined format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.log(level, msg, *args, **kwargs)\n\ndef disable(level):\n    \"\"\"\n    Disable all logging calls of severity 'level' and below.\n    \"\"\"\n    root.manager.disable = level\n\ndef shutdown(handlerList=_handlerList):\n    \"\"\"\n    Perform any cleanup actions in the logging system (e.g. flushing\n    buffers).\n\n    Should be called at application exit.\n    \"\"\"\n    for wr in reversed(handlerList[:]):\n        #errors might occur, for example, if files are locked\n        #we just ignore them if raiseExceptions is not set\n        try:\n            h = wr()\n            if h:\n                try:\n                    h.acquire()\n                    h.flush()\n                    h.close()\n                except (OSError, ValueError):\n                    # Ignore errors which might be caused\n                    # because handlers have been closed but\n                    # references to them are still around at\n                    # application exit.\n                    pass\n                finally:\n                    h.release()\n        except: # ignore everything, as we're shutting down\n            if raiseExceptions:\n                raise\n            #else, swallow\n\n#Let's try and shutdown automatically on application exit...\nimport atexit\natexit.register(shutdown)\n\n# Null handler\n\nclass NullHandler(Handler):\n    \"\"\"\n    This handler does nothing. It's intended to be used to avoid the\n    \"No handlers could be found for logger XXX\" one-off warning. This is\n    important for library code, which may contain code to log events. If a user\n    of the library does not configure logging, the one-off warning might be\n    produced; to avoid this, the library developer simply needs to instantiate\n    a NullHandler and add it to the top-level logger of the library module or\n    package.\n    \"\"\"\n    def handle(self, record):\n        \"\"\"Stub.\"\"\"\n\n    def emit(self, record):\n        \"\"\"Stub.\"\"\"\n\n    def createLock(self):\n        self.lock = None\n\n# Warnings integration\n\n_warnings_showwarning = None\n\ndef _showwarning(message, category, filename, lineno, file=None, line=None):\n    \"\"\"\n    Implementation of showwarnings which redirects to logging, which will first\n    check to see if the file parameter is None. If a file is specified, it will\n    delegate to the original warnings implementation of showwarning. Otherwise,\n    it will call warnings.formatwarning and will log the resulting string to a\n    warnings logger named \"py.warnings\" with level logging.WARNING.\n    \"\"\"\n    if file is not None:\n        if _warnings_showwarning is not None:\n            _warnings_showwarning(message, category, filename, lineno, file, line)\n    else:\n        s = warnings.formatwarning(message, category, filename, lineno, line)\n        logger = getLogger(\"py.warnings\")\n        if not logger.handlers:\n            logger.addHandler(NullHandler())\n        logger.warning(\"%s\", s)\n\ndef captureWarnings(capture):\n    \"\"\"\n    If capture is true, redirect all warnings to the logging package.\n    If capture is False, ensure that warnings are not redirected to logging\n    but to their original destinations.\n    \"\"\"\n    global _warnings_showwarning\n    if capture:\n        if _warnings_showwarning is None:\n            _warnings_showwarning = warnings.showwarning\n            warnings.showwarning = _showwarning\n    else:\n        if _warnings_showwarning is not None:\n            warnings.showwarning = _warnings_showwarning\n            _warnings_showwarning = None\n",2021],"d:\\coding\\python3.6\\lib\\ntpath.py":["# Module 'ntpath' -- common operations on WinNT/Win95 pathnames\n\"\"\"Common pathname manipulations, WindowsNT/95 version.\n\nInstead of importing this module directly, import os and refer to this\nmodule as os.path.\n\"\"\"\n\n# strings representing various path-related bits and pieces\n# These are primarily for export; internally, they are hardcoded.\n# Should be set before imports for resolving cyclic dependency.\ncurdir = '.'\npardir = '..'\nextsep = '.'\nsep = '\\\\'\npathsep = ';'\naltsep = '/'\ndefpath = '.;C:\\\\bin'\ndevnull = 'nul'\n\nimport os\nimport sys\nimport stat\nimport genericpath\nfrom genericpath import *\n\n__all__ = [\"normcase\",\"isabs\",\"join\",\"splitdrive\",\"split\",\"splitext\",\n           \"basename\",\"dirname\",\"commonprefix\",\"getsize\",\"getmtime\",\n           \"getatime\",\"getctime\", \"islink\",\"exists\",\"lexists\",\"isdir\",\"isfile\",\n           \"ismount\", \"expanduser\",\"expandvars\",\"normpath\",\"abspath\",\n           \"splitunc\",\"curdir\",\"pardir\",\"sep\",\"pathsep\",\"defpath\",\"altsep\",\n           \"extsep\",\"devnull\",\"realpath\",\"supports_unicode_filenames\",\"relpath\",\n           \"samefile\", \"sameopenfile\", \"samestat\", \"commonpath\"]\n\ndef _get_bothseps(path):\n    if isinstance(path, bytes):\n        return b'\\\\/'\n    else:\n        return '\\\\/'\n\n# Normalize the case of a pathname and map slashes to backslashes.\n# Other normalizations (such as optimizing '../' away) are not done\n# (this is done by normpath).\n\ndef normcase(s):\n    \"\"\"Normalize case of pathname.\n\n    Makes all characters lowercase and all slashes into backslashes.\"\"\"\n    s = os.fspath(s)\n    try:\n        if isinstance(s, bytes):\n            return s.replace(b'/', b'\\\\').lower()\n        else:\n            return s.replace('/', '\\\\').lower()\n    except (TypeError, AttributeError):\n        if not isinstance(s, (bytes, str)):\n            raise TypeError(\"normcase() argument must be str or bytes, \"\n                            \"not %r\" % s.__class__.__name__) from None\n        raise\n\n\n# Return whether a path is absolute.\n# Trivial in Posix, harder on Windows.\n# For Windows it is absolute if it starts with a slash or backslash (current\n# volume), or if a pathname after the volume-letter-and-colon or UNC-resource\n# starts with a slash or backslash.\n\ndef isabs(s):\n    \"\"\"Test whether a path is absolute\"\"\"\n    s = os.fspath(s)\n    s = splitdrive(s)[1]\n    return len(s) > 0 and s[0] in _get_bothseps(s)\n\n\n# Join two (or more) paths.\ndef join(path, *paths):\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        sep = b'\\\\'\n        seps = b'\\\\/'\n        colon = b':'\n    else:\n        sep = '\\\\'\n        seps = '\\\\/'\n        colon = ':'\n    try:\n        if not paths:\n            path[:0] + sep  #23780: Ensure compatible data type even if p is null.\n        result_drive, result_path = splitdrive(path)\n        for p in map(os.fspath, paths):\n            p_drive, p_path = splitdrive(p)\n            if p_path and p_path[0] in seps:\n                # Second path is absolute\n                if p_drive or not result_drive:\n                    result_drive = p_drive\n                result_path = p_path\n                continue\n            elif p_drive and p_drive != result_drive:\n                if p_drive.lower() != result_drive.lower():\n                    # Different drives => ignore the first path entirely\n                    result_drive = p_drive\n                    result_path = p_path\n                    continue\n                # Same drive in different case\n                result_drive = p_drive\n            # Second path is relative to the first\n            if result_path and result_path[-1] not in seps:\n                result_path = result_path + sep\n            result_path = result_path + p_path\n        ## add separator between UNC and non-absolute path\n        if (result_path and result_path[0] not in seps and\n            result_drive and result_drive[-1:] != colon):\n            return result_drive + sep + result_path\n        return result_drive + result_path\n    except (TypeError, AttributeError, BytesWarning):\n        genericpath._check_arg_types('join', path, *paths)\n        raise\n\n\n# Split a path in a drive specification (a drive letter followed by a\n# colon) and the path specification.\n# It is always true that drivespec + pathspec == p\ndef splitdrive(p):\n    \"\"\"Split a pathname into drive/UNC sharepoint and relative path specifiers.\n    Returns a 2-tuple (drive_or_unc, path); either part may be empty.\n\n    If you assign\n        result = splitdrive(p)\n    It is always true that:\n        result[0] + result[1] == p\n\n    If the path contained a drive letter, drive_or_unc will contain everything\n    up to and including the colon.  e.g. splitdrive(\"c:/dir\") returns (\"c:\", \"/dir\")\n\n    If the path contained a UNC path, the drive_or_unc will contain the host name\n    and share up to but not including the fourth directory separator character.\n    e.g. splitdrive(\"//host/computer/dir\") returns (\"//host/computer\", \"/dir\")\n\n    Paths cannot contain both a drive letter and a UNC path.\n\n    \"\"\"\n    p = os.fspath(p)\n    if len(p) >= 2:\n        if isinstance(p, bytes):\n            sep = b'\\\\'\n            altsep = b'/'\n            colon = b':'\n        else:\n            sep = '\\\\'\n            altsep = '/'\n            colon = ':'\n        normp = p.replace(altsep, sep)\n        if (normp[0:2] == sep*2) and (normp[2:3] != sep):\n            # is a UNC path:\n            # vvvvvvvvvvvvvvvvvvvv drive letter or UNC path\n            # \\\\machine\\mountpoint\\directory\\etc\\...\n            #           directory ^^^^^^^^^^^^^^^\n            index = normp.find(sep, 2)\n            if index == -1:\n                return p[:0], p\n            index2 = normp.find(sep, index + 1)\n            # a UNC path can't have two slashes in a row\n            # (after the initial two)\n            if index2 == index + 1:\n                return p[:0], p\n            if index2 == -1:\n                index2 = len(p)\n            return p[:index2], p[index2:]\n        if normp[1:2] == colon:\n            return p[:2], p[2:]\n    return p[:0], p\n\n\n# Parse UNC paths\ndef splitunc(p):\n    \"\"\"Deprecated since Python 3.1.  Please use splitdrive() instead;\n    it now handles UNC paths.\n\n    Split a pathname into UNC mount point and relative path specifiers.\n\n    Return a 2-tuple (unc, rest); either part may be empty.\n    If unc is not empty, it has the form '//host/mount' (or similar\n    using backslashes).  unc+rest is always the input path.\n    Paths containing drive letters never have a UNC part.\n    \"\"\"\n    import warnings\n    warnings.warn(\"ntpath.splitunc is deprecated, use ntpath.splitdrive instead\",\n                  DeprecationWarning, 2)\n    drive, path = splitdrive(p)\n    if len(drive) == 2:\n         # Drive letter present\n        return p[:0], p\n    return drive, path\n\n\n# Split a path in head (everything up to the last '/') and tail (the\n# rest).  After the trailing '/' is stripped, the invariant\n# join(head, tail) == p holds.\n# The resulting head won't end in '/' unless it is the root.\n\ndef split(p):\n    \"\"\"Split a pathname.\n\n    Return tuple (head, tail) where tail is everything after the final slash.\n    Either part may be empty.\"\"\"\n    p = os.fspath(p)\n    seps = _get_bothseps(p)\n    d, p = splitdrive(p)\n    # set i to index beyond p's last slash\n    i = len(p)\n    while i and p[i-1] not in seps:\n        i -= 1\n    head, tail = p[:i], p[i:]  # now tail has no slashes\n    # remove trailing slashes from head, unless it's all slashes\n    head = head.rstrip(seps) or head\n    return d + head, tail\n\n\n# Split a path in root and extension.\n# The extension is everything starting at the last dot in the last\n# pathname component; the root is everything before that.\n# It is always true that root + ext == p.\n\ndef splitext(p):\n    p = os.fspath(p)\n    if isinstance(p, bytes):\n        return genericpath._splitext(p, b'\\\\', b'/', b'.')\n    else:\n        return genericpath._splitext(p, '\\\\', '/', '.')\nsplitext.__doc__ = genericpath._splitext.__doc__\n\n\n# Return the tail (basename) part of a path.\n\ndef basename(p):\n    \"\"\"Returns the final component of a pathname\"\"\"\n    return split(p)[1]\n\n\n# Return the head (dirname) part of a path.\n\ndef dirname(p):\n    \"\"\"Returns the directory component of a pathname\"\"\"\n    return split(p)[0]\n\n# Is a path a symbolic link?\n# This will always return false on systems where os.lstat doesn't exist.\n\ndef islink(path):\n    \"\"\"Test whether a path is a symbolic link.\n    This will always return false for Windows prior to 6.0.\n    \"\"\"\n    try:\n        st = os.lstat(path)\n    except (OSError, AttributeError):\n        return False\n    return stat.S_ISLNK(st.st_mode)\n\n# Being true for dangling symbolic links is also useful.\n\ndef lexists(path):\n    \"\"\"Test whether a path exists.  Returns True for broken symbolic links\"\"\"\n    try:\n        st = os.lstat(path)\n    except OSError:\n        return False\n    return True\n\n# Is a path a mount point?\n# Any drive letter root (eg c:\\)\n# Any share UNC (eg \\\\server\\share)\n# Any volume mounted on a filesystem folder\n#\n# No one method detects all three situations. Historically we've lexically\n# detected drive letter roots and share UNCs. The canonical approach to\n# detecting mounted volumes (querying the reparse tag) fails for the most\n# common case: drive letter roots. The alternative which uses GetVolumePathName\n# fails if the drive letter is the result of a SUBST.\ntry:\n    from nt import _getvolumepathname\nexcept ImportError:\n    _getvolumepathname = None\ndef ismount(path):\n    \"\"\"Test whether a path is a mount point (a drive root, the root of a\n    share, or a mounted volume)\"\"\"\n    path = os.fspath(path)\n    seps = _get_bothseps(path)\n    path = abspath(path)\n    root, rest = splitdrive(path)\n    if root and root[0] in seps:\n        return (not rest) or (rest in seps)\n    if rest in seps:\n        return True\n\n    if _getvolumepathname:\n        return path.rstrip(seps) == _getvolumepathname(path).rstrip(seps)\n    else:\n        return False\n\n\n# Expand paths beginning with '~' or '~user'.\n# '~' means $HOME; '~user' means that user's home directory.\n# If the path doesn't begin with '~', or if the user or $HOME is unknown,\n# the path is returned unchanged (leaving error reporting to whatever\n# function is called with the expanded path as argument).\n# See also module 'glob' for expansion of *, ? and [...] in pathnames.\n# (A function should also be defined to do full *sh-style environment\n# variable expansion.)\n\ndef expanduser(path):\n    \"\"\"Expand ~ and ~user constructs.\n\n    If user or $HOME is unknown, do nothing.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        tilde = b'~'\n    else:\n        tilde = '~'\n    if not path.startswith(tilde):\n        return path\n    i, n = 1, len(path)\n    while i < n and path[i] not in _get_bothseps(path):\n        i += 1\n\n    if 'HOME' in os.environ:\n        userhome = os.environ['HOME']\n    elif 'USERPROFILE' in os.environ:\n        userhome = os.environ['USERPROFILE']\n    elif not 'HOMEPATH' in os.environ:\n        return path\n    else:\n        try:\n            drive = os.environ['HOMEDRIVE']\n        except KeyError:\n            drive = ''\n        userhome = join(drive, os.environ['HOMEPATH'])\n\n    if isinstance(path, bytes):\n        userhome = os.fsencode(userhome)\n\n    if i != 1: #~user\n        userhome = join(dirname(userhome), path[1:i])\n\n    return userhome + path[i:]\n\n\n# Expand paths containing shell variable substitutions.\n# The following rules apply:\n#       - no expansion within single quotes\n#       - '$$' is translated into '$'\n#       - '%%' is translated into '%' if '%%' are not seen in %var1%%var2%\n#       - ${varname} is accepted.\n#       - $varname is accepted.\n#       - %varname% is accepted.\n#       - varnames can be made out of letters, digits and the characters '_-'\n#         (though is not verified in the ${varname} and %varname% cases)\n# XXX With COMMAND.COM you can use any characters in a variable name,\n# XXX except '^|<>='.\n\ndef expandvars(path):\n    \"\"\"Expand shell variables of the forms $var, ${var} and %var%.\n\n    Unknown variables are left unchanged.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        if b'$' not in path and b'%' not in path:\n            return path\n        import string\n        varchars = bytes(string.ascii_letters + string.digits + '_-', 'ascii')\n        quote = b'\\''\n        percent = b'%'\n        brace = b'{'\n        rbrace = b'}'\n        dollar = b'$'\n        environ = getattr(os, 'environb', None)\n    else:\n        if '$' not in path and '%' not in path:\n            return path\n        import string\n        varchars = string.ascii_letters + string.digits + '_-'\n        quote = '\\''\n        percent = '%'\n        brace = '{'\n        rbrace = '}'\n        dollar = '$'\n        environ = os.environ\n    res = path[:0]\n    index = 0\n    pathlen = len(path)\n    while index < pathlen:\n        c = path[index:index+1]\n        if c == quote:   # no expansion within single quotes\n            path = path[index + 1:]\n            pathlen = len(path)\n            try:\n                index = path.index(c)\n                res += c + path[:index + 1]\n            except ValueError:\n                res += c + path\n                index = pathlen - 1\n        elif c == percent:  # variable or '%'\n            if path[index + 1:index + 2] == percent:\n                res += c\n                index += 1\n            else:\n                path = path[index+1:]\n                pathlen = len(path)\n                try:\n                    index = path.index(percent)\n                except ValueError:\n                    res += percent + path\n                    index = pathlen - 1\n                else:\n                    var = path[:index]\n                    try:\n                        if environ is None:\n                            value = os.fsencode(os.environ[os.fsdecode(var)])\n                        else:\n                            value = environ[var]\n                    except KeyError:\n                        value = percent + var + percent\n                    res += value\n        elif c == dollar:  # variable or '$$'\n            if path[index + 1:index + 2] == dollar:\n                res += c\n                index += 1\n            elif path[index + 1:index + 2] == brace:\n                path = path[index+2:]\n                pathlen = len(path)\n                try:\n                    index = path.index(rbrace)\n                except ValueError:\n                    res += dollar + brace + path\n                    index = pathlen - 1\n                else:\n                    var = path[:index]\n                    try:\n                        if environ is None:\n                            value = os.fsencode(os.environ[os.fsdecode(var)])\n                        else:\n                            value = environ[var]\n                    except KeyError:\n                        value = dollar + brace + var + rbrace\n                    res += value\n            else:\n                var = path[:0]\n                index += 1\n                c = path[index:index + 1]\n                while c and c in varchars:\n                    var += c\n                    index += 1\n                    c = path[index:index + 1]\n                try:\n                    if environ is None:\n                        value = os.fsencode(os.environ[os.fsdecode(var)])\n                    else:\n                        value = environ[var]\n                except KeyError:\n                    value = dollar + var\n                res += value\n                if c:\n                    index -= 1\n        else:\n            res += c\n        index += 1\n    return res\n\n\n# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A\\B.\n# Previously, this function also truncated pathnames to 8+3 format,\n# but as this module is called \"ntpath\", that's obviously wrong!\n\ndef normpath(path):\n    \"\"\"Normalize path, eliminating double slashes, etc.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        sep = b'\\\\'\n        altsep = b'/'\n        curdir = b'.'\n        pardir = b'..'\n        special_prefixes = (b'\\\\\\\\.\\\\', b'\\\\\\\\?\\\\')\n    else:\n        sep = '\\\\'\n        altsep = '/'\n        curdir = '.'\n        pardir = '..'\n        special_prefixes = ('\\\\\\\\.\\\\', '\\\\\\\\?\\\\')\n    if path.startswith(special_prefixes):\n        # in the case of paths with these prefixes:\n        # \\\\.\\ -> device names\n        # \\\\?\\ -> literal paths\n        # do not do any normalization, but return the path unchanged\n        return path\n    path = path.replace(altsep, sep)\n    prefix, path = splitdrive(path)\n\n    # collapse initial backslashes\n    if path.startswith(sep):\n        prefix += sep\n        path = path.lstrip(sep)\n\n    comps = path.split(sep)\n    i = 0\n    while i < len(comps):\n        if not comps[i] or comps[i] == curdir:\n            del comps[i]\n        elif comps[i] == pardir:\n            if i > 0 and comps[i-1] != pardir:\n                del comps[i-1:i+1]\n                i -= 1\n            elif i == 0 and prefix.endswith(sep):\n                del comps[i]\n            else:\n                i += 1\n        else:\n            i += 1\n    # If the path is now empty, substitute '.'\n    if not prefix and not comps:\n        comps.append(curdir)\n    return prefix + sep.join(comps)\n\ndef _abspath_fallback(path):\n    \"\"\"Return the absolute version of a path as a fallback function in case\n    `nt._getfullpathname` is not available or raises OSError. See bpo-31047 for\n    more.\n\n    \"\"\"\n\n    path = os.fspath(path)\n    if not isabs(path):\n        if isinstance(path, bytes):\n            cwd = os.getcwdb()\n        else:\n            cwd = os.getcwd()\n        path = join(cwd, path)\n    return normpath(path)\n\n# Return an absolute path.\ntry:\n    from nt import _getfullpathname\n\nexcept ImportError: # not running on Windows - mock up something sensible\n    abspath = _abspath_fallback\n\nelse:  # use native Windows method on Windows\n    def abspath(path):\n        \"\"\"Return the absolute version of a path.\"\"\"\n        try:\n            return normpath(_getfullpathname(path))\n        except (OSError, ValueError):\n            return _abspath_fallback(path)\n\n# realpath is a no-op on systems without islink support\nrealpath = abspath\n# Win9x family and earlier have no Unicode filename support.\nsupports_unicode_filenames = (hasattr(sys, \"getwindowsversion\") and\n                              sys.getwindowsversion()[3] >= 2)\n\ndef relpath(path, start=None):\n    \"\"\"Return a relative version of a path\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        sep = b'\\\\'\n        curdir = b'.'\n        pardir = b'..'\n    else:\n        sep = '\\\\'\n        curdir = '.'\n        pardir = '..'\n\n    if start is None:\n        start = curdir\n\n    if not path:\n        raise ValueError(\"no path specified\")\n\n    start = os.fspath(start)\n    try:\n        start_abs = abspath(normpath(start))\n        path_abs = abspath(normpath(path))\n        start_drive, start_rest = splitdrive(start_abs)\n        path_drive, path_rest = splitdrive(path_abs)\n        if normcase(start_drive) != normcase(path_drive):\n            raise ValueError(\"path is on mount %r, start on mount %r\" % (\n                path_drive, start_drive))\n\n        start_list = [x for x in start_rest.split(sep) if x]\n        path_list = [x for x in path_rest.split(sep) if x]\n        # Work out how much of the filepath is shared by start and path.\n        i = 0\n        for e1, e2 in zip(start_list, path_list):\n            if normcase(e1) != normcase(e2):\n                break\n            i += 1\n\n        rel_list = [pardir] * (len(start_list)-i) + path_list[i:]\n        if not rel_list:\n            return curdir\n        return join(*rel_list)\n    except (TypeError, ValueError, AttributeError, BytesWarning, DeprecationWarning):\n        genericpath._check_arg_types('relpath', path, start)\n        raise\n\n\n# Return the longest common sub-path of the sequence of paths given as input.\n# The function is case-insensitive and 'separator-insensitive', i.e. if the\n# only difference between two paths is the use of '\\' versus '/' as separator,\n# they are deemed to be equal.\n#\n# However, the returned path will have the standard '\\' separator (even if the\n# given paths had the alternative '/' separator) and will have the case of the\n# first path given in the sequence. Additionally, any trailing separator is\n# stripped from the returned path.\n\ndef commonpath(paths):\n    \"\"\"Given a sequence of path names, returns the longest common sub-path.\"\"\"\n\n    if not paths:\n        raise ValueError('commonpath() arg is an empty sequence')\n\n    paths = tuple(map(os.fspath, paths))\n    if isinstance(paths[0], bytes):\n        sep = b'\\\\'\n        altsep = b'/'\n        curdir = b'.'\n    else:\n        sep = '\\\\'\n        altsep = '/'\n        curdir = '.'\n\n    try:\n        drivesplits = [splitdrive(p.replace(altsep, sep).lower()) for p in paths]\n        split_paths = [p.split(sep) for d, p in drivesplits]\n\n        try:\n            isabs, = set(p[:1] == sep for d, p in drivesplits)\n        except ValueError:\n            raise ValueError(\"Can't mix absolute and relative paths\") from None\n\n        # Check that all drive letters or UNC paths match. The check is made only\n        # now otherwise type errors for mixing strings and bytes would not be\n        # caught.\n        if len(set(d for d, p in drivesplits)) != 1:\n            raise ValueError(\"Paths don't have the same drive\")\n\n        drive, path = splitdrive(paths[0].replace(altsep, sep))\n        common = path.split(sep)\n        common = [c for c in common if c and c != curdir]\n\n        split_paths = [[c for c in s if c and c != curdir] for s in split_paths]\n        s1 = min(split_paths)\n        s2 = max(split_paths)\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                common = common[:i]\n                break\n        else:\n            common = common[:len(s1)]\n\n        prefix = drive + sep if isabs else drive\n        return prefix + sep.join(common)\n    except (TypeError, AttributeError):\n        genericpath._check_arg_types('commonpath', *paths)\n        raise\n\n\n# determine if two files are in fact the same file\ntry:\n    # GetFinalPathNameByHandle is available starting with Windows 6.0.\n    # Windows XP and non-Windows OS'es will mock _getfinalpathname.\n    if sys.getwindowsversion()[:2] >= (6, 0):\n        from nt import _getfinalpathname\n    else:\n        raise ImportError\nexcept (AttributeError, ImportError):\n    # On Windows XP and earlier, two files are the same if their absolute\n    # pathnames are the same.\n    # Non-Windows operating systems fake this method with an XP\n    # approximation.\n    def _getfinalpathname(f):\n        return normcase(abspath(f))\n\n\ntry:\n    # The genericpath.isdir implementation uses os.stat and checks the mode\n    # attribute to tell whether or not the path is a directory.\n    # This is overkill on Windows - just pass the path to GetFileAttributes\n    # and check the attribute from there.\n    from nt import _isdir as isdir\nexcept ImportError:\n    # Use genericpath.isdir as imported above.\n    pass\n",691],"d:\\coding\\python3.6\\lib\\_bootlocale.py":["\"\"\"A minimal subset of the locale module used at interpreter startup\n(imported by the _io module), in order to reduce startup time.\n\nDon't import directly from third-party code; use the `locale` module instead!\n\"\"\"\n\nimport sys\nimport _locale\n\nif sys.platform.startswith(\"win\"):\n    def getpreferredencoding(do_setlocale=True):\n        return _locale._getdefaultlocale()[1]\nelse:\n    try:\n        _locale.CODESET\n    except AttributeError:\n        def getpreferredencoding(do_setlocale=True):\n            # This path for legacy systems needs the more complex\n            # getdefaultlocale() function, import the full locale module.\n            import locale\n            return locale.getpreferredencoding(do_setlocale)\n    else:\n        def getpreferredencoding(do_setlocale=True):\n            assert not do_setlocale\n            result = _locale.nl_langinfo(_locale.CODESET)\n            if not result and sys.platform == 'darwin':\n                # nl_langinfo can return an empty string\n                # when the setting has an invalid value.\n                # Default to UTF-8 in that case because\n                # UTF-8 is the default charset on OSX and\n                # returning nothing will crash the\n                # interpreter.\n                result = 'UTF-8'\n            return result\n",34],"d:\\coding\\python3.6\\lib\\codecs.py":["\"\"\" codecs -- Python Codec Registry, API and helpers.\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.\n\n\"\"\"#\"\n\nimport builtins, sys\n\n### Registry and builtin stateless codec functions\n\ntry:\n    from _codecs import *\nexcept ImportError as why:\n    raise SystemError('Failed to load the builtin codecs: %s' % why)\n\n__all__ = [\"register\", \"lookup\", \"open\", \"EncodedFile\", \"BOM\", \"BOM_BE\",\n           \"BOM_LE\", \"BOM32_BE\", \"BOM32_LE\", \"BOM64_BE\", \"BOM64_LE\",\n           \"BOM_UTF8\", \"BOM_UTF16\", \"BOM_UTF16_LE\", \"BOM_UTF16_BE\",\n           \"BOM_UTF32\", \"BOM_UTF32_LE\", \"BOM_UTF32_BE\",\n           \"CodecInfo\", \"Codec\", \"IncrementalEncoder\", \"IncrementalDecoder\",\n           \"StreamReader\", \"StreamWriter\",\n           \"StreamReaderWriter\", \"StreamRecoder\",\n           \"getencoder\", \"getdecoder\", \"getincrementalencoder\",\n           \"getincrementaldecoder\", \"getreader\", \"getwriter\",\n           \"encode\", \"decode\", \"iterencode\", \"iterdecode\",\n           \"strict_errors\", \"ignore_errors\", \"replace_errors\",\n           \"xmlcharrefreplace_errors\",\n           \"backslashreplace_errors\", \"namereplace_errors\",\n           \"register_error\", \"lookup_error\"]\n\n### Constants\n\n#\n# Byte Order Mark (BOM = ZERO WIDTH NO-BREAK SPACE = U+FEFF)\n# and its possible byte string values\n# for UTF8/UTF16/UTF32 output and little/big endian machines\n#\n\n# UTF-8\nBOM_UTF8 = b'\\xef\\xbb\\xbf'\n\n# UTF-16, little endian\nBOM_LE = BOM_UTF16_LE = b'\\xff\\xfe'\n\n# UTF-16, big endian\nBOM_BE = BOM_UTF16_BE = b'\\xfe\\xff'\n\n# UTF-32, little endian\nBOM_UTF32_LE = b'\\xff\\xfe\\x00\\x00'\n\n# UTF-32, big endian\nBOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\n\nif sys.byteorder == 'little':\n\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_LE\n\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_LE\n\nelse:\n\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_BE\n\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_BE\n\n# Old broken names (don't use in new code)\nBOM32_LE = BOM_UTF16_LE\nBOM32_BE = BOM_UTF16_BE\nBOM64_LE = BOM_UTF32_LE\nBOM64_BE = BOM_UTF32_BE\n\n\n### Codec base classes (defining the API)\n\nclass CodecInfo(tuple):\n    \"\"\"Codec details when looking up the codec registry\"\"\"\n\n    # Private API to allow Python 3.4 to blacklist the known non-Unicode\n    # codecs in the standard library. A more general mechanism to\n    # reliably distinguish test encodings from other codecs will hopefully\n    # be defined for Python 3.5\n    #\n    # See http://bugs.python.org/issue19619\n    _is_text_encoding = True # Assume codecs are text encodings by default\n\n    def __new__(cls, encode, decode, streamreader=None, streamwriter=None,\n        incrementalencoder=None, incrementaldecoder=None, name=None,\n        *, _is_text_encoding=None):\n        self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))\n        self.name = name\n        self.encode = encode\n        self.decode = decode\n        self.incrementalencoder = incrementalencoder\n        self.incrementaldecoder = incrementaldecoder\n        self.streamwriter = streamwriter\n        self.streamreader = streamreader\n        if _is_text_encoding is not None:\n            self._is_text_encoding = _is_text_encoding\n        return self\n\n    def __repr__(self):\n        return \"<%s.%s object for encoding %s at %#x>\" % \\\n                (self.__class__.__module__, self.__class__.__qualname__,\n                 self.name, id(self))\n\nclass Codec:\n\n    \"\"\" Defines the interface for stateless encoders/decoders.\n\n        The .encode()/.decode() methods may use different error\n        handling schemes by providing the errors argument. These\n        string values are predefined:\n\n         'strict' - raise a ValueError error (or a subclass)\n         'ignore' - ignore the character and continue with the next\n         'replace' - replace with a suitable replacement character;\n                    Python will use the official U+FFFD REPLACEMENT\n                    CHARACTER for the builtin Unicode codecs on\n                    decoding and '?' on encoding.\n         'surrogateescape' - replace with private code points U+DCnn.\n         'xmlcharrefreplace' - Replace with the appropriate XML\n                               character reference (only for encoding).\n         'backslashreplace'  - Replace with backslashed escape sequences.\n         'namereplace'       - Replace with \\\\N{...} escape sequences\n                               (only for encoding).\n\n        The set of allowed values can be extended via register_error.\n\n    \"\"\"\n    def encode(self, input, errors='strict'):\n\n        \"\"\" Encodes the object input and returns a tuple (output\n            object, length consumed).\n\n            errors defines the error handling to apply. It defaults to\n            'strict' handling.\n\n            The method may not store state in the Codec instance. Use\n            StreamWriter for codecs which have to keep state in order to\n            make encoding efficient.\n\n            The encoder must be able to handle zero length input and\n            return an empty object of the output object type in this\n            situation.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def decode(self, input, errors='strict'):\n\n        \"\"\" Decodes the object input and returns a tuple (output\n            object, length consumed).\n\n            input must be an object which provides the bf_getreadbuf\n            buffer slot. Python strings, buffer objects and memory\n            mapped files are examples of objects providing this slot.\n\n            errors defines the error handling to apply. It defaults to\n            'strict' handling.\n\n            The method may not store state in the Codec instance. Use\n            StreamReader for codecs which have to keep state in order to\n            make decoding efficient.\n\n            The decoder must be able to handle zero length input and\n            return an empty object of the output object type in this\n            situation.\n\n        \"\"\"\n        raise NotImplementedError\n\nclass IncrementalEncoder(object):\n    \"\"\"\n    An IncrementalEncoder encodes an input in multiple steps. The input can\n    be passed piece by piece to the encode() method. The IncrementalEncoder\n    remembers the state of the encoding process between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Creates an IncrementalEncoder instance.\n\n        The IncrementalEncoder may use different error handling schemes by\n        providing the errors keyword argument. See the module docstring\n        for a list of possible values.\n        \"\"\"\n        self.errors = errors\n        self.buffer = \"\"\n\n    def encode(self, input, final=False):\n        \"\"\"\n        Encodes input and returns the resulting object.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self):\n        \"\"\"\n        Resets the encoder to the initial state.\n        \"\"\"\n\n    def getstate(self):\n        \"\"\"\n        Return the current state of the encoder.\n        \"\"\"\n        return 0\n\n    def setstate(self, state):\n        \"\"\"\n        Set the current state of the encoder. state must have been\n        returned by getstate().\n        \"\"\"\n\nclass BufferedIncrementalEncoder(IncrementalEncoder):\n    \"\"\"\n    This subclass of IncrementalEncoder can be used as the baseclass for an\n    incremental encoder if the encoder must keep some of the output in a\n    buffer between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalEncoder.__init__(self, errors)\n        # unencoded input that is kept between calls to encode()\n        self.buffer = \"\"\n\n    def _buffer_encode(self, input, errors, final):\n        # Overwrite this method in subclasses: It must encode input\n        # and return an (output, length consumed) tuple\n        raise NotImplementedError\n\n    def encode(self, input, final=False):\n        # encode input (taking the buffer into account)\n        data = self.buffer + input\n        (result, consumed) = self._buffer_encode(data, self.errors, final)\n        # keep unencoded input until the next call\n        self.buffer = data[consumed:]\n        return result\n\n    def reset(self):\n        IncrementalEncoder.reset(self)\n        self.buffer = \"\"\n\n    def getstate(self):\n        return self.buffer or 0\n\n    def setstate(self, state):\n        self.buffer = state or \"\"\n\nclass IncrementalDecoder(object):\n    \"\"\"\n    An IncrementalDecoder decodes an input in multiple steps. The input can\n    be passed piece by piece to the decode() method. The IncrementalDecoder\n    remembers the state of the decoding process between calls to decode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Create an IncrementalDecoder instance.\n\n        The IncrementalDecoder may use different error handling schemes by\n        providing the errors keyword argument. See the module docstring\n        for a list of possible values.\n        \"\"\"\n        self.errors = errors\n\n    def decode(self, input, final=False):\n        \"\"\"\n        Decode input and returns the resulting object.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self):\n        \"\"\"\n        Reset the decoder to the initial state.\n        \"\"\"\n\n    def getstate(self):\n        \"\"\"\n        Return the current state of the decoder.\n\n        This must be a (buffered_input, additional_state_info) tuple.\n        buffered_input must be a bytes object containing bytes that\n        were passed to decode() that have not yet been converted.\n        additional_state_info must be a non-negative integer\n        representing the state of the decoder WITHOUT yet having\n        processed the contents of buffered_input.  In the initial state\n        and after reset(), getstate() must return (b\"\", 0).\n        \"\"\"\n        return (b\"\", 0)\n\n    def setstate(self, state):\n        \"\"\"\n        Set the current state of the decoder.\n\n        state must have been returned by getstate().  The effect of\n        setstate((b\"\", 0)) must be equivalent to reset().\n        \"\"\"\n\nclass BufferedIncrementalDecoder(IncrementalDecoder):\n    \"\"\"\n    This subclass of IncrementalDecoder can be used as the baseclass for an\n    incremental decoder if the decoder must be able to handle incomplete\n    byte sequences.\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalDecoder.__init__(self, errors)\n        # undecoded input that is kept between calls to decode()\n        self.buffer = b\"\"\n\n    def _buffer_decode(self, input, errors, final):\n        # Overwrite this method in subclasses: It must decode input\n        # and return an (output, length consumed) tuple\n        raise NotImplementedError\n\n    def decode(self, input, final=False):\n        # decode input (taking the buffer into account)\n        data = self.buffer + input\n        (result, consumed) = self._buffer_decode(data, self.errors, final)\n        # keep undecoded input until the next call\n        self.buffer = data[consumed:]\n        return result\n\n    def reset(self):\n        IncrementalDecoder.reset(self)\n        self.buffer = b\"\"\n\n    def getstate(self):\n        # additional state info is always 0\n        return (self.buffer, 0)\n\n    def setstate(self, state):\n        # ignore additional state info\n        self.buffer = state[0]\n\n#\n# The StreamWriter and StreamReader class provide generic working\n# interfaces which can be used to implement new encoding submodules\n# very easily. See encodings/utf_8.py for an example on how this is\n# done.\n#\n\nclass StreamWriter(Codec):\n\n    def __init__(self, stream, errors='strict'):\n\n        \"\"\" Creates a StreamWriter instance.\n\n            stream must be a file-like object open for writing.\n\n            The StreamWriter may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next\n             'replace'- replace with a suitable replacement character\n             'xmlcharrefreplace' - Replace with the appropriate XML\n                                   character reference.\n             'backslashreplace'  - Replace with backslashed escape\n                                   sequences.\n             'namereplace'       - Replace with \\\\N{...} escape sequences.\n\n            The set of allowed parameter values can be extended via\n            register_error.\n        \"\"\"\n        self.stream = stream\n        self.errors = errors\n\n    def write(self, object):\n\n        \"\"\" Writes the object's contents encoded to self.stream.\n        \"\"\"\n        data, consumed = self.encode(object, self.errors)\n        self.stream.write(data)\n\n    def writelines(self, list):\n\n        \"\"\" Writes the concatenated list of strings to the stream\n            using .write().\n        \"\"\"\n        self.write(''.join(list))\n\n    def reset(self):\n\n        \"\"\" Flushes and resets the codec buffers used for keeping state.\n\n            Calling this method should ensure that the data on the\n            output is put into a clean state, that allows appending\n            of new fresh data without having to rescan the whole\n            stream to recover state.\n\n        \"\"\"\n        pass\n\n    def seek(self, offset, whence=0):\n        self.stream.seek(offset, whence)\n        if whence == 0 and offset == 0:\n            self.reset()\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n###\n\nclass StreamReader(Codec):\n\n    charbuffertype = str\n\n    def __init__(self, stream, errors='strict'):\n\n        \"\"\" Creates a StreamReader instance.\n\n            stream must be a file-like object open for reading.\n\n            The StreamReader may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next\n             'replace'- replace with a suitable replacement character\n             'backslashreplace' - Replace with backslashed escape sequences;\n\n            The set of allowed parameter values can be extended via\n            register_error.\n        \"\"\"\n        self.stream = stream\n        self.errors = errors\n        self.bytebuffer = b\"\"\n        self._empty_charbuffer = self.charbuffertype()\n        self.charbuffer = self._empty_charbuffer\n        self.linebuffer = None\n\n    def decode(self, input, errors='strict'):\n        raise NotImplementedError\n\n    def read(self, size=-1, chars=-1, firstline=False):\n\n        \"\"\" Decodes data from the stream self.stream and returns the\n            resulting object.\n\n            chars indicates the number of decoded code points or bytes to\n            return. read() will never return more data than requested,\n            but it might return less, if there is not enough available.\n\n            size indicates the approximate maximum number of decoded\n            bytes or code points to read for decoding. The decoder\n            can modify this setting as appropriate. The default value\n            -1 indicates to read and decode as much as possible.  size\n            is intended to prevent having to decode huge files in one\n            step.\n\n            If firstline is true, and a UnicodeDecodeError happens\n            after the first line terminator in the input only the first line\n            will be returned, the rest of the input will be kept until the\n            next call to read().\n\n            The method should use a greedy read strategy, meaning that\n            it should read as much data as is allowed within the\n            definition of the encoding and the given size, e.g.  if\n            optional encoding endings or state markers are available\n            on the stream, these should be read too.\n        \"\"\"\n        # If we have lines cached, first merge them back into characters\n        if self.linebuffer:\n            self.charbuffer = self._empty_charbuffer.join(self.linebuffer)\n            self.linebuffer = None\n\n        if chars < 0:\n            # For compatibility with other read() methods that take a\n            # single argument\n            chars = size\n\n        # read until we get the required number of characters (if available)\n        while True:\n            # can the request be satisfied from the character buffer?\n            if chars >= 0:\n                if len(self.charbuffer) >= chars:\n                    break\n            # we need more data\n            if size < 0:\n                newdata = self.stream.read()\n            else:\n                newdata = self.stream.read(size)\n            # decode bytes (those remaining from the last call included)\n            data = self.bytebuffer + newdata\n            if not data:\n                break\n            try:\n                newchars, decodedbytes = self.decode(data, self.errors)\n            except UnicodeDecodeError as exc:\n                if firstline:\n                    newchars, decodedbytes = \\\n                        self.decode(data[:exc.start], self.errors)\n                    lines = newchars.splitlines(keepends=True)\n                    if len(lines)<=1:\n                        raise\n                else:\n                    raise\n            # keep undecoded bytes until the next call\n            self.bytebuffer = data[decodedbytes:]\n            # put new characters in the character buffer\n            self.charbuffer += newchars\n            # there was no data available\n            if not newdata:\n                break\n        if chars < 0:\n            # Return everything we've got\n            result = self.charbuffer\n            self.charbuffer = self._empty_charbuffer\n        else:\n            # Return the first chars characters\n            result = self.charbuffer[:chars]\n            self.charbuffer = self.charbuffer[chars:]\n        return result\n\n    def readline(self, size=None, keepends=True):\n\n        \"\"\" Read one line from the input stream and return the\n            decoded data.\n\n            size, if given, is passed as size argument to the\n            read() method.\n\n        \"\"\"\n        # If we have lines cached from an earlier read, return\n        # them unconditionally\n        if self.linebuffer:\n            line = self.linebuffer[0]\n            del self.linebuffer[0]\n            if len(self.linebuffer) == 1:\n                # revert to charbuffer mode; we might need more data\n                # next time\n                self.charbuffer = self.linebuffer[0]\n                self.linebuffer = None\n            if not keepends:\n                line = line.splitlines(keepends=False)[0]\n            return line\n\n        readsize = size or 72\n        line = self._empty_charbuffer\n        # If size is given, we call read() only once\n        while True:\n            data = self.read(readsize, firstline=True)\n            if data:\n                # If we're at a \"\\r\" read one extra character (which might\n                # be a \"\\n\") to get a proper line ending. If the stream is\n                # temporarily exhausted we return the wrong line ending.\n                if (isinstance(data, str) and data.endswith(\"\\r\")) or \\\n                   (isinstance(data, bytes) and data.endswith(b\"\\r\")):\n                    data += self.read(size=1, chars=1)\n\n            line += data\n            lines = line.splitlines(keepends=True)\n            if lines:\n                if len(lines) > 1:\n                    # More than one line result; the first line is a full line\n                    # to return\n                    line = lines[0]\n                    del lines[0]\n                    if len(lines) > 1:\n                        # cache the remaining lines\n                        lines[-1] += self.charbuffer\n                        self.linebuffer = lines\n                        self.charbuffer = None\n                    else:\n                        # only one remaining line, put it back into charbuffer\n                        self.charbuffer = lines[0] + self.charbuffer\n                    if not keepends:\n                        line = line.splitlines(keepends=False)[0]\n                    break\n                line0withend = lines[0]\n                line0withoutend = lines[0].splitlines(keepends=False)[0]\n                if line0withend != line0withoutend: # We really have a line end\n                    # Put the rest back together and keep it until the next call\n                    self.charbuffer = self._empty_charbuffer.join(lines[1:]) + \\\n                                      self.charbuffer\n                    if keepends:\n                        line = line0withend\n                    else:\n                        line = line0withoutend\n                    break\n            # we didn't get anything or this was our only try\n            if not data or size is not None:\n                if line and not keepends:\n                    line = line.splitlines(keepends=False)[0]\n                break\n            if readsize < 8000:\n                readsize *= 2\n        return line\n\n    def readlines(self, sizehint=None, keepends=True):\n\n        \"\"\" Read all lines available on the input stream\n            and return them as a list.\n\n            Line breaks are implemented using the codec's decoder\n            method and are included in the list entries.\n\n            sizehint, if given, is ignored since there is no efficient\n            way to finding the true end-of-line.\n\n        \"\"\"\n        data = self.read()\n        return data.splitlines(keepends)\n\n    def reset(self):\n\n        \"\"\" Resets the codec buffers used for keeping state.\n\n            Note that no stream repositioning should take place.\n            This method is primarily intended to be able to recover\n            from decoding errors.\n\n        \"\"\"\n        self.bytebuffer = b\"\"\n        self.charbuffer = self._empty_charbuffer\n        self.linebuffer = None\n\n    def seek(self, offset, whence=0):\n        \"\"\" Set the input stream's current position.\n\n            Resets the codec buffers used for keeping state.\n        \"\"\"\n        self.stream.seek(offset, whence)\n        self.reset()\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        line = self.readline()\n        if line:\n            return line\n        raise StopIteration\n\n    def __iter__(self):\n        return self\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n###\n\nclass StreamReaderWriter:\n\n    \"\"\" StreamReaderWriter instances allow wrapping streams which\n        work in both read and write modes.\n\n        The design is such that one can use the factory functions\n        returned by the codec.lookup() function to construct the\n        instance.\n\n    \"\"\"\n    # Optional attributes set by the file wrappers below\n    encoding = 'unknown'\n\n    def __init__(self, stream, Reader, Writer, errors='strict'):\n\n        \"\"\" Creates a StreamReaderWriter instance.\n\n            stream must be a Stream-like object.\n\n            Reader, Writer must be factory functions or classes\n            providing the StreamReader, StreamWriter interface resp.\n\n            Error handling is done in the same way as defined for the\n            StreamWriter/Readers.\n\n        \"\"\"\n        self.stream = stream\n        self.reader = Reader(stream, errors)\n        self.writer = Writer(stream, errors)\n        self.errors = errors\n\n    def read(self, size=-1):\n\n        return self.reader.read(size)\n\n    def readline(self, size=None):\n\n        return self.reader.readline(size)\n\n    def readlines(self, sizehint=None):\n\n        return self.reader.readlines(sizehint)\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        return next(self.reader)\n\n    def __iter__(self):\n        return self\n\n    def write(self, data):\n\n        return self.writer.write(data)\n\n    def writelines(self, list):\n\n        return self.writer.writelines(list)\n\n    def reset(self):\n\n        self.reader.reset()\n        self.writer.reset()\n\n    def seek(self, offset, whence=0):\n        self.stream.seek(offset, whence)\n        self.reader.reset()\n        if whence == 0 and offset == 0:\n            self.writer.reset()\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    # these are needed to make \"with codecs.open(...)\" work properly\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n###\n\nclass StreamRecoder:\n\n    \"\"\" StreamRecoder instances translate data from one encoding to another.\n\n        They use the complete set of APIs returned by the\n        codecs.lookup() function to implement their task.\n\n        Data written to the StreamRecoder is first decoded into an\n        intermediate format (depending on the \"decode\" codec) and then\n        written to the underlying stream using an instance of the provided\n        Writer class.\n\n        In the other direction, data is read from the underlying stream using\n        a Reader instance and then encoded and returned to the caller.\n\n    \"\"\"\n    # Optional attributes set by the file wrappers below\n    data_encoding = 'unknown'\n    file_encoding = 'unknown'\n\n    def __init__(self, stream, encode, decode, Reader, Writer,\n                 errors='strict'):\n\n        \"\"\" Creates a StreamRecoder instance which implements a two-way\n            conversion: encode and decode work on the frontend (the\n            data visible to .read() and .write()) while Reader and Writer\n            work on the backend (the data in stream).\n\n            You can use these objects to do transparent\n            transcodings from e.g. latin-1 to utf-8 and back.\n\n            stream must be a file-like object.\n\n            encode and decode must adhere to the Codec interface; Reader and\n            Writer must be factory functions or classes providing the\n            StreamReader and StreamWriter interfaces resp.\n\n            Error handling is done in the same way as defined for the\n            StreamWriter/Readers.\n\n        \"\"\"\n        self.stream = stream\n        self.encode = encode\n        self.decode = decode\n        self.reader = Reader(stream, errors)\n        self.writer = Writer(stream, errors)\n        self.errors = errors\n\n    def read(self, size=-1):\n\n        data = self.reader.read(size)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def readline(self, size=None):\n\n        if size is None:\n            data = self.reader.readline()\n        else:\n            data = self.reader.readline(size)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def readlines(self, sizehint=None):\n\n        data = self.reader.read()\n        data, bytesencoded = self.encode(data, self.errors)\n        return data.splitlines(keepends=True)\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        data = next(self.reader)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def __iter__(self):\n        return self\n\n    def write(self, data):\n\n        data, bytesdecoded = self.decode(data, self.errors)\n        return self.writer.write(data)\n\n    def writelines(self, list):\n\n        data = ''.join(list)\n        data, bytesdecoded = self.decode(data, self.errors)\n        return self.writer.write(data)\n\n    def reset(self):\n\n        self.reader.reset()\n        self.writer.reset()\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n### Shortcuts\n\ndef open(filename, mode='r', encoding=None, errors='strict', buffering=1):\n\n    \"\"\" Open an encoded file using the given mode and return\n        a wrapped version providing transparent encoding/decoding.\n\n        Note: The wrapped version will only accept the object format\n        defined by the codecs, i.e. Unicode objects for most builtin\n        codecs. Output is also codec dependent and will usually be\n        Unicode as well.\n\n        Underlying encoded files are always opened in binary mode.\n        The default file mode is 'r', meaning to open the file in read mode.\n\n        encoding specifies the encoding which is to be used for the\n        file.\n\n        errors may be given to define the error handling. It defaults\n        to 'strict' which causes ValueErrors to be raised in case an\n        encoding error occurs.\n\n        buffering has the same meaning as for the builtin open() API.\n        It defaults to line buffered.\n\n        The returned wrapped file object provides an extra attribute\n        .encoding which allows querying the used encoding. This\n        attribute is only available if an encoding was specified as\n        parameter.\n\n    \"\"\"\n    if encoding is not None and \\\n       'b' not in mode:\n        # Force opening of the file in binary mode\n        mode = mode + 'b'\n    file = builtins.open(filename, mode, buffering)\n    if encoding is None:\n        return file\n    info = lookup(encoding)\n    srw = StreamReaderWriter(file, info.streamreader, info.streamwriter, errors)\n    # Add attributes to simplify introspection\n    srw.encoding = encoding\n    return srw\n\ndef EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):\n\n    \"\"\" Return a wrapped version of file which provides transparent\n        encoding translation.\n\n        Data written to the wrapped file is decoded according\n        to the given data_encoding and then encoded to the underlying\n        file using file_encoding. The intermediate data type\n        will usually be Unicode but depends on the specified codecs.\n\n        Bytes read from the file are decoded using file_encoding and then\n        passed back to the caller encoded using data_encoding.\n\n        If file_encoding is not given, it defaults to data_encoding.\n\n        errors may be given to define the error handling. It defaults\n        to 'strict' which causes ValueErrors to be raised in case an\n        encoding error occurs.\n\n        The returned wrapped file object provides two extra attributes\n        .data_encoding and .file_encoding which reflect the given\n        parameters of the same name. The attributes can be used for\n        introspection by Python programs.\n\n    \"\"\"\n    if file_encoding is None:\n        file_encoding = data_encoding\n    data_info = lookup(data_encoding)\n    file_info = lookup(file_encoding)\n    sr = StreamRecoder(file, data_info.encode, data_info.decode,\n                       file_info.streamreader, file_info.streamwriter, errors)\n    # Add attributes to simplify introspection\n    sr.data_encoding = data_encoding\n    sr.file_encoding = file_encoding\n    return sr\n\n### Helpers for codec lookup\n\ndef getencoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its encoder function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).encode\n\ndef getdecoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its decoder function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).decode\n\ndef getincrementalencoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalEncoder class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental encoder.\n\n    \"\"\"\n    encoder = lookup(encoding).incrementalencoder\n    if encoder is None:\n        raise LookupError(encoding)\n    return encoder\n\ndef getincrementaldecoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalDecoder class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental decoder.\n\n    \"\"\"\n    decoder = lookup(encoding).incrementaldecoder\n    if decoder is None:\n        raise LookupError(encoding)\n    return decoder\n\ndef getreader(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamReader class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).streamreader\n\ndef getwriter(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamWriter class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).streamwriter\n\ndef iterencode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Encoding iterator.\n\n    Encodes the input strings from the iterator using an IncrementalEncoder.\n\n    errors and kwargs are passed through to the IncrementalEncoder\n    constructor.\n    \"\"\"\n    encoder = getincrementalencoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = encoder.encode(input)\n        if output:\n            yield output\n    output = encoder.encode(\"\", True)\n    if output:\n        yield output\n\ndef iterdecode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Decoding iterator.\n\n    Decodes the input strings from the iterator using an IncrementalDecoder.\n\n    errors and kwargs are passed through to the IncrementalDecoder\n    constructor.\n    \"\"\"\n    decoder = getincrementaldecoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = decoder.decode(input)\n        if output:\n            yield output\n    output = decoder.decode(b\"\", True)\n    if output:\n        yield output\n\n### Helpers for charmap-based codecs\n\ndef make_identity_dict(rng):\n\n    \"\"\" make_identity_dict(rng) -> dict\n\n        Return a dictionary where elements of the rng sequence are\n        mapped to themselves.\n\n    \"\"\"\n    return {i:i for i in rng}\n\ndef make_encoding_map(decoding_map):\n\n    \"\"\" Creates an encoding map from a decoding map.\n\n        If a target mapping in the decoding map occurs multiple\n        times, then that target is mapped to None (undefined mapping),\n        causing an exception when encountered by the charmap codec\n        during translation.\n\n        One example where this happens is cp875.py which decodes\n        multiple character to \\\\u001a.\n\n    \"\"\"\n    m = {}\n    for k,v in decoding_map.items():\n        if not v in m:\n            m[v] = k\n        else:\n            m[v] = None\n    return m\n\n### error handlers\n\ntry:\n    strict_errors = lookup_error(\"strict\")\n    ignore_errors = lookup_error(\"ignore\")\n    replace_errors = lookup_error(\"replace\")\n    xmlcharrefreplace_errors = lookup_error(\"xmlcharrefreplace\")\n    backslashreplace_errors = lookup_error(\"backslashreplace\")\n    namereplace_errors = lookup_error(\"namereplace\")\nexcept LookupError:\n    # In --disable-unicode builds, these error handler are missing\n    strict_errors = None\n    ignore_errors = None\n    replace_errors = None\n    xmlcharrefreplace_errors = None\n    backslashreplace_errors = None\n    namereplace_errors = None\n\n# Tell modulefinder that using codecs probably needs the encodings\n# package\n_false = 0\nif _false:\n    import encodings\n\n### Tests\n\nif __name__ == '__main__':\n\n    # Make stdout translate Latin-1 output into UTF-8 output\n    sys.stdout = EncodedFile(sys.stdout, 'latin-1', 'utf-8')\n\n    # Have stdin translate Latin-1 input into UTF-8 input\n    sys.stdin = EncodedFile(sys.stdin, 'utf-8', 'latin-1')\n",1113],"d:\\coding\\python3.6\\lib\\threading.py":["\"\"\"Thread module emulating a subset of Java's threading model.\"\"\"\n\nimport sys as _sys\nimport _thread\n\nfrom time import monotonic as _time\nfrom traceback import format_exc as _format_exc\nfrom _weakrefset import WeakSet\nfrom itertools import islice as _islice, count as _count\ntry:\n    from _collections import deque as _deque\nexcept ImportError:\n    from collections import deque as _deque\n\n# Note regarding PEP 8 compliant names\n#  This threading model was originally inspired by Java, and inherited\n# the convention of camelCase function and method names from that\n# language. Those original names are not in any imminent danger of\n# being deprecated (even for Py3k),so this module provides them as an\n# alias for the PEP 8 compliant names\n# Note that using the new PEP 8 compliant names facilitates substitution\n# with the multiprocessing module, which doesn't provide the old\n# Java inspired names.\n\n__all__ = ['get_ident', 'active_count', 'Condition', 'current_thread',\n           'enumerate', 'main_thread', 'TIMEOUT_MAX',\n           'Event', 'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',\n           'Barrier', 'BrokenBarrierError', 'Timer', 'ThreadError',\n           'setprofile', 'settrace', 'local', 'stack_size']\n\n# Rename some stuff so \"from threading import *\" is safe\n_start_new_thread = _thread.start_new_thread\n_allocate_lock = _thread.allocate_lock\n_set_sentinel = _thread._set_sentinel\nget_ident = _thread.get_ident\nThreadError = _thread.error\ntry:\n    _CRLock = _thread.RLock\nexcept AttributeError:\n    _CRLock = None\nTIMEOUT_MAX = _thread.TIMEOUT_MAX\ndel _thread\n\n\n# Support for profile and trace hooks\n\n_profile_hook = None\n_trace_hook = None\n\ndef setprofile(func):\n    \"\"\"Set a profile function for all threads started from the threading module.\n\n    The func will be passed to sys.setprofile() for each thread, before its\n    run() method is called.\n\n    \"\"\"\n    global _profile_hook\n    _profile_hook = func\n\ndef settrace(func):\n    \"\"\"Set a trace function for all threads started from the threading module.\n\n    The func will be passed to sys.settrace() for each thread, before its run()\n    method is called.\n\n    \"\"\"\n    global _trace_hook\n    _trace_hook = func\n\n# Synchronization classes\n\nLock = _allocate_lock\n\ndef RLock(*args, **kwargs):\n    \"\"\"Factory function that returns a new reentrant lock.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it again\n    without blocking; the thread must release it once for each time it has\n    acquired it.\n\n    \"\"\"\n    if _CRLock is None:\n        return _PyRLock(*args, **kwargs)\n    return _CRLock(*args, **kwargs)\n\nclass _RLock:\n    \"\"\"This class implements reentrant lock objects.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it\n    again without blocking; the thread must release it once for each time it\n    has acquired it.\n\n    \"\"\"\n\n    def __init__(self):\n        self._block = _allocate_lock()\n        self._owner = None\n        self._count = 0\n\n    def __repr__(self):\n        owner = self._owner\n        try:\n            owner = _active[owner].name\n        except KeyError:\n            pass\n        return \"<%s %s.%s object owner=%r count=%d at %s>\" % (\n            \"locked\" if self._block.locked() else \"unlocked\",\n            self.__class__.__module__,\n            self.__class__.__qualname__,\n            owner,\n            self._count,\n            hex(id(self))\n        )\n\n    def acquire(self, blocking=True, timeout=-1):\n        \"\"\"Acquire a lock, blocking or non-blocking.\n\n        When invoked without arguments: if this thread already owns the lock,\n        increment the recursion level by one, and return immediately. Otherwise,\n        if another thread owns the lock, block until the lock is unlocked. Once\n        the lock is unlocked (not owned by any thread), then grab ownership, set\n        the recursion level to one, and return. If more than one thread is\n        blocked waiting until the lock is unlocked, only one at a time will be\n        able to grab ownership of the lock. There is no return value in this\n        case.\n\n        When invoked with the blocking argument set to true, do the same thing\n        as when called without arguments, and return true.\n\n        When invoked with the blocking argument set to false, do not block. If a\n        call without an argument would block, return false immediately;\n        otherwise, do the same thing as when called without arguments, and\n        return true.\n\n        When invoked with the floating-point timeout argument set to a positive\n        value, block for at most the number of seconds specified by timeout\n        and as long as the lock cannot be acquired.  Return true if the lock has\n        been acquired, false if the timeout has elapsed.\n\n        \"\"\"\n        me = get_ident()\n        if self._owner == me:\n            self._count += 1\n            return 1\n        rc = self._block.acquire(blocking, timeout)\n        if rc:\n            self._owner = me\n            self._count = 1\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        \"\"\"Release a lock, decrementing the recursion level.\n\n        If after the decrement it is zero, reset the lock to unlocked (not owned\n        by any thread), and if any other threads are blocked waiting for the\n        lock to become unlocked, allow exactly one of them to proceed. If after\n        the decrement the recursion level is still nonzero, the lock remains\n        locked and owned by the calling thread.\n\n        Only call this method when the calling thread owns the lock. A\n        RuntimeError is raised if this method is called when the lock is\n        unlocked.\n\n        There is no return value.\n\n        \"\"\"\n        if self._owner != get_ident():\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        self._count = count = self._count - 1\n        if not count:\n            self._owner = None\n            self._block.release()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n    # Internal methods used by condition variables\n\n    def _acquire_restore(self, state):\n        self._block.acquire()\n        self._count, self._owner = state\n\n    def _release_save(self):\n        if self._count == 0:\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        count = self._count\n        self._count = 0\n        owner = self._owner\n        self._owner = None\n        self._block.release()\n        return (count, owner)\n\n    def _is_owned(self):\n        return self._owner == get_ident()\n\n_PyRLock = _RLock\n\n\nclass Condition:\n    \"\"\"Class that implements a condition variable.\n\n    A condition variable allows one or more threads to wait until they are\n    notified by another thread.\n\n    If the lock argument is given and not None, it must be a Lock or RLock\n    object, and it is used as the underlying lock. Otherwise, a new RLock object\n    is created and used as the underlying lock.\n\n    \"\"\"\n\n    def __init__(self, lock=None):\n        if lock is None:\n            lock = RLock()\n        self._lock = lock\n        # Export the lock's acquire() and release() methods\n        self.acquire = lock.acquire\n        self.release = lock.release\n        # If the lock defines _release_save() and/or _acquire_restore(),\n        # these override the default implementations (which just call\n        # release() and acquire() on the lock).  Ditto for _is_owned().\n        try:\n            self._release_save = lock._release_save\n        except AttributeError:\n            pass\n        try:\n            self._acquire_restore = lock._acquire_restore\n        except AttributeError:\n            pass\n        try:\n            self._is_owned = lock._is_owned\n        except AttributeError:\n            pass\n        self._waiters = _deque()\n\n    def __enter__(self):\n        return self._lock.__enter__()\n\n    def __exit__(self, *args):\n        return self._lock.__exit__(*args)\n\n    def __repr__(self):\n        return \"<Condition(%s, %d)>\" % (self._lock, len(self._waiters))\n\n    def _release_save(self):\n        self._lock.release()           # No state to save\n\n    def _acquire_restore(self, x):\n        self._lock.acquire()           # Ignore saved state\n\n    def _is_owned(self):\n        # Return True if lock is owned by current_thread.\n        # This method is called only if _lock doesn't have _is_owned().\n        if self._lock.acquire(0):\n            self._lock.release()\n            return False\n        else:\n            return True\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n                waiter.acquire()\n                gotit = True\n            else:\n                if timeout > 0:\n                    gotit = waiter.acquire(True, timeout)\n                else:\n                    gotit = waiter.acquire(False)\n            return gotit\n        finally:\n            self._acquire_restore(saved_state)\n            if not gotit:\n                try:\n                    self._waiters.remove(waiter)\n                except ValueError:\n                    pass\n\n    def wait_for(self, predicate, timeout=None):\n        \"\"\"Wait until a condition evaluates to True.\n\n        predicate should be a callable which result will be interpreted as a\n        boolean value.  A timeout may be provided giving the maximum time to\n        wait.\n\n        \"\"\"\n        endtime = None\n        waittime = timeout\n        result = predicate()\n        while not result:\n            if waittime is not None:\n                if endtime is None:\n                    endtime = _time() + waittime\n                else:\n                    waittime = endtime - _time()\n                    if waittime <= 0:\n                        break\n            self.wait(waittime)\n            result = predicate()\n        return result\n\n    def notify(self, n=1):\n        \"\"\"Wake up one or more threads waiting on this condition, if any.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method wakes up at most n of the threads waiting for the condition\n        variable; it is a no-op if no threads are waiting.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot notify on un-acquired lock\")\n        all_waiters = self._waiters\n        waiters_to_notify = _deque(_islice(all_waiters, n))\n        if not waiters_to_notify:\n            return\n        for waiter in waiters_to_notify:\n            waiter.release()\n            try:\n                all_waiters.remove(waiter)\n            except ValueError:\n                pass\n\n    def notify_all(self):\n        \"\"\"Wake up all threads waiting on this condition.\n\n        If the calling thread has not acquired the lock when this method\n        is called, a RuntimeError is raised.\n\n        \"\"\"\n        self.notify(len(self._waiters))\n\n    notifyAll = notify_all\n\n\nclass Semaphore:\n    \"\"\"This class implements semaphore objects.\n\n    Semaphores manage a counter representing the number of release() calls minus\n    the number of acquire() calls, plus an initial value. The acquire() method\n    blocks if necessary until it can return without making the counter\n    negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    # After Tim Peters' semaphore class, but not quite the same (no maximum)\n\n    def __init__(self, value=1):\n        if value < 0:\n            raise ValueError(\"semaphore initial value must be >= 0\")\n        self._cond = Condition(Lock())\n        self._value = value\n\n    def acquire(self, blocking=True, timeout=None):\n        \"\"\"Acquire a semaphore, decrementing the internal counter by one.\n\n        When invoked without arguments: if the internal counter is larger than\n        zero on entry, decrement it by one and return immediately. If it is zero\n        on entry, block, waiting until some other thread has called release() to\n        make it larger than zero. This is done with proper interlocking so that\n        if multiple acquire() calls are blocked, release() will wake exactly one\n        of them up. The implementation may pick one at random, so the order in\n        which blocked threads are awakened should not be relied on. There is no\n        return value in this case.\n\n        When invoked with blocking set to true, do the same thing as when called\n        without arguments, and return true.\n\n        When invoked with blocking set to false, do not block. If a call without\n        an argument would block, return false immediately; otherwise, do the\n        same thing as when called without arguments, and return true.\n\n        When invoked with a timeout other than None, it will block for at\n        most timeout seconds.  If acquire does not complete successfully in\n        that interval, return false.  Return true otherwise.\n\n        \"\"\"\n        if not blocking and timeout is not None:\n            raise ValueError(\"can't specify timeout for non-blocking acquire\")\n        rc = False\n        endtime = None\n        with self._cond:\n            while self._value == 0:\n                if not blocking:\n                    break\n                if timeout is not None:\n                    if endtime is None:\n                        endtime = _time() + timeout\n                    else:\n                        timeout = endtime - _time()\n                        if timeout <= 0:\n                            break\n                self._cond.wait(timeout)\n            else:\n                self._value -= 1\n                rc = True\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        \"\"\"Release a semaphore, incrementing the internal counter by one.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        \"\"\"\n        with self._cond:\n            self._value += 1\n            self._cond.notify()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\nclass BoundedSemaphore(Semaphore):\n    \"\"\"Implements a bounded semaphore.\n\n    A bounded semaphore checks to make sure its current value doesn't exceed its\n    initial value. If it does, ValueError is raised. In most situations\n    semaphores are used to guard resources with limited capacity.\n\n    If the semaphore is released too many times it's a sign of a bug. If not\n    given, value defaults to 1.\n\n    Like regular semaphores, bounded semaphores manage a counter representing\n    the number of release() calls minus the number of acquire() calls, plus an\n    initial value. The acquire() method blocks if necessary until it can return\n    without making the counter negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    def __init__(self, value=1):\n        Semaphore.__init__(self, value)\n        self._initial_value = value\n\n    def release(self):\n        \"\"\"Release a semaphore, incrementing the internal counter by one.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        If the number of releases exceeds the number of acquires,\n        raise a ValueError.\n\n        \"\"\"\n        with self._cond:\n            if self._value >= self._initial_value:\n                raise ValueError(\"Semaphore released too many times\")\n            self._value += 1\n            self._cond.notify()\n\n\nclass Event:\n    \"\"\"Class implementing event objects.\n\n    Events manage a flag that can be set to true with the set() method and reset\n    to false with the clear() method. The wait() method blocks until the flag is\n    true.  The flag is initially false.\n\n    \"\"\"\n\n    # After Tim Peters' event class (without is_posted())\n\n    def __init__(self):\n        self._cond = Condition(Lock())\n        self._flag = False\n\n    def _reset_internal_locks(self):\n        # private!  called by Thread._reset_internal_locks by _after_fork()\n        self._cond.__init__(Lock())\n\n    def is_set(self):\n        \"\"\"Return true if and only if the internal flag is true.\"\"\"\n        return self._flag\n\n    isSet = is_set\n\n    def set(self):\n        \"\"\"Set the internal flag to true.\n\n        All threads waiting for it to become true are awakened. Threads\n        that call wait() once the flag is true will not block at all.\n\n        \"\"\"\n        with self._cond:\n            self._flag = True\n            self._cond.notify_all()\n\n    def clear(self):\n        \"\"\"Reset the internal flag to false.\n\n        Subsequently, threads calling wait() will block until set() is called to\n        set the internal flag to true again.\n\n        \"\"\"\n        with self._cond:\n            self._flag = False\n\n    def wait(self, timeout=None):\n        \"\"\"Block until the internal flag is true.\n\n        If the internal flag is true on entry, return immediately. Otherwise,\n        block until another thread calls set() to set the flag to true, or until\n        the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        This method returns the internal flag on exit, so it will always return\n        True except if a timeout is given and the operation times out.\n\n        \"\"\"\n        with self._cond:\n            signaled = self._flag\n            if not signaled:\n                signaled = self._cond.wait(timeout)\n            return signaled\n\n\n# A barrier class.  Inspired in part by the pthread_barrier_* api and\n# the CyclicBarrier class from Java.  See\n# http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and\n# http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/\n#        CyclicBarrier.html\n# for information.\n# We maintain two main states, 'filling' and 'draining' enabling the barrier\n# to be cyclic.  Threads are not allowed into it until it has fully drained\n# since the previous cycle.  In addition, a 'resetting' state exists which is\n# similar to 'draining' except that threads leave with a BrokenBarrierError,\n# and a 'broken' state in which all threads get the exception.\nclass Barrier:\n    \"\"\"Implements a Barrier.\n\n    Useful for synchronizing a fixed number of threads at known synchronization\n    points.  Threads block on 'wait()' and are simultaneously once they have all\n    made that call.\n\n    \"\"\"\n\n    def __init__(self, parties, action=None, timeout=None):\n        \"\"\"Create a barrier, initialised to 'parties' threads.\n\n        'action' is a callable which, when supplied, will be called by one of\n        the threads after they have all entered the barrier and just prior to\n        releasing them all. If a 'timeout' is provided, it is uses as the\n        default for all subsequent 'wait()' calls.\n\n        \"\"\"\n        self._cond = Condition(Lock())\n        self._action = action\n        self._timeout = timeout\n        self._parties = parties\n        self._state = 0 #0 filling, 1, draining, -1 resetting, -2 broken\n        self._count = 0\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for the barrier.\n\n        When the specified number of threads have started waiting, they are all\n        simultaneously awoken. If an 'action' was provided for the barrier, one\n        of the threads will have executed that callback prior to returning.\n        Returns an individual index number from 0 to 'parties-1'.\n\n        \"\"\"\n        if timeout is None:\n            timeout = self._timeout\n        with self._cond:\n            self._enter() # Block while the barrier drains.\n            index = self._count\n            self._count += 1\n            try:\n                if index + 1 == self._parties:\n                    # We release the barrier\n                    self._release()\n                else:\n                    # We wait until someone releases us\n                    self._wait(timeout)\n                return index\n            finally:\n                self._count -= 1\n                # Wake up any threads waiting for barrier to drain.\n                self._exit()\n\n    # Block until the barrier is ready for us, or raise an exception\n    # if it is broken.\n    def _enter(self):\n        while self._state in (-1, 1):\n            # It is draining or resetting, wait until done\n            self._cond.wait()\n        #see if the barrier is in a broken state\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 0\n\n    # Optionally run the 'action' and release the threads waiting\n    # in the barrier.\n    def _release(self):\n        try:\n            if self._action:\n                self._action()\n            # enter draining state\n            self._state = 1\n            self._cond.notify_all()\n        except:\n            #an exception during the _action handler.  Break and reraise\n            self._break()\n            raise\n\n    # Wait in the barrier until we are released.  Raise an exception\n    # if the barrier is reset or broken.\n    def _wait(self, timeout):\n        if not self._cond.wait_for(lambda : self._state != 0, timeout):\n            #timed out.  Break the barrier\n            self._break()\n            raise BrokenBarrierError\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 1\n\n    # If we are the last thread to exit the barrier, signal any threads\n    # waiting for the barrier to drain.\n    def _exit(self):\n        if self._count == 0:\n            if self._state in (-1, 1):\n                #resetting or draining\n                self._state = 0\n                self._cond.notify_all()\n\n    def reset(self):\n        \"\"\"Reset the barrier to the initial state.\n\n        Any threads currently waiting will get the BrokenBarrier exception\n        raised.\n\n        \"\"\"\n        with self._cond:\n            if self._count > 0:\n                if self._state == 0:\n                    #reset the barrier, waking up threads\n                    self._state = -1\n                elif self._state == -2:\n                    #was broken, set it to reset state\n                    #which clears when the last thread exits\n                    self._state = -1\n            else:\n                self._state = 0\n            self._cond.notify_all()\n\n    def abort(self):\n        \"\"\"Place the barrier into a 'broken' state.\n\n        Useful in case of error.  Any currently waiting threads and threads\n        attempting to 'wait()' will have BrokenBarrierError raised.\n\n        \"\"\"\n        with self._cond:\n            self._break()\n\n    def _break(self):\n        # An internal error was detected.  The barrier is set to\n        # a broken state all parties awakened.\n        self._state = -2\n        self._cond.notify_all()\n\n    @property\n    def parties(self):\n        \"\"\"Return the number of threads required to trip the barrier.\"\"\"\n        return self._parties\n\n    @property\n    def n_waiting(self):\n        \"\"\"Return the number of threads currently waiting at the barrier.\"\"\"\n        # We don't need synchronization here since this is an ephemeral result\n        # anyway.  It returns the correct value in the steady state.\n        if self._state == 0:\n            return self._count\n        return 0\n\n    @property\n    def broken(self):\n        \"\"\"Return True if the barrier is in a broken state.\"\"\"\n        return self._state == -2\n\n# exception raised by the Barrier class\nclass BrokenBarrierError(RuntimeError):\n    pass\n\n\n# Helper to generate new thread names\n_counter = _count().__next__\n_counter() # Consume 0 so first non-main thread has id 1.\ndef _newname(template=\"Thread-%d\"):\n    return template % _counter()\n\n# Active thread administration\n_active_limbo_lock = _allocate_lock()\n_active = {}    # maps thread id to Thread object\n_limbo = {}\n_dangling = WeakSet()\n\n# Main class for threads\n\nclass Thread:\n    \"\"\"A class that represents a thread of control.\n\n    This class can be safely subclassed in a limited fashion. There are two ways\n    to specify the activity: by passing a callable object to the constructor, or\n    by overriding the run() method in a subclass.\n\n    \"\"\"\n\n    _initialized = False\n    # Need to store a reference to sys.exc_info for printing\n    # out exceptions when a thread tries to use a global var. during interp.\n    # shutdown and thus raises an exception about trying to perform some\n    # operation on/with a NoneType\n    _exc_info = _sys.exc_info\n    # Keep sys.exc_clear too to clear the exception just before\n    # allowing .join() to return.\n    #XXX __exc_clear = _sys.exc_clear\n\n    def __init__(self, group=None, target=None, name=None,\n                 args=(), kwargs=None, *, daemon=None):\n        \"\"\"This constructor should always be called with keyword arguments. Arguments are:\n\n        *group* should be None; reserved for future extension when a ThreadGroup\n        class is implemented.\n\n        *target* is the callable object to be invoked by the run()\n        method. Defaults to None, meaning nothing is called.\n\n        *name* is the thread name. By default, a unique name is constructed of\n        the form \"Thread-N\" where N is a small decimal number.\n\n        *args* is the argument tuple for the target invocation. Defaults to ().\n\n        *kwargs* is a dictionary of keyword arguments for the target\n        invocation. Defaults to {}.\n\n        If a subclass overrides the constructor, it must make sure to invoke\n        the base class constructor (Thread.__init__()) before doing anything\n        else to the thread.\n\n        \"\"\"\n        assert group is None, \"group argument must be None for now\"\n        if kwargs is None:\n            kwargs = {}\n        self._target = target\n        self._name = str(name or _newname())\n        self._args = args\n        self._kwargs = kwargs\n        if daemon is not None:\n            self._daemonic = daemon\n        else:\n            self._daemonic = current_thread().daemon\n        self._ident = None\n        self._tstate_lock = None\n        self._started = Event()\n        self._is_stopped = False\n        self._initialized = True\n        # sys.stderr is not stored in the class like\n        # sys.exc_info since it can be changed between instances\n        self._stderr = _sys.stderr\n        # For debugging and _after_fork()\n        _dangling.add(self)\n\n    def _reset_internal_locks(self, is_alive):\n        # private!  Called by _after_fork() to reset our internal locks as\n        # they may be in an invalid state leading to a deadlock or crash.\n        self._started._reset_internal_locks()\n        if is_alive:\n            self._set_tstate_lock()\n        else:\n            # The thread isn't alive after fork: it doesn't have a tstate\n            # anymore.\n            self._is_stopped = True\n            self._tstate_lock = None\n\n    def __repr__(self):\n        assert self._initialized, \"Thread.__init__() was not called\"\n        status = \"initial\"\n        if self._started.is_set():\n            status = \"started\"\n        self.is_alive() # easy way to get ._is_stopped set when appropriate\n        if self._is_stopped:\n            status = \"stopped\"\n        if self._daemonic:\n            status += \" daemon\"\n        if self._ident is not None:\n            status += \" %s\" % self._ident\n        return \"<%s(%s, %s)>\" % (self.__class__.__name__, self._name, status)\n\n    def start(self):\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n        same thread object.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n            raise RuntimeError(\"threads can only be started once\")\n        with _active_limbo_lock:\n            _limbo[self] = self\n        try:\n            _start_new_thread(self._bootstrap, ())\n        except Exception:\n            with _active_limbo_lock:\n                del _limbo[self]\n            raise\n        self._started.wait()\n\n    def run(self):\n        \"\"\"Method representing the thread's activity.\n\n        You may override this method in a subclass. The standard run() method\n        invokes the callable object passed to the object's constructor as the\n        target argument, if any, with sequential and keyword arguments taken\n        from the args and kwargs arguments, respectively.\n\n        \"\"\"\n        try:\n            if self._target:\n                self._target(*self._args, **self._kwargs)\n        finally:\n            # Avoid a refcycle if the thread is running a function with\n            # an argument that has a member that points to the thread.\n            del self._target, self._args, self._kwargs\n\n    def _bootstrap(self):\n        # Wrapper around the real bootstrap code that ignores\n        # exceptions during interpreter cleanup.  Those typically\n        # happen when a daemon thread wakes up at an unfortunate\n        # moment, finds the world around it destroyed, and raises some\n        # random exception *** while trying to report the exception in\n        # _bootstrap_inner() below ***.  Those random exceptions\n        # don't help anybody, and they confuse users, so we suppress\n        # them.  We suppress them only when it appears that the world\n        # indeed has already been destroyed, so that exceptions in\n        # _bootstrap_inner() during normal business hours are properly\n        # reported.  Also, we only suppress them for daemonic threads;\n        # if a non-daemonic encounters this, something else is wrong.\n        try:\n            self._bootstrap_inner()\n        except:\n            if self._daemonic and _sys is None:\n                return\n            raise\n\n    def _set_ident(self):\n        self._ident = get_ident()\n\n    def _set_tstate_lock(self):\n        \"\"\"\n        Set a lock object which will be released by the interpreter when\n        the underlying thread state (see pystate.h) gets deleted.\n        \"\"\"\n        self._tstate_lock = _set_sentinel()\n        self._tstate_lock.acquire()\n\n    def _bootstrap_inner(self):\n        try:\n            self._set_ident()\n            self._set_tstate_lock()\n            self._started.set()\n            with _active_limbo_lock:\n                _active[self._ident] = self\n                del _limbo[self]\n\n            if _trace_hook:\n                _sys.settrace(_trace_hook)\n            if _profile_hook:\n                _sys.setprofile(_profile_hook)\n\n            try:\n                self.run()\n            except SystemExit:\n                pass\n            except:\n                # If sys.stderr is no more (most likely from interpreter\n                # shutdown) use self._stderr.  Otherwise still use sys (as in\n                # _sys) in case sys.stderr was redefined since the creation of\n                # self.\n                if _sys and _sys.stderr is not None:\n                    print(\"Exception in thread %s:\\n%s\" %\n                          (self.name, _format_exc()), file=_sys.stderr)\n                elif self._stderr is not None:\n                    # Do the best job possible w/o a huge amt. of code to\n                    # approximate a traceback (code ideas from\n                    # Lib/traceback.py)\n                    exc_type, exc_value, exc_tb = self._exc_info()\n                    try:\n                        print((\n                            \"Exception in thread \" + self.name +\n                            \" (most likely raised during interpreter shutdown):\"), file=self._stderr)\n                        print((\n                            \"Traceback (most recent call last):\"), file=self._stderr)\n                        while exc_tb:\n                            print((\n                                '  File \"%s\", line %s, in %s' %\n                                (exc_tb.tb_frame.f_code.co_filename,\n                                    exc_tb.tb_lineno,\n                                    exc_tb.tb_frame.f_code.co_name)), file=self._stderr)\n                            exc_tb = exc_tb.tb_next\n                        print((\"%s: %s\" % (exc_type, exc_value)), file=self._stderr)\n                    # Make sure that exc_tb gets deleted since it is a memory\n                    # hog; deleting everything else is just for thoroughness\n                    finally:\n                        del exc_type, exc_value, exc_tb\n            finally:\n                # Prevent a race in\n                # test_threading.test_no_refcycle_through_target when\n                # the exception keeps the target alive past when we\n                # assert that it's dead.\n                #XXX self._exc_clear()\n                pass\n        finally:\n            with _active_limbo_lock:\n                try:\n                    # We don't call self._delete() because it also\n                    # grabs _active_limbo_lock.\n                    del _active[get_ident()]\n                except:\n                    pass\n\n    def _stop(self):\n        # After calling ._stop(), .is_alive() returns False and .join() returns\n        # immediately.  ._tstate_lock must be released before calling ._stop().\n        #\n        # Normal case:  C code at the end of the thread's life\n        # (release_sentinel in _threadmodule.c) releases ._tstate_lock, and\n        # that's detected by our ._wait_for_tstate_lock(), called by .join()\n        # and .is_alive().  Any number of threads _may_ call ._stop()\n        # simultaneously (for example, if multiple threads are blocked in\n        # .join() calls), and they're not serialized.  That's harmless -\n        # they'll just make redundant rebindings of ._is_stopped and\n        # ._tstate_lock.  Obscure:  we rebind ._tstate_lock last so that the\n        # \"assert self._is_stopped\" in ._wait_for_tstate_lock() always works\n        # (the assert is executed only if ._tstate_lock is None).\n        #\n        # Special case:  _main_thread releases ._tstate_lock via this\n        # module's _shutdown() function.\n        lock = self._tstate_lock\n        if lock is not None:\n            assert not lock.locked()\n        self._is_stopped = True\n        self._tstate_lock = None\n\n    def _delete(self):\n        \"Remove current thread from the dict of currently running threads.\"\n\n        # Notes about running with _dummy_thread:\n        #\n        # Must take care to not raise an exception if _dummy_thread is being\n        # used (and thus this module is being used as an instance of\n        # dummy_threading).  _dummy_thread.get_ident() always returns -1 since\n        # there is only one thread if _dummy_thread is being used.  Thus\n        # len(_active) is always <= 1 here, and any Thread instance created\n        # overwrites the (if any) thread currently registered in _active.\n        #\n        # An instance of _MainThread is always created by 'threading'.  This\n        # gets overwritten the instant an instance of Thread is created; both\n        # threads return -1 from _dummy_thread.get_ident() and thus have the\n        # same key in the dict.  So when the _MainThread instance created by\n        # 'threading' tries to clean itself up when atexit calls this method\n        # it gets a KeyError if another Thread instance was created.\n        #\n        # This all means that KeyError from trying to delete something from\n        # _active if dummy_threading is being used is a red herring.  But\n        # since it isn't if dummy_threading is *not* being used then don't\n        # hide the exception.\n\n        try:\n            with _active_limbo_lock:\n                del _active[get_ident()]\n                # There must not be any python code between the previous line\n                # and after the lock is released.  Otherwise a tracing function\n                # could try to acquire the lock again in the same thread, (in\n                # current_thread()), and would block.\n        except KeyError:\n            if 'dummy_threading' not in _sys.modules:\n                raise\n\n    def join(self, timeout=None):\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n        called terminates -- either normally or through an unhandled exception\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof). As join() always returns None, you must call\n        isAlive() after join() to decide whether a timeout happened -- if the\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n        thread as that would cause a deadlock. It is also an error to join() a\n        thread before it has been started and attempts to do so raises the same\n        exception.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if not self._started.is_set():\n            raise RuntimeError(\"cannot join thread before it is started\")\n        if self is current_thread():\n            raise RuntimeError(\"cannot join current thread\")\n\n        if timeout is None:\n            self._wait_for_tstate_lock()\n        else:\n            # the behavior of a negative timeout isn't documented, but\n            # historically .join(timeout=x) for x<0 has acted as if timeout=0\n            self._wait_for_tstate_lock(timeout=max(timeout, 0))\n\n    def _wait_for_tstate_lock(self, block=True, timeout=-1):\n        # Issue #18808: wait for the thread state to be gone.\n        # At the end of the thread's life, after all knowledge of the thread\n        # is removed from C data structures, C code releases our _tstate_lock.\n        # This method passes its arguments to _tstate_lock.acquire().\n        # If the lock is acquired, the C code is done, and self._stop() is\n        # called.  That sets ._is_stopped to True, and ._tstate_lock to None.\n        lock = self._tstate_lock\n        if lock is None:  # already determined that the C code is done\n            assert self._is_stopped\n        elif lock.acquire(block, timeout):\n            lock.release()\n            self._stop()\n\n    @property\n    def name(self):\n        \"\"\"A string used for identification purposes only.\n\n        It has no semantics. Multiple threads may be given the same name. The\n        initial name is set by the constructor.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert self._initialized, \"Thread.__init__() not called\"\n        self._name = str(name)\n\n    @property\n    def ident(self):\n        \"\"\"Thread identifier of this thread or None if it has not been started.\n\n        This is a nonzero integer. See the get_ident() function. Thread\n        identifiers may be recycled when a thread exits and another thread is\n        created. The identifier is available even after the thread has exited.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._ident\n\n    def is_alive(self):\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n        after the run() method terminates. The module function enumerate()\n        returns a list of all alive threads.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        if self._is_stopped or not self._started.is_set():\n            return False\n        self._wait_for_tstate_lock(False)\n        return not self._is_stopped\n\n    isAlive = is_alive\n\n    @property\n    def daemon(self):\n        \"\"\"A boolean value indicating whether this thread is a daemon thread.\n\n        This must be set before start() is called, otherwise RuntimeError is\n        raised. Its initial value is inherited from the creating thread; the\n        main thread is not a daemon thread and therefore all threads created in\n        the main thread default to daemon = False.\n\n        The entire Python program exits when no alive non-daemon threads are\n        left.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._daemonic\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if self._started.is_set():\n            raise RuntimeError(\"cannot set daemon status of active thread\")\n        self._daemonic = daemonic\n\n    def isDaemon(self):\n        return self.daemon\n\n    def setDaemon(self, daemonic):\n        self.daemon = daemonic\n\n    def getName(self):\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n# The timer class was contributed by Itamar Shtull-Trauring\n\nclass Timer(Thread):\n    \"\"\"Call a function after a specified number of seconds:\n\n            t = Timer(30.0, f, args=None, kwargs=None)\n            t.start()\n            t.cancel()     # stop the timer's action if it's still waiting\n\n    \"\"\"\n\n    def __init__(self, interval, function, args=None, kwargs=None):\n        Thread.__init__(self)\n        self.interval = interval\n        self.function = function\n        self.args = args if args is not None else []\n        self.kwargs = kwargs if kwargs is not None else {}\n        self.finished = Event()\n\n    def cancel(self):\n        \"\"\"Stop the timer if it hasn't finished yet.\"\"\"\n        self.finished.set()\n\n    def run(self):\n        self.finished.wait(self.interval)\n        if not self.finished.is_set():\n            self.function(*self.args, **self.kwargs)\n        self.finished.set()\n\n\n# Special thread class to represent the main thread\n\nclass _MainThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=\"MainThread\", daemon=False)\n        self._set_tstate_lock()\n        self._started.set()\n        self._set_ident()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n\n# Dummy thread class to represent threads not started here.\n# These aren't garbage collected when they die, nor can they be waited for.\n# If they invoke anything in threading.py that calls current_thread(), they\n# leave an entry in the _active dict forever after.\n# Their purpose is to return *something* from current_thread().\n# They are marked as daemon threads so we won't wait for them\n# when we exit (conform previous semantics).\n\nclass _DummyThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=_newname(\"Dummy-%d\"), daemon=True)\n\n        self._started.set()\n        self._set_ident()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n    def _stop(self):\n        pass\n\n    def is_alive(self):\n        assert not self._is_stopped and self._started.is_set()\n        return True\n\n    def join(self, timeout=None):\n        assert False, \"cannot join a dummy thread\"\n\n\n# Global API functions\n\ndef current_thread():\n    \"\"\"Return the current Thread object, corresponding to the caller's thread of control.\n\n    If the caller's thread of control was not created through the threading\n    module, a dummy thread object with limited functionality is returned.\n\n    \"\"\"\n    try:\n        return _active[get_ident()]\n    except KeyError:\n        return _DummyThread()\n\ncurrentThread = current_thread\n\ndef active_count():\n    \"\"\"Return the number of Thread objects currently alive.\n\n    The returned count is equal to the length of the list returned by\n    enumerate().\n\n    \"\"\"\n    with _active_limbo_lock:\n        return len(_active) + len(_limbo)\n\nactiveCount = active_count\n\ndef _enumerate():\n    # Same as enumerate(), but without the lock. Internal use only.\n    return list(_active.values()) + list(_limbo.values())\n\ndef enumerate():\n    \"\"\"Return a list of all Thread objects currently alive.\n\n    The list includes daemonic threads, dummy thread objects created by\n    current_thread(), and the main thread. It excludes terminated threads and\n    threads that have not yet been started.\n\n    \"\"\"\n    with _active_limbo_lock:\n        return list(_active.values()) + list(_limbo.values())\n\nfrom _thread import stack_size\n\n# Create the main thread object,\n# and make it available for the interpreter\n# (Py_Main) as threading._shutdown.\n\n_main_thread = _MainThread()\n\ndef _shutdown():\n    # Obscure:  other threads may be waiting to join _main_thread.  That's\n    # dubious, but some code does it.  We can't wait for C code to release\n    # the main thread's tstate_lock - that won't happen until the interpreter\n    # is nearly dead.  So we release it here.  Note that just calling _stop()\n    # isn't enough:  other threads may already be waiting on _tstate_lock.\n    tlock = _main_thread._tstate_lock\n    # The main thread isn't finished yet, so its thread state lock can't have\n    # been released.\n    assert tlock is not None\n    assert tlock.locked()\n    tlock.release()\n    _main_thread._stop()\n    t = _pickSomeNonDaemonThread()\n    while t:\n        t.join()\n        t = _pickSomeNonDaemonThread()\n\ndef _pickSomeNonDaemonThread():\n    for t in enumerate():\n        if not t.daemon and t.is_alive():\n            return t\n    return None\n\ndef main_thread():\n    \"\"\"Return the main thread object.\n\n    In normal conditions, the main thread is the thread from which the\n    Python interpreter was started.\n    \"\"\"\n    return _main_thread\n\n# get thread-local implementation, either from the thread\n# module, or from the python fallback\n\ntry:\n    from _thread import _local as local\nexcept ImportError:\n    from _threading_local import local\n\n\ndef _after_fork():\n    # This function is called by Python/ceval.c:PyEval_ReInitThreads which\n    # is called from PyOS_AfterFork.  Here we cleanup threading module state\n    # that should not exist after a fork.\n\n    # Reset _active_limbo_lock, in case we forked while the lock was held\n    # by another (non-forked) thread.  http://bugs.python.org/issue874900\n    global _active_limbo_lock, _main_thread\n    _active_limbo_lock = _allocate_lock()\n\n    # fork() only copied the current thread; clear references to others.\n    new_active = {}\n    current = current_thread()\n    _main_thread = current\n    with _active_limbo_lock:\n        # Dangling thread instances must still have their locks reset,\n        # because someone may join() them.\n        threads = set(_enumerate())\n        threads.update(_dangling)\n        for thread in threads:\n            # Any lock/condition variable may be currently locked or in an\n            # invalid state, so we reinitialize them.\n            if thread is current:\n                # There is only one active thread. We reset the ident to\n                # its new value since it can have changed.\n                thread._reset_internal_locks(True)\n                ident = get_ident()\n                thread._ident = ident\n                new_active[ident] = thread\n            else:\n                # All the others are already stopped.\n                thread._reset_internal_locks(False)\n                thread._stop()\n\n        _limbo.clear()\n        _active.clear()\n        _active.update(new_active)\n        assert len(_active) == 1\n",1357],"C:\\Users\\libuliduobuqiuqiu\\Desktop\\GitProjects\\PythonDemo\\Logging\\logging_example.py":["# -*- coding: utf-8 -*-\n# @Author   : linshukai\n# @Date     : 2022/5/21\n# @Description  :   logging\n\nimport logging\n\nfrom logging import FileHandler, StreamHandler\nfrom logging import Formatter\n\n\ndef init_logger():\n    # \n    logger = logging.getLogger(__name__)\n    # \n\n    logger.setLevel(\"DEBUG\")\n\n    fm = Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n                   \"%Y-%m-%d %H:%M:%S\")\n\n    fh = FileHandler(\"example.log\")\n    fh.setLevel(\"WARNING\")\n    fh.setFormatter(fm)\n\n    ch = StreamHandler()\n    ch.setLevel(\"DEBUG\")\n    ch.setFormatter(fm)\n\n    logger.addHandler(fh)\n    logger.addHandler(ch)\n\n    return logger\n\n\nif __name__ == \"__main__\":\n    logger = init_logger()\n    logger.debug(\"DEBUG TEST\")\n    logger.info(\"INFO TEST\")\n    logger.warning(\"WARNING TEST\")\n    logger.error(\"ERROR TEST\")\n    logger.critical(\"CRITICAL TEST\")\n    logger.log(2, \"DEBUG TEST\")\n    try:\n        a = 1/0\n\n    except Exception as e:\n        logger.exception(f\"EXCEPTION TEST: {str(e)}\")\n\n",49],"d:\\coding\\python3.6\\lib\\genericpath.py":["\"\"\"\nPath operations common to more than one OS\nDo not use directly.  The OS specific modules import the appropriate\nfunctions from this module themselves.\n\"\"\"\nimport os\nimport stat\n\n__all__ = ['commonprefix', 'exists', 'getatime', 'getctime', 'getmtime',\n           'getsize', 'isdir', 'isfile', 'samefile', 'sameopenfile',\n           'samestat']\n\n\n# Does a path exist?\n# This is false for dangling symbolic links on systems that support them.\ndef exists(path):\n    \"\"\"Test whether a path exists.  Returns False for broken symbolic links\"\"\"\n    try:\n        os.stat(path)\n    except OSError:\n        return False\n    return True\n\n\n# This follows symbolic links, so both islink() and isdir() can be true\n# for the same path on systems that support symlinks\ndef isfile(path):\n    \"\"\"Test whether a path is a regular file\"\"\"\n    try:\n        st = os.stat(path)\n    except OSError:\n        return False\n    return stat.S_ISREG(st.st_mode)\n\n\n# Is a path a directory?\n# This follows symbolic links, so both islink() and isdir()\n# can be true for the same path on systems that support symlinks\ndef isdir(s):\n    \"\"\"Return true if the pathname refers to an existing directory.\"\"\"\n    try:\n        st = os.stat(s)\n    except OSError:\n        return False\n    return stat.S_ISDIR(st.st_mode)\n\n\ndef getsize(filename):\n    \"\"\"Return the size of a file, reported by os.stat().\"\"\"\n    return os.stat(filename).st_size\n\n\ndef getmtime(filename):\n    \"\"\"Return the last modification time of a file, reported by os.stat().\"\"\"\n    return os.stat(filename).st_mtime\n\n\ndef getatime(filename):\n    \"\"\"Return the last access time of a file, reported by os.stat().\"\"\"\n    return os.stat(filename).st_atime\n\n\ndef getctime(filename):\n    \"\"\"Return the metadata change time of a file, reported by os.stat().\"\"\"\n    return os.stat(filename).st_ctime\n\n\n# Return the longest prefix of all list elements.\ndef commonprefix(m):\n    \"Given a list of pathnames, returns the longest common leading component\"\n    if not m: return ''\n    # Some people pass in a list of pathname parts to operate in an OS-agnostic\n    # fashion; don't try to translate in that case as that's an abuse of the\n    # API and they are already doing what they need to be OS-agnostic and so\n    # they most likely won't be using an os.PathLike object in the sublists.\n    if not isinstance(m[0], (list, tuple)):\n        m = tuple(map(os.fspath, m))\n    s1 = min(m)\n    s2 = max(m)\n    for i, c in enumerate(s1):\n        if c != s2[i]:\n            return s1[:i]\n    return s1\n\n# Are two stat buffers (obtained from stat, fstat or lstat)\n# describing the same file?\ndef samestat(s1, s2):\n    \"\"\"Test whether two stat buffers reference the same file\"\"\"\n    return (s1.st_ino == s2.st_ino and\n            s1.st_dev == s2.st_dev)\n\n\n# Are two filenames really pointing to the same file?\ndef samefile(f1, f2):\n    \"\"\"Test whether two pathnames reference the same actual file\"\"\"\n    s1 = os.stat(f1)\n    s2 = os.stat(f2)\n    return samestat(s1, s2)\n\n\n# Are two open files really referencing the same file?\n# (Not necessarily the same file descriptor!)\ndef sameopenfile(fp1, fp2):\n    \"\"\"Test whether two open file objects reference the same file\"\"\"\n    s1 = os.fstat(fp1)\n    s2 = os.fstat(fp2)\n    return samestat(s1, s2)\n\n\n# Split a path in root and extension.\n# The extension is everything starting at the last dot in the last\n# pathname component; the root is everything before that.\n# It is always true that root + ext == p.\n\n# Generic implementation of splitext, to be parametrized with\n# the separators\ndef _splitext(p, sep, altsep, extsep):\n    \"\"\"Split the extension from a pathname.\n\n    Extension is everything from the last dot to the end, ignoring\n    leading dots.  Returns \"(root, ext)\"; ext may be empty.\"\"\"\n    # NOTE: This code must work for text and bytes strings.\n\n    sepIndex = p.rfind(sep)\n    if altsep:\n        altsepIndex = p.rfind(altsep)\n        sepIndex = max(sepIndex, altsepIndex)\n\n    dotIndex = p.rfind(extsep)\n    if dotIndex > sepIndex:\n        # skip all leading dots\n        filenameIndex = sepIndex + 1\n        while filenameIndex < dotIndex:\n            if p[filenameIndex:filenameIndex+1] != extsep:\n                return p[:dotIndex], p[dotIndex:]\n            filenameIndex += 1\n\n    return p, p[:0]\n\ndef _check_arg_types(funcname, *args):\n    hasstr = hasbytes = False\n    for s in args:\n        if isinstance(s, str):\n            hasstr = True\n        elif isinstance(s, bytes):\n            hasbytes = True\n        else:\n            raise TypeError('%s() argument must be str or bytes, not %r' %\n                            (funcname, s.__class__.__name__)) from None\n    if hasstr and hasbytes:\n        raise TypeError(\"Can't mix strings and bytes in path components\") from None\n",151],"d:\\coding\\python3.6\\lib\\multiprocessing\\process.py":["#\n# Module providing the `Process` class which emulates `threading.Thread`\n#\n# multiprocessing/process.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\n__all__ = ['BaseProcess', 'current_process', 'active_children']\n\n#\n# Imports\n#\n\nimport os\nimport sys\nimport signal\nimport itertools\nfrom _weakrefset import WeakSet\n\n#\n#\n#\n\ntry:\n    ORIGINAL_DIR = os.path.abspath(os.getcwd())\nexcept OSError:\n    ORIGINAL_DIR = None\n\n#\n# Public functions\n#\n\ndef current_process():\n    '''\n    Return process object representing the current process\n    '''\n    return _current_process\n\ndef active_children():\n    '''\n    Return list of process objects corresponding to live child processes\n    '''\n    _cleanup()\n    return list(_children)\n\n#\n#\n#\n\ndef _cleanup():\n    # check for processes which have finished\n    for p in list(_children):\n        if p._popen.poll() is not None:\n            _children.discard(p)\n\n#\n# The `Process` class\n#\n\nclass BaseProcess(object):\n    '''\n    Process objects represent activity that is run in a separate process\n\n    The class is analogous to `threading.Thread`\n    '''\n    def _Popen(self):\n        raise NotImplementedError\n\n    def __init__(self, group=None, target=None, name=None, args=(), kwargs={},\n                 *, daemon=None):\n        assert group is None, 'group argument must be None for now'\n        count = next(_process_counter)\n        self._identity = _current_process._identity + (count,)\n        self._config = _current_process._config.copy()\n        self._parent_pid = os.getpid()\n        self._popen = None\n        self._target = target\n        self._args = tuple(args)\n        self._kwargs = dict(kwargs)\n        self._name = name or type(self).__name__ + '-' + \\\n                     ':'.join(str(i) for i in self._identity)\n        if daemon is not None:\n            self.daemon = daemon\n        _dangling.add(self)\n\n    def run(self):\n        '''\n        Method to be run in sub-process; can be overridden in sub-class\n        '''\n        if self._target:\n            self._target(*self._args, **self._kwargs)\n\n    def start(self):\n        '''\n        Start child process\n        '''\n        assert self._popen is None, 'cannot start a process twice'\n        assert self._parent_pid == os.getpid(), \\\n               'can only start a process object created by current process'\n        assert not _current_process._config.get('daemon'), \\\n               'daemonic processes are not allowed to have children'\n        _cleanup()\n        self._popen = self._Popen(self)\n        self._sentinel = self._popen.sentinel\n        # Avoid a refcycle if the target function holds an indirect\n        # reference to the process object (see bpo-30775)\n        del self._target, self._args, self._kwargs\n        _children.add(self)\n\n    def terminate(self):\n        '''\n        Terminate process; sends SIGTERM signal or uses TerminateProcess()\n        '''\n        self._popen.terminate()\n\n    def join(self, timeout=None):\n        '''\n        Wait until child process terminates\n        '''\n        assert self._parent_pid == os.getpid(), 'can only join a child process'\n        assert self._popen is not None, 'can only join a started process'\n        res = self._popen.wait(timeout)\n        if res is not None:\n            _children.discard(self)\n\n    def is_alive(self):\n        '''\n        Return whether process is alive\n        '''\n        if self is _current_process:\n            return True\n        assert self._parent_pid == os.getpid(), 'can only test a child process'\n\n        if self._popen is None:\n            return False\n\n        returncode = self._popen.poll()\n        if returncode is None:\n            return True\n        else:\n            _children.discard(self)\n            return False\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert isinstance(name, str), 'name must be a string'\n        self._name = name\n\n    @property\n    def daemon(self):\n        '''\n        Return whether process is a daemon\n        '''\n        return self._config.get('daemon', False)\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        '''\n        Set whether process is a daemon\n        '''\n        assert self._popen is None, 'process has already started'\n        self._config['daemon'] = daemonic\n\n    @property\n    def authkey(self):\n        return self._config['authkey']\n\n    @authkey.setter\n    def authkey(self, authkey):\n        '''\n        Set authorization key of process\n        '''\n        self._config['authkey'] = AuthenticationString(authkey)\n\n    @property\n    def exitcode(self):\n        '''\n        Return exit code of process or `None` if it has yet to stop\n        '''\n        if self._popen is None:\n            return self._popen\n        return self._popen.poll()\n\n    @property\n    def ident(self):\n        '''\n        Return identifier (PID) of process or `None` if it has yet to start\n        '''\n        if self is _current_process:\n            return os.getpid()\n        else:\n            return self._popen and self._popen.pid\n\n    pid = ident\n\n    @property\n    def sentinel(self):\n        '''\n        Return a file descriptor (Unix) or handle (Windows) suitable for\n        waiting for process termination.\n        '''\n        try:\n            return self._sentinel\n        except AttributeError:\n            raise ValueError(\"process not started\")\n\n    def __repr__(self):\n        if self is _current_process:\n            status = 'started'\n        elif self._parent_pid != os.getpid():\n            status = 'unknown'\n        elif self._popen is None:\n            status = 'initial'\n        else:\n            if self._popen.poll() is not None:\n                status = self.exitcode\n            else:\n                status = 'started'\n\n        if type(status) is int:\n            if status == 0:\n                status = 'stopped'\n            else:\n                status = 'stopped[%s]' % _exitcode_to_name.get(status, status)\n\n        return '<%s(%s, %s%s)>' % (type(self).__name__, self._name,\n                                   status, self.daemon and ' daemon' or '')\n\n    ##\n\n    def _bootstrap(self):\n        from . import util, context\n        global _current_process, _process_counter, _children\n\n        try:\n            if self._start_method is not None:\n                context._force_start_method(self._start_method)\n            _process_counter = itertools.count(1)\n            _children = set()\n            util._close_stdin()\n            old_process = _current_process\n            _current_process = self\n            try:\n                util._finalizer_registry.clear()\n                util._run_after_forkers()\n            finally:\n                # delay finalization of the old process object until after\n                # _run_after_forkers() is executed\n                del old_process\n            util.info('child process calling self.run()')\n            try:\n                self.run()\n                exitcode = 0\n            finally:\n                util._exit_function()\n        except SystemExit as e:\n            if not e.args:\n                exitcode = 1\n            elif isinstance(e.args[0], int):\n                exitcode = e.args[0]\n            else:\n                sys.stderr.write(str(e.args[0]) + '\\n')\n                exitcode = 1\n        except:\n            exitcode = 1\n            import traceback\n            sys.stderr.write('Process %s:\\n' % self.name)\n            traceback.print_exc()\n        finally:\n            util.info('process exiting with exitcode %d' % exitcode)\n            util._flush_std_streams()\n\n        return exitcode\n\n#\n# We subclass bytes to avoid accidental transmission of auth keys over network\n#\n\nclass AuthenticationString(bytes):\n    def __reduce__(self):\n        from .context import get_spawning_popen\n        if get_spawning_popen() is None:\n            raise TypeError(\n                'Pickling an AuthenticationString object is '\n                'disallowed for security reasons'\n                )\n        return AuthenticationString, (bytes(self),)\n\n#\n# Create object representing the main process\n#\n\nclass _MainProcess(BaseProcess):\n\n    def __init__(self):\n        self._identity = ()\n        self._name = 'MainProcess'\n        self._parent_pid = None\n        self._popen = None\n        self._config = {'authkey': AuthenticationString(os.urandom(32)),\n                        'semprefix': '/mp'}\n        # Note that some versions of FreeBSD only allow named\n        # semaphores to have names of up to 14 characters.  Therefore\n        # we choose a short prefix.\n        #\n        # On MacOSX in a sandbox it may be necessary to use a\n        # different prefix -- see #19478.\n        #\n        # Everything in self._config will be inherited by descendant\n        # processes.\n\n\n_current_process = _MainProcess()\n_process_counter = itertools.count(1)\n_children = set()\ndel _MainProcess\n\n#\n# Give names to some return codes\n#\n\n_exitcode_to_name = {}\n\nfor name, signum in list(signal.__dict__.items()):\n    if name[:3]=='SIG' and '_' not in name:\n        _exitcode_to_name[-signum] = name\n\n# For debug and leak testing\n_dangling = WeakSet()\n",335],"d:\\coding\\python3.6\\lib\\traceback.py":["\"\"\"Extract, format and print information about Python stack traces.\"\"\"\n\nimport collections\nimport itertools\nimport linecache\nimport sys\n\n__all__ = ['extract_stack', 'extract_tb', 'format_exception',\n           'format_exception_only', 'format_list', 'format_stack',\n           'format_tb', 'print_exc', 'format_exc', 'print_exception',\n           'print_last', 'print_stack', 'print_tb', 'clear_frames',\n           'FrameSummary', 'StackSummary', 'TracebackException',\n           'walk_stack', 'walk_tb']\n\n#\n# Formatting and printing lists of traceback lines.\n#\n\ndef print_list(extracted_list, file=None):\n    \"\"\"Print the list of tuples as returned by extract_tb() or\n    extract_stack() as a formatted stack trace to the given file.\"\"\"\n    if file is None:\n        file = sys.stderr\n    for item in StackSummary.from_list(extracted_list).format():\n        print(item, file=file, end=\"\")\n\ndef format_list(extracted_list):\n    \"\"\"Format a list of tuples or FrameSummary objects for printing.\n\n    Given a list of tuples or FrameSummary objects as returned by\n    extract_tb() or extract_stack(), return a list of strings ready\n    for printing.\n\n    Each string in the resulting list corresponds to the item with the\n    same index in the argument list.  Each string ends in a newline;\n    the strings may contain internal newlines as well, for those items\n    whose source text line is not None.\n    \"\"\"\n    return StackSummary.from_list(extracted_list).format()\n\n#\n# Printing and Extracting Tracebacks.\n#\n\ndef print_tb(tb, limit=None, file=None):\n    \"\"\"Print up to 'limit' stack trace entries from the traceback 'tb'.\n\n    If 'limit' is omitted or None, all entries are printed.  If 'file'\n    is omitted or None, the output goes to sys.stderr; otherwise\n    'file' should be an open file or file-like object with a write()\n    method.\n    \"\"\"\n    print_list(extract_tb(tb, limit=limit), file=file)\n\ndef format_tb(tb, limit=None):\n    \"\"\"A shorthand for 'format_list(extract_tb(tb, limit))'.\"\"\"\n    return extract_tb(tb, limit=limit).format()\n\ndef extract_tb(tb, limit=None):\n    \"\"\"\n    Return a StackSummary object representing a list of\n    pre-processed entries from traceback.\n\n    This is useful for alternate formatting of stack traces.  If\n    'limit' is omitted or None, all entries are extracted.  A\n    pre-processed stack trace entry is a FrameSummary object\n    containing attributes filename, lineno, name, and line\n    representing the information that is usually printed for a stack\n    trace.  The line is a string with leading and trailing\n    whitespace stripped; if the source is not available it is None.\n    \"\"\"\n    return StackSummary.extract(walk_tb(tb), limit=limit)\n\n#\n# Exception formatting and output.\n#\n\n_cause_message = (\n    \"\\nThe above exception was the direct cause \"\n    \"of the following exception:\\n\\n\")\n\n_context_message = (\n    \"\\nDuring handling of the above exception, \"\n    \"another exception occurred:\\n\\n\")\n\n\ndef print_exception(etype, value, tb, limit=None, file=None, chain=True):\n    \"\"\"Print exception up to 'limit' stack trace entries from 'tb' to 'file'.\n\n    This differs from print_tb() in the following ways: (1) if\n    traceback is not None, it prints a header \"Traceback (most recent\n    call last):\"; (2) it prints the exception type and value after the\n    stack trace; (3) if type is SyntaxError and value has the\n    appropriate format, it prints the line where the syntax error\n    occurred with a caret on the next line indicating the approximate\n    position of the error.\n    \"\"\"\n    # format_exception has ignored etype for some time, and code such as cgitb\n    # passes in bogus values as a result. For compatibility with such code we\n    # ignore it here (rather than in the new TracebackException API).\n    if file is None:\n        file = sys.stderr\n    for line in TracebackException(\n            type(value), value, tb, limit=limit).format(chain=chain):\n        print(line, file=file, end=\"\")\n\n\ndef format_exception(etype, value, tb, limit=None, chain=True):\n    \"\"\"Format a stack trace and the exception information.\n\n    The arguments have the same meaning as the corresponding arguments\n    to print_exception().  The return value is a list of strings, each\n    ending in a newline and some containing internal newlines.  When\n    these lines are concatenated and printed, exactly the same text is\n    printed as does print_exception().\n    \"\"\"\n    # format_exception has ignored etype for some time, and code such as cgitb\n    # passes in bogus values as a result. For compatibility with such code we\n    # ignore it here (rather than in the new TracebackException API).\n    return list(TracebackException(\n        type(value), value, tb, limit=limit).format(chain=chain))\n\n\ndef format_exception_only(etype, value):\n    \"\"\"Format the exception part of a traceback.\n\n    The arguments are the exception type and value such as given by\n    sys.last_type and sys.last_value. The return value is a list of\n    strings, each ending in a newline.\n\n    Normally, the list contains a single string; however, for\n    SyntaxError exceptions, it contains several lines that (when\n    printed) display detailed information about where the syntax\n    error occurred.\n\n    The message indicating which exception occurred is always the last\n    string in the list.\n\n    \"\"\"\n    return list(TracebackException(etype, value, None).format_exception_only())\n\n\n# -- not official API but folk probably use these two functions.\n\ndef _format_final_exc_line(etype, value):\n    valuestr = _some_str(value)\n    if value is None or not valuestr:\n        line = \"%s\\n\" % etype\n    else:\n        line = \"%s: %s\\n\" % (etype, valuestr)\n    return line\n\ndef _some_str(value):\n    try:\n        return str(value)\n    except:\n        return '<unprintable %s object>' % type(value).__name__\n\n# --\n\ndef print_exc(limit=None, file=None, chain=True):\n    \"\"\"Shorthand for 'print_exception(*sys.exc_info(), limit, file)'.\"\"\"\n    print_exception(*sys.exc_info(), limit=limit, file=file, chain=chain)\n\ndef format_exc(limit=None, chain=True):\n    \"\"\"Like print_exc() but return a string.\"\"\"\n    return \"\".join(format_exception(*sys.exc_info(), limit=limit, chain=chain))\n\ndef print_last(limit=None, file=None, chain=True):\n    \"\"\"This is a shorthand for 'print_exception(sys.last_type,\n    sys.last_value, sys.last_traceback, limit, file)'.\"\"\"\n    if not hasattr(sys, \"last_type\"):\n        raise ValueError(\"no last exception\")\n    print_exception(sys.last_type, sys.last_value, sys.last_traceback,\n                    limit, file, chain)\n\n#\n# Printing and Extracting Stacks.\n#\n\ndef print_stack(f=None, limit=None, file=None):\n    \"\"\"Print a stack trace from its invocation point.\n\n    The optional 'f' argument can be used to specify an alternate\n    stack frame at which to start. The optional 'limit' and 'file'\n    arguments have the same meaning as for print_exception().\n    \"\"\"\n    if f is None:\n        f = sys._getframe().f_back\n    print_list(extract_stack(f, limit=limit), file=file)\n\n\ndef format_stack(f=None, limit=None):\n    \"\"\"Shorthand for 'format_list(extract_stack(f, limit))'.\"\"\"\n    if f is None:\n        f = sys._getframe().f_back\n    return format_list(extract_stack(f, limit=limit))\n\n\ndef extract_stack(f=None, limit=None):\n    \"\"\"Extract the raw traceback from the current stack frame.\n\n    The return value has the same format as for extract_tb().  The\n    optional 'f' and 'limit' arguments have the same meaning as for\n    print_stack().  Each item in the list is a quadruple (filename,\n    line number, function name, text), and the entries are in order\n    from oldest to newest stack frame.\n    \"\"\"\n    if f is None:\n        f = sys._getframe().f_back\n    stack = StackSummary.extract(walk_stack(f), limit=limit)\n    stack.reverse()\n    return stack\n\n\ndef clear_frames(tb):\n    \"Clear all references to local variables in the frames of a traceback.\"\n    while tb is not None:\n        try:\n            tb.tb_frame.clear()\n        except RuntimeError:\n            # Ignore the exception raised if the frame is still executing.\n            pass\n        tb = tb.tb_next\n\n\nclass FrameSummary:\n    \"\"\"A single frame from a traceback.\n\n    - :attr:`filename` The filename for the frame.\n    - :attr:`lineno` The line within filename for the frame that was\n      active when the frame was captured.\n    - :attr:`name` The name of the function or method that was executing\n      when the frame was captured.\n    - :attr:`line` The text from the linecache module for the\n      of code that was running when the frame was captured.\n    - :attr:`locals` Either None if locals were not supplied, or a dict\n      mapping the name to the repr() of the variable.\n    \"\"\"\n\n    __slots__ = ('filename', 'lineno', 'name', '_line', 'locals')\n\n    def __init__(self, filename, lineno, name, *, lookup_line=True,\n            locals=None, line=None):\n        \"\"\"Construct a FrameSummary.\n\n        :param lookup_line: If True, `linecache` is consulted for the source\n            code line. Otherwise, the line will be looked up when first needed.\n        :param locals: If supplied the frame locals, which will be captured as\n            object representations.\n        :param line: If provided, use this instead of looking up the line in\n            the linecache.\n        \"\"\"\n        self.filename = filename\n        self.lineno = lineno\n        self.name = name\n        self._line = line\n        if lookup_line:\n            self.line\n        self.locals = \\\n            dict((k, repr(v)) for k, v in locals.items()) if locals else None\n\n    def __eq__(self, other):\n        if isinstance(other, FrameSummary):\n            return (self.filename == other.filename and\n                    self.lineno == other.lineno and\n                    self.name == other.name and\n                    self.locals == other.locals)\n        if isinstance(other, tuple):\n            return (self.filename, self.lineno, self.name, self.line) == other\n        return NotImplemented\n\n    def __getitem__(self, pos):\n        return (self.filename, self.lineno, self.name, self.line)[pos]\n\n    def __iter__(self):\n        return iter([self.filename, self.lineno, self.name, self.line])\n\n    def __repr__(self):\n        return \"<FrameSummary file {filename}, line {lineno} in {name}>\".format(\n            filename=self.filename, lineno=self.lineno, name=self.name)\n\n    @property\n    def line(self):\n        if self._line is None:\n            self._line = linecache.getline(self.filename, self.lineno).strip()\n        return self._line\n\n\ndef walk_stack(f):\n    \"\"\"Walk a stack yielding the frame and line number for each frame.\n\n    This will follow f.f_back from the given frame. If no frame is given, the\n    current stack is used. Usually used with StackSummary.extract.\n    \"\"\"\n    if f is None:\n        f = sys._getframe().f_back.f_back\n    while f is not None:\n        yield f, f.f_lineno\n        f = f.f_back\n\n\ndef walk_tb(tb):\n    \"\"\"Walk a traceback yielding the frame and line number for each frame.\n\n    This will follow tb.tb_next (and thus is in the opposite order to\n    walk_stack). Usually used with StackSummary.extract.\n    \"\"\"\n    while tb is not None:\n        yield tb.tb_frame, tb.tb_lineno\n        tb = tb.tb_next\n\n\n_RECURSIVE_CUTOFF = 3 # Also hardcoded in traceback.c.\n\nclass StackSummary(list):\n    \"\"\"A stack of frames.\"\"\"\n\n    @classmethod\n    def extract(klass, frame_gen, *, limit=None, lookup_lines=True,\n            capture_locals=False):\n        \"\"\"Create a StackSummary from a traceback or stack object.\n\n        :param frame_gen: A generator that yields (frame, lineno) tuples to\n            include in the stack.\n        :param limit: None to include all frames or the number of frames to\n            include.\n        :param lookup_lines: If True, lookup lines for each frame immediately,\n            otherwise lookup is deferred until the frame is rendered.\n        :param capture_locals: If True, the local variables from each frame will\n            be captured as object representations into the FrameSummary.\n        \"\"\"\n        if limit is None:\n            limit = getattr(sys, 'tracebacklimit', None)\n            if limit is not None and limit < 0:\n                limit = 0\n        if limit is not None:\n            if limit >= 0:\n                frame_gen = itertools.islice(frame_gen, limit)\n            else:\n                frame_gen = collections.deque(frame_gen, maxlen=-limit)\n\n        result = klass()\n        fnames = set()\n        for f, lineno in frame_gen:\n            co = f.f_code\n            filename = co.co_filename\n            name = co.co_name\n\n            fnames.add(filename)\n            linecache.lazycache(filename, f.f_globals)\n            # Must defer line lookups until we have called checkcache.\n            if capture_locals:\n                f_locals = f.f_locals\n            else:\n                f_locals = None\n            result.append(FrameSummary(\n                filename, lineno, name, lookup_line=False, locals=f_locals))\n        for filename in fnames:\n            linecache.checkcache(filename)\n        # If immediate lookup was desired, trigger lookups now.\n        if lookup_lines:\n            for f in result:\n                f.line\n        return result\n\n    @classmethod\n    def from_list(klass, a_list):\n        \"\"\"\n        Create a StackSummary object from a supplied list of\n        FrameSummary objects or old-style list of tuples.\n        \"\"\"\n        # While doing a fast-path check for isinstance(a_list, StackSummary) is\n        # appealing, idlelib.run.cleanup_traceback and other similar code may\n        # break this by making arbitrary frames plain tuples, so we need to\n        # check on a frame by frame basis.\n        result = StackSummary()\n        for frame in a_list:\n            if isinstance(frame, FrameSummary):\n                result.append(frame)\n            else:\n                filename, lineno, name, line = frame\n                result.append(FrameSummary(filename, lineno, name, line=line))\n        return result\n\n    def format(self):\n        \"\"\"Format the stack ready for printing.\n\n        Returns a list of strings ready for printing.  Each string in the\n        resulting list corresponds to a single frame from the stack.\n        Each string ends in a newline; the strings may contain internal\n        newlines as well, for those items with source text lines.\n\n        For long sequences of the same frame and line, the first few\n        repetitions are shown, followed by a summary line stating the exact\n        number of further repetitions.\n        \"\"\"\n        result = []\n        last_file = None\n        last_line = None\n        last_name = None\n        count = 0\n        for frame in self:\n            if (last_file is None or last_file != frame.filename or\n                last_line is None or last_line != frame.lineno or\n                last_name is None or last_name != frame.name):\n                if count > _RECURSIVE_CUTOFF:\n                    count -= _RECURSIVE_CUTOFF\n                    result.append(\n                        f'  [Previous line repeated {count} more '\n                        f'time{\"s\" if count > 1 else \"\"}]\\n'\n                    )\n                last_file = frame.filename\n                last_line = frame.lineno\n                last_name = frame.name\n                count = 0\n            count += 1\n            if count > _RECURSIVE_CUTOFF:\n                continue\n            row = []\n            row.append('  File \"{}\", line {}, in {}\\n'.format(\n                frame.filename, frame.lineno, frame.name))\n            if frame.line:\n                row.append('    {}\\n'.format(frame.line.strip()))\n            if frame.locals:\n                for name, value in sorted(frame.locals.items()):\n                    row.append('    {name} = {value}\\n'.format(name=name, value=value))\n            result.append(''.join(row))\n        if count > _RECURSIVE_CUTOFF:\n            count -= _RECURSIVE_CUTOFF\n            result.append(\n                f'  [Previous line repeated {count} more '\n                f'time{\"s\" if count > 1 else \"\"}]\\n'\n            )\n        return result\n\n\nclass TracebackException:\n    \"\"\"An exception ready for rendering.\n\n    The traceback module captures enough attributes from the original exception\n    to this intermediary form to ensure that no references are held, while\n    still being able to fully print or format it.\n\n    Use `from_exception` to create TracebackException instances from exception\n    objects, or the constructor to create TracebackException instances from\n    individual components.\n\n    - :attr:`__cause__` A TracebackException of the original *__cause__*.\n    - :attr:`__context__` A TracebackException of the original *__context__*.\n    - :attr:`__suppress_context__` The *__suppress_context__* value from the\n      original exception.\n    - :attr:`stack` A `StackSummary` representing the traceback.\n    - :attr:`exc_type` The class of the original traceback.\n    - :attr:`filename` For syntax errors - the filename where the error\n      occurred.\n    - :attr:`lineno` For syntax errors - the linenumber where the error\n      occurred.\n    - :attr:`text` For syntax errors - the text where the error\n      occurred.\n    - :attr:`offset` For syntax errors - the offset into the text where the\n      error occurred.\n    - :attr:`msg` For syntax errors - the compiler error message.\n    \"\"\"\n\n    def __init__(self, exc_type, exc_value, exc_traceback, *, limit=None,\n            lookup_lines=True, capture_locals=False, _seen=None):\n        # NB: we need to accept exc_traceback, exc_value, exc_traceback to\n        # permit backwards compat with the existing API, otherwise we\n        # need stub thunk objects just to glue it together.\n        # Handle loops in __cause__ or __context__.\n        if _seen is None:\n            _seen = set()\n        _seen.add(id(exc_value))\n        # Gracefully handle (the way Python 2.4 and earlier did) the case of\n        # being called with no type or value (None, None, None).\n        if (exc_value and exc_value.__cause__ is not None\n            and id(exc_value.__cause__) not in _seen):\n            cause = TracebackException(\n                type(exc_value.__cause__),\n                exc_value.__cause__,\n                exc_value.__cause__.__traceback__,\n                limit=limit,\n                lookup_lines=False,\n                capture_locals=capture_locals,\n                _seen=_seen)\n        else:\n            cause = None\n        if (exc_value and exc_value.__context__ is not None\n            and id(exc_value.__context__) not in _seen):\n            context = TracebackException(\n                type(exc_value.__context__),\n                exc_value.__context__,\n                exc_value.__context__.__traceback__,\n                limit=limit,\n                lookup_lines=False,\n                capture_locals=capture_locals,\n                _seen=_seen)\n        else:\n            context = None\n        self.exc_traceback = exc_traceback\n        self.__cause__ = cause\n        self.__context__ = context\n        self.__suppress_context__ = \\\n            exc_value.__suppress_context__ if exc_value else False\n        # TODO: locals.\n        self.stack = StackSummary.extract(\n            walk_tb(exc_traceback), limit=limit, lookup_lines=lookup_lines,\n            capture_locals=capture_locals)\n        self.exc_type = exc_type\n        # Capture now to permit freeing resources: only complication is in the\n        # unofficial API _format_final_exc_line\n        self._str = _some_str(exc_value)\n        if exc_type and issubclass(exc_type, SyntaxError):\n            # Handle SyntaxError's specially\n            self.filename = exc_value.filename\n            self.lineno = str(exc_value.lineno)\n            self.text = exc_value.text\n            self.offset = exc_value.offset\n            self.msg = exc_value.msg\n        if lookup_lines:\n            self._load_lines()\n\n    @classmethod\n    def from_exception(cls, exc, *args, **kwargs):\n        \"\"\"Create a TracebackException from an exception.\"\"\"\n        return cls(type(exc), exc, exc.__traceback__, *args, **kwargs)\n\n    def _load_lines(self):\n        \"\"\"Private API. force all lines in the stack to be loaded.\"\"\"\n        for frame in self.stack:\n            frame.line\n        if self.__context__:\n            self.__context__._load_lines()\n        if self.__cause__:\n            self.__cause__._load_lines()\n\n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n    def __str__(self):\n        return self._str\n\n    def format_exception_only(self):\n        \"\"\"Format the exception part of the traceback.\n\n        The return value is a generator of strings, each ending in a newline.\n\n        Normally, the generator emits a single string; however, for\n        SyntaxError exceptions, it emites several lines that (when\n        printed) display detailed information about where the syntax\n        error occurred.\n\n        The message indicating which exception occurred is always the last\n        string in the output.\n        \"\"\"\n        if self.exc_type is None:\n            yield _format_final_exc_line(None, self._str)\n            return\n\n        stype = self.exc_type.__qualname__\n        smod = self.exc_type.__module__\n        if smod not in (\"__main__\", \"builtins\"):\n            stype = smod + '.' + stype\n\n        if not issubclass(self.exc_type, SyntaxError):\n            yield _format_final_exc_line(stype, self._str)\n            return\n\n        # It was a syntax error; show exactly where the problem was found.\n        filename = self.filename or \"<string>\"\n        lineno = str(self.lineno) or '?'\n        yield '  File \"{}\", line {}\\n'.format(filename, lineno)\n\n        badline = self.text\n        offset = self.offset\n        if badline is not None:\n            yield '    {}\\n'.format(badline.strip())\n            if offset is not None:\n                caretspace = badline.rstrip('\\n')\n                offset = min(len(caretspace), offset) - 1\n                caretspace = caretspace[:offset].lstrip()\n                # non-space whitespace (likes tabs) must be kept for alignment\n                caretspace = ((c.isspace() and c or ' ') for c in caretspace)\n                yield '    {}^\\n'.format(''.join(caretspace))\n        msg = self.msg or \"<no detail available>\"\n        yield \"{}: {}\\n\".format(stype, msg)\n\n    def format(self, *, chain=True):\n        \"\"\"Format the exception.\n\n        If chain is not *True*, *__cause__* and *__context__* will not be formatted.\n\n        The return value is a generator of strings, each ending in a newline and\n        some containing internal newlines. `print_exception` is a wrapper around\n        this method which just prints the lines to a file.\n\n        The message indicating which exception occurred is always the last\n        string in the output.\n        \"\"\"\n        if chain:\n            if self.__cause__ is not None:\n                yield from self.__cause__.format(chain=chain)\n                yield _cause_message\n            elif (self.__context__ is not None and\n                not self.__suppress_context__):\n                yield from self.__context__.format(chain=chain)\n                yield _context_message\n        if self.exc_traceback is not None:\n            yield 'Traceback (most recent call last):\\n'\n        yield from self.stack.format()\n        yield from self.format_exception_only()\n",612],"d:\\coding\\python3.6\\lib\\linecache.py":["\"\"\"Cache lines from Python source files.\n\nThis is intended to read lines from modules imported -- hence if a filename\nis not found, it will look down the module search path for a file by\nthat name.\n\"\"\"\n\nimport functools\nimport sys\nimport os\nimport tokenize\n\n__all__ = [\"getline\", \"clearcache\", \"checkcache\"]\n\ndef getline(filename, lineno, module_globals=None):\n    lines = getlines(filename, module_globals)\n    if 1 <= lineno <= len(lines):\n        return lines[lineno-1]\n    else:\n        return ''\n\n\n# The cache\n\n# The cache. Maps filenames to either a thunk which will provide source code,\n# or a tuple (size, mtime, lines, fullname) once loaded.\ncache = {}\n\n\ndef clearcache():\n    \"\"\"Clear the cache entirely.\"\"\"\n\n    global cache\n    cache = {}\n\n\ndef getlines(filename, module_globals=None):\n    \"\"\"Get the lines for a Python source file from the cache.\n    Update the cache if it doesn't contain an entry for this file already.\"\"\"\n\n    if filename in cache:\n        entry = cache[filename]\n        if len(entry) != 1:\n            return cache[filename][2]\n\n    try:\n        return updatecache(filename, module_globals)\n    except MemoryError:\n        clearcache()\n        return []\n\n\ndef checkcache(filename=None):\n    \"\"\"Discard cache entries that are out of date.\n    (This is not checked upon each call!)\"\"\"\n\n    if filename is None:\n        filenames = list(cache.keys())\n    else:\n        if filename in cache:\n            filenames = [filename]\n        else:\n            return\n\n    for filename in filenames:\n        entry = cache[filename]\n        if len(entry) == 1:\n            # lazy cache entry, leave it lazy.\n            continue\n        size, mtime, lines, fullname = entry\n        if mtime is None:\n            continue   # no-op for files loaded via a __loader__\n        try:\n            stat = os.stat(fullname)\n        except OSError:\n            del cache[filename]\n            continue\n        if size != stat.st_size or mtime != stat.st_mtime:\n            del cache[filename]\n\n\ndef updatecache(filename, module_globals=None):\n    \"\"\"Update a cache entry and return its list of lines.\n    If something's wrong, print a message, discard the cache entry,\n    and return an empty list.\"\"\"\n\n    if filename in cache:\n        if len(cache[filename]) != 1:\n            del cache[filename]\n    if not filename or (filename.startswith('<') and filename.endswith('>')):\n        return []\n\n    fullname = filename\n    try:\n        stat = os.stat(fullname)\n    except OSError:\n        basename = filename\n\n        # Realise a lazy loader based lookup if there is one\n        # otherwise try to lookup right now.\n        if lazycache(filename, module_globals):\n            try:\n                data = cache[filename][0]()\n            except (ImportError, OSError):\n                pass\n            else:\n                if data is None:\n                    # No luck, the PEP302 loader cannot find the source\n                    # for this module.\n                    return []\n                cache[filename] = (\n                    len(data), None,\n                    [line+'\\n' for line in data.splitlines()], fullname\n                )\n                return cache[filename][2]\n\n        # Try looking through the module search path, which is only useful\n        # when handling a relative filename.\n        if os.path.isabs(filename):\n            return []\n\n        for dirname in sys.path:\n            try:\n                fullname = os.path.join(dirname, basename)\n            except (TypeError, AttributeError):\n                # Not sufficiently string-like to do anything useful with.\n                continue\n            try:\n                stat = os.stat(fullname)\n                break\n            except OSError:\n                pass\n        else:\n            return []\n    try:\n        with tokenize.open(fullname) as fp:\n            lines = fp.readlines()\n    except OSError:\n        return []\n    if lines and not lines[-1].endswith('\\n'):\n        lines[-1] += '\\n'\n    size, mtime = stat.st_size, stat.st_mtime\n    cache[filename] = size, mtime, lines, fullname\n    return lines\n\n\ndef lazycache(filename, module_globals):\n    \"\"\"Seed the cache for filename with module_globals.\n\n    The module loader will be asked for the source only when getlines is\n    called, not immediately.\n\n    If there is an entry in the cache already, it is not altered.\n\n    :return: True if a lazy load is registered in the cache,\n        otherwise False. To register such a load a module loader with a\n        get_source method must be found, the filename must be a cachable\n        filename, and the filename must not be already cached.\n    \"\"\"\n    if filename in cache:\n        if len(cache[filename]) == 1:\n            return True\n        else:\n            return False\n    if not filename or (filename.startswith('<') and filename.endswith('>')):\n        return False\n    # Try for a __loader__, if available\n    if module_globals and '__loader__' in module_globals:\n        name = module_globals.get('__name__')\n        loader = module_globals['__loader__']\n        get_source = getattr(loader, 'get_source', None)\n\n        if name and get_source:\n            get_lines = functools.partial(get_source, name)\n            cache[filename] = (get_lines,)\n            return True\n    return False\n",177],"d:\\coding\\python3.6\\lib\\tokenize.py":["\"\"\"Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.\n\"\"\"\n\n__author__ = 'Ka-Ping Yee <ping@lfw.org>'\n__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '\n               'Skip Montanaro, Raymond Hettinger, Trent Nelson, '\n               'Michael Foord')\nfrom builtins import open as _builtin_open\nfrom codecs import lookup, BOM_UTF8\nimport collections\nfrom io import TextIOWrapper\nfrom itertools import chain\nimport itertools as _itertools\nimport re\nimport sys\nfrom token import *\n\ncookie_re = re.compile(r'^[ \\t\\f]*#.*?coding[:=][ \\t]*([-\\w.]+)', re.ASCII)\nblank_re = re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)', re.ASCII)\n\nimport token\n__all__ = token.__all__ + [\"COMMENT\", \"tokenize\", \"detect_encoding\",\n                           \"NL\", \"untokenize\", \"ENCODING\", \"TokenInfo\"]\ndel token\n\nCOMMENT = N_TOKENS\ntok_name[COMMENT] = 'COMMENT'\nNL = N_TOKENS + 1\ntok_name[NL] = 'NL'\nENCODING = N_TOKENS + 2\ntok_name[ENCODING] = 'ENCODING'\nN_TOKENS += 3\nEXACT_TOKEN_TYPES = {\n    '(':   LPAR,\n    ')':   RPAR,\n    '[':   LSQB,\n    ']':   RSQB,\n    ':':   COLON,\n    ',':   COMMA,\n    ';':   SEMI,\n    '+':   PLUS,\n    '-':   MINUS,\n    '*':   STAR,\n    '/':   SLASH,\n    '|':   VBAR,\n    '&':   AMPER,\n    '<':   LESS,\n    '>':   GREATER,\n    '=':   EQUAL,\n    '.':   DOT,\n    '%':   PERCENT,\n    '{':   LBRACE,\n    '}':   RBRACE,\n    '==':  EQEQUAL,\n    '!=':  NOTEQUAL,\n    '<=':  LESSEQUAL,\n    '>=':  GREATEREQUAL,\n    '~':   TILDE,\n    '^':   CIRCUMFLEX,\n    '<<':  LEFTSHIFT,\n    '>>':  RIGHTSHIFT,\n    '**':  DOUBLESTAR,\n    '+=':  PLUSEQUAL,\n    '-=':  MINEQUAL,\n    '*=':  STAREQUAL,\n    '/=':  SLASHEQUAL,\n    '%=':  PERCENTEQUAL,\n    '&=':  AMPEREQUAL,\n    '|=':  VBAREQUAL,\n    '^=': CIRCUMFLEXEQUAL,\n    '<<=': LEFTSHIFTEQUAL,\n    '>>=': RIGHTSHIFTEQUAL,\n    '**=': DOUBLESTAREQUAL,\n    '//':  DOUBLESLASH,\n    '//=': DOUBLESLASHEQUAL,\n    '@':   AT,\n    '@=':  ATEQUAL,\n}\n\nclass TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):\n    def __repr__(self):\n        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])\n        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %\n                self._replace(type=annotated_type))\n\n    @property\n    def exact_type(self):\n        if self.type == OP and self.string in EXACT_TOKEN_TYPES:\n            return EXACT_TOKEN_TYPES[self.string]\n        else:\n            return self.type\n\ndef group(*choices): return '(' + '|'.join(choices) + ')'\ndef any(*choices): return group(*choices) + '*'\ndef maybe(*choices): return group(*choices) + '?'\n\n# Note: we use unicode matching for names (\"\\w\") but ascii matching for\n# number literals.\nWhitespace = r'[ \\f\\t]*'\nComment = r'#[^\\r\\n]*'\nIgnore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\n\nHexnumber = r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber = r'0[bB](?:_?[01])+'\nOctnumber = r'0[oO](?:_?[0-7])+'\nDecnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n\n# Return the empty string, plus all of the valid string prefixes.\ndef _all_string_prefixes():\n    # The valid string prefixes. Only contain the lower case versions,\n    #  and don't contain any permuations (include 'fr', but not\n    #  'rf'). The various permutations will be generated.\n    _valid_string_prefixes = ['b', 'r', 'u', 'f', 'br', 'fr']\n    # if we add binary f-strings, add: ['fb', 'fbr']\n    result = set([''])\n    for prefix in _valid_string_prefixes:\n        for t in _itertools.permutations(prefix):\n            # create a list with upper and lower versions of each\n            #  character\n            for u in _itertools.product(*[(c, c.upper()) for c in t]):\n                result.add(''.join(u))\n    return result\n\ndef _compile(expr):\n    return re.compile(expr, re.UNICODE)\n\n# Note that since _all_string_prefixes includes the empty string,\n#  StringPrefix can be the empty string (making it optional).\nStringPrefix = group(*_all_string_prefixes())\n\n# Tail end of ' string.\nSingle = r\"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"\n# Tail end of \" string.\nDouble = r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'\n# Tail end of ''' string.\nSingle3 = r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n# Tail end of \"\"\" string.\nDouble3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')\n# Single-line ' or \" string.\nString = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\n               StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n\n# Because of leftmost-then-longest match semantics, be sure to put the\n# longest operators first (e.g., if = came before ==, == would get\n# recognized as two instances of =).\nOperator = group(r\"\\*\\*=?\", r\">>=?\", r\"<<=?\", r\"!=\",\n                 r\"//=?\", r\"->\",\n                 r\"[+\\-*/%&@|^=<>]=?\",\n                 r\"~\")\n\nBracket = '[][(){}]'\nSpecial = group(r'\\r?\\n', r'\\.\\.\\.', r'[:;.,@]')\nFunny = group(Operator, Bracket, Special)\n\nPlainToken = group(Number, Funny, String, Name)\nToken = Ignore + PlainToken\n\n# First (or only) line of ' or \" string.\nContStr = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +\n                group(\"'\", r'\\\\\\r?\\n'),\n                StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +\n                group('\"', r'\\\\\\r?\\n'))\nPseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)\nPseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n\n# For a given string prefix plus quotes, endpats maps it to a regex\n#  to match the remainder of that string. _prefix can be empty, for\n#  a normal single or triple quoted string (with no prefix).\nendpats = {}\nfor _prefix in _all_string_prefixes():\n    endpats[_prefix + \"'\"] = Single\n    endpats[_prefix + '\"'] = Double\n    endpats[_prefix + \"'''\"] = Single3\n    endpats[_prefix + '\"\"\"'] = Double3\n\n# A set of all of the single and triple quoted string prefixes,\n#  including the opening quotes.\nsingle_quoted = set()\ntriple_quoted = set()\nfor t in _all_string_prefixes():\n    for u in (t + '\"', t + \"'\"):\n        single_quoted.add(u)\n    for u in (t + '\"\"\"', t + \"'''\"):\n        triple_quoted.add(u)\n\ntabsize = 8\n\nclass TokenError(Exception): pass\n\nclass StopTokenizing(Exception): pass\n\n\nclass Untokenizer:\n\n    def __init__(self):\n        self.tokens = []\n        self.prev_row = 1\n        self.prev_col = 0\n        self.encoding = None\n\n    def add_whitespace(self, start):\n        row, col = start\n        if row < self.prev_row or row == self.prev_row and col < self.prev_col:\n            raise ValueError(\"start ({},{}) precedes previous end ({},{})\"\n                             .format(row, col, self.prev_row, self.prev_col))\n        row_offset = row - self.prev_row\n        if row_offset:\n            self.tokens.append(\"\\\\\\n\" * row_offset)\n            self.prev_col = 0\n        col_offset = col - self.prev_col\n        if col_offset:\n            self.tokens.append(\" \" * col_offset)\n\n    def untokenize(self, iterable):\n        it = iter(iterable)\n        indents = []\n        startline = False\n        for t in it:\n            if len(t) == 2:\n                self.compat(t, it)\n                break\n            tok_type, token, start, end, line = t\n            if tok_type == ENCODING:\n                self.encoding = token\n                continue\n            if tok_type == ENDMARKER:\n                break\n            if tok_type == INDENT:\n                indents.append(token)\n                continue\n            elif tok_type == DEDENT:\n                indents.pop()\n                self.prev_row, self.prev_col = end\n                continue\n            elif tok_type in (NEWLINE, NL):\n                startline = True\n            elif startline and indents:\n                indent = indents[-1]\n                if start[1] >= len(indent):\n                    self.tokens.append(indent)\n                    self.prev_col = len(indent)\n                startline = False\n            self.add_whitespace(start)\n            self.tokens.append(token)\n            self.prev_row, self.prev_col = end\n            if tok_type in (NEWLINE, NL):\n                self.prev_row += 1\n                self.prev_col = 0\n        return \"\".join(self.tokens)\n\n    def compat(self, token, iterable):\n        indents = []\n        toks_append = self.tokens.append\n        startline = token[0] in (NEWLINE, NL)\n        prevstring = False\n\n        for tok in chain([token], iterable):\n            toknum, tokval = tok[:2]\n            if toknum == ENCODING:\n                self.encoding = tokval\n                continue\n\n            if toknum in (NAME, NUMBER, ASYNC, AWAIT):\n                tokval += ' '\n\n            # Insert a space between two consecutive strings\n            if toknum == STRING:\n                if prevstring:\n                    tokval = ' ' + tokval\n                prevstring = True\n            else:\n                prevstring = False\n\n            if toknum == INDENT:\n                indents.append(tokval)\n                continue\n            elif toknum == DEDENT:\n                indents.pop()\n                continue\n            elif toknum in (NEWLINE, NL):\n                startline = True\n            elif startline and indents:\n                toks_append(indents[-1])\n                startline = False\n            toks_append(tokval)\n\n\ndef untokenize(iterable):\n    \"\"\"Transform tokens back into Python source code.\n    It returns a bytes object, encoded using the ENCODING\n    token, which is the first token sequence output by tokenize.\n\n    Each element returned by the iterable must be a token sequence\n    with at least two elements, a token number and token value.  If\n    only two tokens are passed, the resulting output is poor.\n\n    Round-trip invariant for full input:\n        Untokenized source will match input source exactly\n\n    Round-trip invariant for limited input:\n        # Output bytes will tokenize back to the input\n        t1 = [tok[:2] for tok in tokenize(f.readline)]\n        newcode = untokenize(t1)\n        readline = BytesIO(newcode).readline\n        t2 = [tok[:2] for tok in tokenize(readline)]\n        assert t1 == t2\n    \"\"\"\n    ut = Untokenizer()\n    out = ut.untokenize(iterable)\n    if ut.encoding is not None:\n        out = out.encode(ut.encoding)\n    return out\n\n\ndef _get_normal_name(orig_enc):\n    \"\"\"Imitates get_normal_name in tokenizer.c.\"\"\"\n    # Only care about the first 12 characters.\n    enc = orig_enc[:12].lower().replace(\"_\", \"-\")\n    if enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n        return \"utf-8\"\n    if enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or \\\n       enc.startswith((\"latin-1-\", \"iso-8859-1-\", \"iso-latin-1-\")):\n        return \"iso-8859-1\"\n    return orig_enc\n\ndef detect_encoding(readline):\n    \"\"\"\n    The detect_encoding() function is used to detect the encoding that should\n    be used to decode a Python source file.  It requires one argument, readline,\n    in the same way as the tokenize() generator.\n\n    It will call readline a maximum of twice, and return the encoding used\n    (as a string) and a list of any lines (left as bytes) it has read in.\n\n    It detects the encoding from the presence of a utf-8 bom or an encoding\n    cookie as specified in pep-0263.  If both a bom and a cookie are present,\n    but disagree, a SyntaxError will be raised.  If the encoding cookie is an\n    invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,\n    'utf-8-sig' is returned.\n\n    If no encoding is specified, then the default of 'utf-8' will be returned.\n    \"\"\"\n    try:\n        filename = readline.__self__.name\n    except AttributeError:\n        filename = None\n    bom_found = False\n    encoding = None\n    default = 'utf-8'\n    def read_or_stop():\n        try:\n            return readline()\n        except StopIteration:\n            return b''\n\n    def find_cookie(line):\n        try:\n            # Decode as UTF-8. Either the line is an encoding declaration,\n            # in which case it should be pure ASCII, or it must be UTF-8\n            # per default encoding.\n            line_string = line.decode('utf-8')\n        except UnicodeDecodeError:\n            msg = \"invalid or missing encoding declaration\"\n            if filename is not None:\n                msg = '{} for {!r}'.format(msg, filename)\n            raise SyntaxError(msg)\n\n        match = cookie_re.match(line_string)\n        if not match:\n            return None\n        encoding = _get_normal_name(match.group(1))\n        try:\n            codec = lookup(encoding)\n        except LookupError:\n            # This behaviour mimics the Python interpreter\n            if filename is None:\n                msg = \"unknown encoding: \" + encoding\n            else:\n                msg = \"unknown encoding for {!r}: {}\".format(filename,\n                        encoding)\n            raise SyntaxError(msg)\n\n        if bom_found:\n            if encoding != 'utf-8':\n                # This behaviour mimics the Python interpreter\n                if filename is None:\n                    msg = 'encoding problem: utf-8'\n                else:\n                    msg = 'encoding problem for {!r}: utf-8'.format(filename)\n                raise SyntaxError(msg)\n            encoding += '-sig'\n        return encoding\n\n    first = read_or_stop()\n    if first.startswith(BOM_UTF8):\n        bom_found = True\n        first = first[3:]\n        default = 'utf-8-sig'\n    if not first:\n        return default, []\n\n    encoding = find_cookie(first)\n    if encoding:\n        return encoding, [first]\n    if not blank_re.match(first):\n        return default, [first]\n\n    second = read_or_stop()\n    if not second:\n        return default, [first]\n\n    encoding = find_cookie(second)\n    if encoding:\n        return encoding, [first, second]\n\n    return default, [first, second]\n\n\ndef open(filename):\n    \"\"\"Open a file in read only mode using the encoding detected by\n    detect_encoding().\n    \"\"\"\n    buffer = _builtin_open(filename, 'rb')\n    try:\n        encoding, lines = detect_encoding(buffer.readline)\n        buffer.seek(0)\n        text = TextIOWrapper(buffer, encoding, line_buffering=True)\n        text.mode = 'r'\n        return text\n    except:\n        buffer.close()\n        raise\n\n\ndef tokenize(readline):\n    \"\"\"\n    The tokenize() generator requires one argument, readline, which\n    must be a callable object which provides the same interface as the\n    readline() method of built-in file objects.  Each call to the function\n    should return one line of input as bytes.  Alternatively, readline\n    can be a callable function terminating with StopIteration:\n        readline = open(myfile, 'rb').__next__  # Example of alternate readline\n\n    The generator produces 5-tuples with these members: the token type; the\n    token string; a 2-tuple (srow, scol) of ints specifying the row and\n    column where the token begins in the source; a 2-tuple (erow, ecol) of\n    ints specifying the row and column where the token ends in the source;\n    and the line on which the token was found.  The line passed is the\n    logical line; continuation lines are included.\n\n    The first token sequence will always be an ENCODING token\n    which tells you which encoding was used to decode the bytes stream.\n    \"\"\"\n    # This import is here to avoid problems when the itertools module is not\n    # built yet and tokenize is imported.\n    from itertools import chain, repeat\n    encoding, consumed = detect_encoding(readline)\n    rl_gen = iter(readline, b\"\")\n    empty = repeat(b\"\")\n    return _tokenize(chain(consumed, rl_gen, empty).__next__, encoding)\n\n\ndef _tokenize(readline, encoding):\n    lnum = parenlev = continued = 0\n    numchars = '0123456789'\n    contstr, needcont = '', 0\n    contline = None\n    indents = [0]\n\n    # 'stashed' and 'async_*' are used for async/await parsing\n    stashed = None\n    async_def = False\n    async_def_indent = 0\n    async_def_nl = False\n\n    if encoding is not None:\n        if encoding == \"utf-8-sig\":\n            # BOM will already have been stripped.\n            encoding = \"utf-8\"\n        yield TokenInfo(ENCODING, encoding, (0, 0), (0, 0), '')\n    last_line = b''\n    line = b''\n    while True:                                # loop over lines in stream\n        try:\n            # We capture the value of the line variable here because\n            # readline uses the empty string '' to signal end of input,\n            # hence `line` itself will always be overwritten at the end\n            # of this loop.\n            last_line = line\n            line = readline()\n        except StopIteration:\n            line = b''\n\n        if encoding is not None:\n            line = line.decode(encoding)\n        lnum += 1\n        pos, max = 0, len(line)\n\n        if contstr:                            # continued string\n            if not line:\n                raise TokenError(\"EOF in multi-line string\", strstart)\n            endmatch = endprog.match(line)\n            if endmatch:\n                pos = end = endmatch.end(0)\n                yield TokenInfo(STRING, contstr + line[:end],\n                       strstart, (lnum, end), contline + line)\n                contstr, needcont = '', 0\n                contline = None\n            elif needcont and line[-2:] != '\\\\\\n' and line[-3:] != '\\\\\\r\\n':\n                yield TokenInfo(ERRORTOKEN, contstr + line,\n                           strstart, (lnum, len(line)), contline)\n                contstr = ''\n                contline = None\n                continue\n            else:\n                contstr = contstr + line\n                contline = contline + line\n                continue\n\n        elif parenlev == 0 and not continued:  # new statement\n            if not line: break\n            column = 0\n            while pos < max:                   # measure leading whitespace\n                if line[pos] == ' ':\n                    column += 1\n                elif line[pos] == '\\t':\n                    column = (column//tabsize + 1)*tabsize\n                elif line[pos] == '\\f':\n                    column = 0\n                else:\n                    break\n                pos += 1\n            if pos == max:\n                break\n\n            if line[pos] in '#\\r\\n':           # skip comments or blank lines\n                if line[pos] == '#':\n                    comment_token = line[pos:].rstrip('\\r\\n')\n                    nl_pos = pos + len(comment_token)\n                    yield TokenInfo(COMMENT, comment_token,\n                           (lnum, pos), (lnum, pos + len(comment_token)), line)\n                    yield TokenInfo(NL, line[nl_pos:],\n                           (lnum, nl_pos), (lnum, len(line)), line)\n                else:\n                    yield TokenInfo((NL, COMMENT)[line[pos] == '#'], line[pos:],\n                           (lnum, pos), (lnum, len(line)), line)\n                continue\n\n            if column > indents[-1]:           # count indents or dedents\n                indents.append(column)\n                yield TokenInfo(INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n            while column < indents[-1]:\n                if column not in indents:\n                    raise IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        (\"<tokenize>\", lnum, pos, line))\n                indents = indents[:-1]\n\n                if async_def and async_def_indent >= indents[-1]:\n                    async_def = False\n                    async_def_nl = False\n                    async_def_indent = 0\n\n                yield TokenInfo(DEDENT, '', (lnum, pos), (lnum, pos), line)\n\n            if async_def and async_def_nl and async_def_indent >= indents[-1]:\n                async_def = False\n                async_def_nl = False\n                async_def_indent = 0\n\n        else:                                  # continued statement\n            if not line:\n                raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\n            continued = 0\n\n        while pos < max:\n            pseudomatch = _compile(PseudoToken).match(line, pos)\n            if pseudomatch:                                # scan for tokens\n                start, end = pseudomatch.span(1)\n                spos, epos, pos = (lnum, start), (lnum, end), end\n                if start == end:\n                    continue\n                token, initial = line[start:end], line[start]\n\n                if (initial in numchars or                  # ordinary number\n                    (initial == '.' and token != '.' and token != '...')):\n                    yield TokenInfo(NUMBER, token, spos, epos, line)\n                elif initial in '\\r\\n':\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    if parenlev > 0:\n                        yield TokenInfo(NL, token, spos, epos, line)\n                    else:\n                        yield TokenInfo(NEWLINE, token, spos, epos, line)\n                        if async_def:\n                            async_def_nl = True\n\n                elif initial == '#':\n                    assert not token.endswith(\"\\n\")\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield TokenInfo(COMMENT, token, spos, epos, line)\n\n                elif token in triple_quoted:\n                    endprog = _compile(endpats[token])\n                    endmatch = endprog.match(line, pos)\n                    if endmatch:                           # all on one line\n                        pos = endmatch.end(0)\n                        token = line[start:pos]\n                        yield TokenInfo(STRING, token, spos, (lnum, pos), line)\n                    else:\n                        strstart = (lnum, start)           # multiple lines\n                        contstr = line[start:]\n                        contline = line\n                        break\n\n                # Check up to the first 3 chars of the token to see if\n                #  they're in the single_quoted set. If so, they start\n                #  a string.\n                # We're using the first 3, because we're looking for\n                #  \"rb'\" (for example) at the start of the token. If\n                #  we switch to longer prefixes, this needs to be\n                #  adjusted.\n                # Note that initial == token[:1].\n                # Also note that single quote checking must come after\n                #  triple quote checking (above).\n                elif (initial in single_quoted or\n                      token[:2] in single_quoted or\n                      token[:3] in single_quoted):\n                    if token[-1] == '\\n':                  # continued string\n                        strstart = (lnum, start)\n                        # Again, using the first 3 chars of the\n                        #  token. This is looking for the matching end\n                        #  regex for the correct type of quote\n                        #  character. So it's really looking for\n                        #  endpats[\"'\"] or endpats['\"'], by trying to\n                        #  skip string prefix characters, if any.\n                        endprog = _compile(endpats.get(initial) or\n                                           endpats.get(token[1]) or\n                                           endpats.get(token[2]))\n                        contstr, needcont = line[start:], 1\n                        contline = line\n                        break\n                    else:                                  # ordinary string\n                        yield TokenInfo(STRING, token, spos, epos, line)\n\n                elif initial.isidentifier():               # ordinary name\n                    if token in ('async', 'await'):\n                        if async_def:\n                            yield TokenInfo(\n                                ASYNC if token == 'async' else AWAIT,\n                                token, spos, epos, line)\n                            continue\n\n                    tok = TokenInfo(NAME, token, spos, epos, line)\n                    if token == 'async' and not stashed:\n                        stashed = tok\n                        continue\n\n                    if token == 'def':\n                        if (stashed\n                                and stashed.type == NAME\n                                and stashed.string == 'async'):\n\n                            async_def = True\n                            async_def_indent = indents[-1]\n\n                            yield TokenInfo(ASYNC, stashed.string,\n                                            stashed.start, stashed.end,\n                                            stashed.line)\n                            stashed = None\n\n                    if stashed:\n                        yield stashed\n                        stashed = None\n\n                    yield tok\n                elif initial == '\\\\':                      # continued stmt\n                    continued = 1\n                else:\n                    if initial in '([{':\n                        parenlev += 1\n                    elif initial in ')]}':\n                        parenlev -= 1\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield TokenInfo(OP, token, spos, epos, line)\n            else:\n                yield TokenInfo(ERRORTOKEN, line[pos],\n                           (lnum, pos), (lnum, pos+1), line)\n                pos += 1\n\n    if stashed:\n        yield stashed\n        stashed = None\n\n    # Add an implicit NEWLINE if the input doesn't end in one\n    if last_line and last_line[-1] not in '\\r\\n':\n        yield TokenInfo(NEWLINE, '', (lnum - 1, len(last_line)), (lnum - 1, len(last_line) + 1), '')\n    for indent in indents[1:]:                 # pop remaining indent levels\n        yield TokenInfo(DEDENT, '', (lnum, 0), (lnum, 0), '')\n    yield TokenInfo(ENDMARKER, '', (lnum, 0), (lnum, 0), '')\n\n\n# An undocumented, backwards compatible, API for all the places in the standard\n# library that expect to be able to use tokenize with strings\ndef generate_tokens(readline):\n    return _tokenize(readline, None)\n\ndef main():\n    import argparse\n\n    # Helper error handling routines\n    def perror(message):\n        print(message, file=sys.stderr)\n\n    def error(message, filename=None, location=None):\n        if location:\n            args = (filename,) + location + (message,)\n            perror(\"%s:%d:%d: error: %s\" % args)\n        elif filename:\n            perror(\"%s: error: %s\" % (filename, message))\n        else:\n            perror(\"error: %s\" % message)\n        sys.exit(1)\n\n    # Parse the arguments and options\n    parser = argparse.ArgumentParser(prog='python -m tokenize')\n    parser.add_argument(dest='filename', nargs='?',\n                        metavar='filename.py',\n                        help='the file to tokenize; defaults to stdin')\n    parser.add_argument('-e', '--exact', dest='exact', action='store_true',\n                        help='display token names using the exact type')\n    args = parser.parse_args()\n\n    try:\n        # Tokenize the input\n        if args.filename:\n            filename = args.filename\n            with _builtin_open(filename, 'rb') as f:\n                tokens = list(tokenize(f.readline))\n        else:\n            filename = \"<stdin>\"\n            tokens = _tokenize(sys.stdin.readline, None)\n\n        # Output the tokenization\n        for token in tokens:\n            token_type = token.type\n            if args.exact:\n                token_type = token.exact_type\n            token_range = \"%d,%d-%d,%d:\" % (token.start + token.end)\n            print(\"%-20s%-15s%-15r\" %\n                  (token_range, tok_name[token_type], token.string))\n    except IndentationError as err:\n        line, column = err.args[1][1:3]\n        error(err.args[0], filename, (line, column))\n    except TokenError as err:\n        line, column = err.args[1]\n        error(err.args[0], filename, (line, column))\n    except SyntaxError as err:\n        error(err, filename)\n    except OSError as err:\n        error(err)\n    except KeyboardInterrupt:\n        print(\"interrupted\\n\")\n    except Exception as err:\n        perror(\"unexpected error: %s\" % err)\n        raise\n\nif __name__ == \"__main__\":\n    main()\n",803]},"functions":{"_acquireLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:219)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",219],"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:685)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",685],"_checkLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:190)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",190],"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1268)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1268],"_fixupParents (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1212)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1212],"_releaseLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:228)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",228],"getLogger (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1161)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1161],"getLogger (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1838)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1838],"setLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1280)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1280],"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:384)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",384],"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:471)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",471],"splitdrive (d:\\coding\\python3.6\\lib\\ntpath.py:122)":["d:\\coding\\python3.6\\lib\\ntpath.py",122],"normpath (d:\\coding\\python3.6\\lib\\ntpath.py:472)":["d:\\coding\\python3.6\\lib\\ntpath.py",472],"abspath (d:\\coding\\python3.6\\lib\\ntpath.py:545)":["d:\\coding\\python3.6\\lib\\ntpath.py",545],"getpreferredencoding (d:\\coding\\python3.6\\lib\\_bootlocale.py:11)":["d:\\coding\\python3.6\\lib\\_bootlocale.py",11],"setstate (d:\\coding\\python3.6\\lib\\codecs.py:213)":["d:\\coding\\python3.6\\lib\\codecs.py",213],"_open (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1056)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1056],"_addHandlerRef (d:\\coding\\python3.6\\lib\\logging\\__init__.py:752)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",752],"RLock (d:\\coding\\python3.6\\lib\\threading.py:74)":["d:\\coding\\python3.6\\lib\\threading.py",74],"createLock (d:\\coding\\python3.6\\lib\\logging\\__init__.py:800)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",800],"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:771)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",771],"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:960)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",960],"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1014)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1014],"setLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:823)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",823],"setFormatter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:870)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",870],"addHandler (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1456)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1456],"init_logger (C:\\Users\\libuliduobuqiuqiu\\Desktop\\GitProjects\\PythonDemo\\Logging\\logging_example.py:12)":["C:\\Users\\libuliduobuqiuqiu\\Desktop\\GitProjects\\PythonDemo\\Logging\\logging_example.py",12],"getEffectiveLevel (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1530)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1530],"isEnabledFor (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1544)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1544],"<lambda> (d:\\coding\\python3.6\\lib\\logging\\__init__.py:157)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",157],"normcase (d:\\coding\\python3.6\\lib\\ntpath.py:44)":["d:\\coding\\python3.6\\lib\\ntpath.py",44],"findCaller (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1376)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1376],"getLevelName (d:\\coding\\python3.6\\lib\\logging\\__init__.py:120)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",120],"_get_bothseps (d:\\coding\\python3.6\\lib\\ntpath.py:34)":["d:\\coding\\python3.6\\lib\\ntpath.py",34],"split (d:\\coding\\python3.6\\lib\\ntpath.py:200)":["d:\\coding\\python3.6\\lib\\ntpath.py",200],"basename (d:\\coding\\python3.6\\lib\\ntpath.py:234)":["d:\\coding\\python3.6\\lib\\ntpath.py",234],"_splitext (d:\\coding\\python3.6\\lib\\genericpath.py:117)":["d:\\coding\\python3.6\\lib\\genericpath.py",117],"splitext (d:\\coding\\python3.6\\lib\\ntpath.py:223)":["d:\\coding\\python3.6\\lib\\ntpath.py",223],"current_thread (d:\\coding\\python3.6\\lib\\threading.py:1230)":["d:\\coding\\python3.6\\lib\\threading.py",1230],"name (d:\\coding\\python3.6\\lib\\threading.py:1076)":["d:\\coding\\python3.6\\lib\\threading.py",1076],"current_process (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:35)":["d:\\coding\\python3.6\\lib\\multiprocessing\\process.py",35],"name (d:\\coding\\python3.6\\lib\\multiprocessing\\process.py:146)":["d:\\coding\\python3.6\\lib\\multiprocessing\\process.py",146],"__init__ (d:\\coding\\python3.6\\lib\\logging\\__init__.py:251)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",251],"makeRecord (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1406)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1406],"filter (d:\\coding\\python3.6\\lib\\logging\\__init__.py:705)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",705],"acquire (d:\\coding\\python3.6\\lib\\logging\\__init__.py:809)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",809],"getMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:329)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",329],"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:387)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",387],"usesTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:542)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",542],"formatTime (d:\\coding\\python3.6\\lib\\logging\\__init__.py:497)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",497],"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:390)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",390],"formatMessage (d:\\coding\\python3.6\\lib\\logging\\__init__.py:548)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",548],"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:564)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",564],"format (d:\\coding\\python3.6\\lib\\logging\\__init__.py:829)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",829],"release (d:\\coding\\python3.6\\lib\\logging\\__init__.py:816)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",816],"flush (d:\\coding\\python3.6\\lib\\logging\\__init__.py:971)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",971],"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:982)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",982],"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:852)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",852],"callHandlers (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1500)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1500],"handle (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1446)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1446],"_log (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1421)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1421],"debug (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1286)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1286],"info (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1298)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1298],"emit (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1063)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1063],"warning (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1310)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1310],"error (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1327)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1327],"critical (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1345)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1345],"log (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1359)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1359],"walk_tb (d:\\coding\\python3.6\\lib\\traceback.py:303)":["d:\\coding\\python3.6\\lib\\traceback.py",303],"lazycache (d:\\coding\\python3.6\\lib\\linecache.py:147)":["d:\\coding\\python3.6\\lib\\linecache.py",147],"__init__ (d:\\coding\\python3.6\\lib\\traceback.py:243)":["d:\\coding\\python3.6\\lib\\traceback.py",243],"checkcache (d:\\coding\\python3.6\\lib\\linecache.py:53)":["d:\\coding\\python3.6\\lib\\linecache.py",53],"read_or_stop (d:\\coding\\python3.6\\lib\\tokenize.py:379)":["d:\\coding\\python3.6\\lib\\tokenize.py",379],"_get_normal_name (d:\\coding\\python3.6\\lib\\tokenize.py:344)":["d:\\coding\\python3.6\\lib\\tokenize.py",344],"find_cookie (d:\\coding\\python3.6\\lib\\tokenize.py:385)":["d:\\coding\\python3.6\\lib\\tokenize.py",385],"detect_encoding (d:\\coding\\python3.6\\lib\\tokenize.py:355)":["d:\\coding\\python3.6\\lib\\tokenize.py",355],"__init__ (d:\\coding\\python3.6\\lib\\codecs.py:259)":["d:\\coding\\python3.6\\lib\\codecs.py",259],"__init__ (d:\\coding\\python3.6\\lib\\codecs.py:308)":["d:\\coding\\python3.6\\lib\\codecs.py",308],"open (d:\\coding\\python3.6\\lib\\tokenize.py:448)":["d:\\coding\\python3.6\\lib\\tokenize.py",448],"decode (d:\\coding\\python3.6\\lib\\codecs.py:318)":["d:\\coding\\python3.6\\lib\\codecs.py",318],"updatecache (d:\\coding\\python3.6\\lib\\linecache.py:82)":["d:\\coding\\python3.6\\lib\\linecache.py",82],"getlines (d:\\coding\\python3.6\\lib\\linecache.py:37)":["d:\\coding\\python3.6\\lib\\linecache.py",37],"getline (d:\\coding\\python3.6\\lib\\linecache.py:15)":["d:\\coding\\python3.6\\lib\\linecache.py",15],"line (d:\\coding\\python3.6\\lib\\traceback.py:283)":["d:\\coding\\python3.6\\lib\\traceback.py",283],"extract (d:\\coding\\python3.6\\lib\\traceback.py:319)":["d:\\coding\\python3.6\\lib\\traceback.py",319],"_some_str (d:\\coding\\python3.6\\lib\\traceback.py:153)":["d:\\coding\\python3.6\\lib\\traceback.py",153],"_load_lines (d:\\coding\\python3.6\\lib\\traceback.py:529)":["d:\\coding\\python3.6\\lib\\traceback.py",529],"__init__ (d:\\coding\\python3.6\\lib\\traceback.py:466)":["d:\\coding\\python3.6\\lib\\traceback.py",466],"format (d:\\coding\\python3.6\\lib\\traceback.py:589)":["d:\\coding\\python3.6\\lib\\traceback.py",589],"format (d:\\coding\\python3.6\\lib\\traceback.py:386)":["d:\\coding\\python3.6\\lib\\traceback.py",386],"_format_final_exc_line (d:\\coding\\python3.6\\lib\\traceback.py:145)":["d:\\coding\\python3.6\\lib\\traceback.py",145],"format_exception_only (d:\\coding\\python3.6\\lib\\traceback.py:544)":["d:\\coding\\python3.6\\lib\\traceback.py",544],"print_exception (d:\\coding\\python3.6\\lib\\traceback.py:87)":["d:\\coding\\python3.6\\lib\\traceback.py",87],"formatException (d:\\coding\\python3.6\\lib\\logging\\__init__.py:523)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",523],"exception (d:\\coding\\python3.6\\lib\\logging\\__init__.py:1339)":["d:\\coding\\python3.6\\lib\\logging\\__init__.py",1339],"<module> (C:\\Users\\libuliduobuqiuqiu\\Desktop\\GitProjects\\PythonDemo\\Logging\\logging_example.py:6)":["C:\\Users\\libuliduobuqiuqiu\\Desktop\\GitProjects\\PythonDemo\\Logging\\logging_example.py",6]}}}